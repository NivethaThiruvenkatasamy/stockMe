import { Component, Input, Inject, forwardRef, Optional } from '@angular/core';
import { connectSortBy } from 'instantsearch.js/es/connectors';
import { TypedBaseWidget } from '../typed-base-widget';
import { NgAisInstantSearch } from '../instantsearch/instantsearch';
import { NgAisIndex } from '../index-widget/index-widget';
import { noop } from '../utils';
export class NgAisSortBy extends TypedBaseWidget {
    constructor(parentIndex, instantSearchInstance) {
        super('SortBy');
        this.parentIndex = parentIndex;
        this.instantSearchInstance = instantSearchInstance;
        this.state = {
            currentRefinement: null,
            options: [],
            refine: noop,
            hasNoResults: false,
        };
    }
    ngOnInit() {
        this.createWidget(connectSortBy, {
            items: this.items,
            transformItems: this.transformItems,
        });
        super.ngOnInit();
    }
}
NgAisSortBy.decorators = [
    { type: Component, args: [{
                selector: 'ais-sort-by',
                template: `
    <div [class]="cx()">
      <select
        [class]="cx('select')"
        (change)="state.refine($event.target.value)"
      >
        <option
          [class]="cx('option')"
          *ngFor="let item of state.options"
          [value]="item.value"
          [selected]="item.value === state.currentRefinement"
        >
          {{item.label}}
        </option>
      </select>
    </div>
  `
            },] }
];
NgAisSortBy.ctorParameters = () => [
    { type: NgAisIndex, decorators: [{ type: Inject, args: [forwardRef(() => NgAisIndex),] }, { type: Optional }] },
    { type: NgAisInstantSearch, decorators: [{ type: Inject, args: [forwardRef(() => NgAisInstantSearch),] }] }
];
NgAisSortBy.propDecorators = {
    items: [{ type: Input }],
    transformItems: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC1ieS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zb3J0LWJ5L3NvcnQtYnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFL0UsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQy9ELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUN2RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNwRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDMUQsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLFVBQVUsQ0FBQztBQXFDaEMsTUFBTSxPQUFPLFdBQVksU0FBUSxlQUdoQztJQVlDLFlBR1MsV0FBdUIsRUFFdkIscUJBQXlDO1FBRWhELEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUpULGdCQUFXLEdBQVgsV0FBVyxDQUFZO1FBRXZCLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBb0I7UUFaM0MsVUFBSyxHQUFzQjtZQUNoQyxpQkFBaUIsRUFBRSxJQUFJO1lBQ3ZCLE9BQU8sRUFBRSxFQUFFO1lBQ1gsTUFBTSxFQUFFLElBQUk7WUFDWixZQUFZLEVBQUUsS0FBSztTQUNwQixDQUFDO0lBVUYsQ0FBQztJQUVNLFFBQVE7UUFDYixJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRTtZQUMvQixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7WUFDakIsY0FBYyxFQUFFLElBQUksQ0FBQyxjQUFjO1NBQ3BDLENBQUMsQ0FBQztRQUNILEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNuQixDQUFDOzs7WUFuREYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxhQUFhO2dCQUN2QixRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQlQ7YUFDRjs7O1lBckNRLFVBQVUsdUJBc0RkLE1BQU0sU0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQ25DLFFBQVE7WUF4REosa0JBQWtCLHVCQTBEdEIsTUFBTSxTQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQzs7O29CQWY3QyxLQUFLOzZCQUNMLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBJbmplY3QsIGZvcndhcmRSZWYsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IGNvbm5lY3RTb3J0QnkgfSBmcm9tICdpbnN0YW50c2VhcmNoLmpzL2VzL2Nvbm5lY3RvcnMnO1xuaW1wb3J0IHsgVHlwZWRCYXNlV2lkZ2V0IH0gZnJvbSAnLi4vdHlwZWQtYmFzZS13aWRnZXQnO1xuaW1wb3J0IHsgTmdBaXNJbnN0YW50U2VhcmNoIH0gZnJvbSAnLi4vaW5zdGFudHNlYXJjaC9pbnN0YW50c2VhcmNoJztcbmltcG9ydCB7IE5nQWlzSW5kZXggfSBmcm9tICcuLi9pbmRleC13aWRnZXQvaW5kZXgtd2lkZ2V0JztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQge1xuICBTb3J0QnlDb25uZWN0b3IsXG4gIFNvcnRCeUNvbm5lY3RvclBhcmFtcyxcbiAgU29ydEJ5V2lkZ2V0RGVzY3JpcHRpb24sXG4gIFNvcnRCeVJlbmRlclN0YXRlLFxuICBTb3J0QnlJdGVtLFxufSBmcm9tICdpbnN0YW50c2VhcmNoLmpzL2VzL2Nvbm5lY3RvcnMvc29ydC1ieS9jb25uZWN0U29ydEJ5JztcblxuZXhwb3J0IHtcbiAgU29ydEJ5Q29ubmVjdG9yLFxuICBTb3J0QnlDb25uZWN0b3JQYXJhbXMsXG4gIFNvcnRCeVdpZGdldERlc2NyaXB0aW9uLFxuICBTb3J0QnlSZW5kZXJTdGF0ZSxcbiAgU29ydEJ5SXRlbSxcbn07XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Fpcy1zb3J0LWJ5JyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IFtjbGFzc109XCJjeCgpXCI+XG4gICAgICA8c2VsZWN0XG4gICAgICAgIFtjbGFzc109XCJjeCgnc2VsZWN0JylcIlxuICAgICAgICAoY2hhbmdlKT1cInN0YXRlLnJlZmluZSgkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXG4gICAgICA+XG4gICAgICAgIDxvcHRpb25cbiAgICAgICAgICBbY2xhc3NdPVwiY3goJ29wdGlvbicpXCJcbiAgICAgICAgICAqbmdGb3I9XCJsZXQgaXRlbSBvZiBzdGF0ZS5vcHRpb25zXCJcbiAgICAgICAgICBbdmFsdWVdPVwiaXRlbS52YWx1ZVwiXG4gICAgICAgICAgW3NlbGVjdGVkXT1cIml0ZW0udmFsdWUgPT09IHN0YXRlLmN1cnJlbnRSZWZpbmVtZW50XCJcbiAgICAgICAgPlxuICAgICAgICAgIHt7aXRlbS5sYWJlbH19XG4gICAgICAgIDwvb3B0aW9uPlxuICAgICAgPC9zZWxlY3Q+XG4gICAgPC9kaXY+XG4gIGAsXG59KVxuZXhwb3J0IGNsYXNzIE5nQWlzU29ydEJ5IGV4dGVuZHMgVHlwZWRCYXNlV2lkZ2V0PFxuICBTb3J0QnlXaWRnZXREZXNjcmlwdGlvbixcbiAgU29ydEJ5Q29ubmVjdG9yUGFyYW1zXG4+IHtcbiAgQElucHV0KCkgcHVibGljIGl0ZW1zOiBTb3J0QnlJdGVtW107XG4gIEBJbnB1dCgpXG4gIHB1YmxpYyB0cmFuc2Zvcm1JdGVtcz86IDxVIGV4dGVuZHMgU29ydEJ5SXRlbT4oaXRlbXM6IFNvcnRCeUl0ZW1bXSkgPT4gVVtdO1xuXG4gIHB1YmxpYyBzdGF0ZTogU29ydEJ5UmVuZGVyU3RhdGUgPSB7XG4gICAgY3VycmVudFJlZmluZW1lbnQ6IG51bGwsXG4gICAgb3B0aW9uczogW10sXG4gICAgcmVmaW5lOiBub29wLFxuICAgIGhhc05vUmVzdWx0czogZmFsc2UsXG4gIH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IE5nQWlzSW5kZXgpKVxuICAgIEBPcHRpb25hbCgpXG4gICAgcHVibGljIHBhcmVudEluZGV4OiBOZ0Fpc0luZGV4LFxuICAgIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBOZ0Fpc0luc3RhbnRTZWFyY2gpKVxuICAgIHB1YmxpYyBpbnN0YW50U2VhcmNoSW5zdGFuY2U6IE5nQWlzSW5zdGFudFNlYXJjaFxuICApIHtcbiAgICBzdXBlcignU29ydEJ5Jyk7XG4gIH1cblxuICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5jcmVhdGVXaWRnZXQoY29ubmVjdFNvcnRCeSwge1xuICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICB0cmFuc2Zvcm1JdGVtczogdGhpcy50cmFuc2Zvcm1JdGVtcyxcbiAgICB9KTtcbiAgICBzdXBlci5uZ09uSW5pdCgpO1xuICB9XG59XG4iXX0=