import { Component, Input, Inject, forwardRef, Optional } from '@angular/core';
import { connectPagination } from 'instantsearch.js/es/connectors';
import { TypedBaseWidget } from '../typed-base-widget';
import { NgAisInstantSearch } from '../instantsearch/instantsearch';
import { NgAisIndex } from '../index-widget/index-widget';
import { parseNumberInput, noop, range } from '../utils';
export class NgAisPagination extends TypedBaseWidget {
    constructor(parentIndex, instantSearchInstance) {
        super('Pagination');
        this.parentIndex = parentIndex;
        this.instantSearchInstance = instantSearchInstance;
        // rendering options
        this.showFirst = true;
        this.showLast = true;
        this.showPrevious = true;
        this.showNext = true;
        // instance options
        this.padding = 3;
        // TODO: check if this works, padding and totalPages are most likely strings when passed to the template
        this.state = {
            createURL: () => '#',
            currentRefinement: 0,
            nbHits: 0,
            nbPages: 0,
            refine: noop,
            pages: [],
            canRefine: false,
            isFirstPage: false,
            isLastPage: false,
        };
    }
    get pages() {
        const { nbPages, currentRefinement } = this.state;
        const pagesArray = Array.apply(null, { length: nbPages }).map(Number.call, Number);
        const pagesPadding = typeof this.padding === 'string'
            ? parseInt(this.padding, 10)
            : this.padding;
        if (pagesPadding && pagesPadding > 0) {
            // should not display pages that does not exists
            if (nbPages < pagesPadding * 2 + 1) {
                return pagesArray;
            }
            const minDelta = currentRefinement - pagesPadding - 1;
            const maxDelta = currentRefinement + pagesPadding + 1;
            if (minDelta < 0) {
                return range({
                    start: 0,
                    end: currentRefinement + pagesPadding + Math.abs(minDelta),
                });
            }
            if (maxDelta > nbPages) {
                return range({
                    start: currentRefinement - pagesPadding - (maxDelta - nbPages),
                    end: nbPages,
                });
            }
            return range({
                start: currentRefinement - pagesPadding,
                end: currentRefinement + pagesPadding + 1,
            });
        }
        return pagesArray;
    }
    ngOnInit() {
        this.createWidget(connectPagination, {
            totalPages: parseNumberInput(this.totalPages),
        });
        super.ngOnInit();
    }
    refine(event, page) {
        event.stopPropagation();
        event.preventDefault();
        if (page < 0 ||
            page === this.state.currentRefinement ||
            page >= this.state.nbPages) {
            return;
        }
        this.state.refine(page);
    }
}
NgAisPagination.decorators = [
    { type: Component, args: [{
                selector: 'ais-pagination',
                template: `
    <div [ngClass]="[cx(), state.nbPages <= 1 ? cx('', 'noRefinement') : '']">
      <ul [class]="cx('list')">
        <li
          *ngIf="showFirst"
          (click)="refine($event, 0)"
          [class]="
            cx('item') +
            ' ' +
            cx('item', 'firstPage') +
            (state.currentRefinement === 0 ? ' ' + cx('item', 'disabled') : '')
          "
        >
          <a
            [href]="state.createURL(0)"
            [class]="cx('link')"
          >
            ‹‹
          </a>
        </li>

        <li
          *ngIf="showPrevious"
          (click)="refine($event, state.currentRefinement - 1)"
          [class]="
            cx('item') +
            ' ' +
            cx('item', 'previousPage') +
            (state.currentRefinement === 0 ? ' ' + cx('item', 'disabled') : '')
          "
        >
          <a
            [href]="state.createURL(state.currentRefinement - 1)"
            [class]="cx('link')"
          >
            ‹
          </a>
        </li>

        <li
          [class]="
            cx('item') +
            ' ' +
            cx('item', 'page') +
            (state.currentRefinement === page ? ' ' + cx('item', 'selected') : '')
          "
          *ngFor="let page of pages"
          (click)="refine($event, page)"
        >
          <a
            [class]="cx('link')"
            [href]="state.createURL(page)"
          >
            {{page + 1}}
          </a>
        </li>

        <li
          *ngIf="showNext"
          (click)="refine($event, state.currentRefinement + 1)"
          [class]="
            cx('item') +
            ' ' +
            cx('item', 'nextPage') +
            (state.currentRefinement + 1 === state.nbPages ? ' ' + cx('item', 'disabled') : '')
          "
        >
          <a
            [href]="state.createURL(state.currentRefinement + 1)"
            [class]="cx('link')"
          >
            ›
          </a>
        </li>

        <li
          *ngIf="showLast"
          (click)="refine($event, state.nbPages - 1)"
          [class]="
            cx('item') +
            ' ' +
            cx('item', 'lastPage') +
            (state.currentRefinement + 1 === state.nbPages ? ' ' + cx('item', 'disabled') : '')
          "
        >
          <a
            [href]="state.createURL(state.nbPages - 1)"
            [class]="cx('link')"
          >
            ››
          </a>
        </li>
      </ul>
    </div>
  `
            },] }
];
NgAisPagination.ctorParameters = () => [
    { type: NgAisIndex, decorators: [{ type: Inject, args: [forwardRef(() => NgAisIndex),] }, { type: Optional }] },
    { type: NgAisInstantSearch, decorators: [{ type: Inject, args: [forwardRef(() => NgAisInstantSearch),] }] }
];
NgAisPagination.propDecorators = {
    showFirst: [{ type: Input }],
    showLast: [{ type: Input }],
    showPrevious: [{ type: Input }],
    showNext: [{ type: Input }],
    padding: [{ type: Input }],
    totalPages: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnaW5hdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wYWdpbmF0aW9uL3BhZ2luYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDL0UsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDbkUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxNQUFNLFVBQVUsQ0FBQztBQTJHekQsTUFBTSxPQUFPLGVBQWdCLFNBQVEsZUFHcEM7SUFxRUMsWUFHUyxXQUF1QixFQUV2QixxQkFBeUM7UUFFaEQsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBSmIsZ0JBQVcsR0FBWCxXQUFXLENBQVk7UUFFdkIsMEJBQXFCLEdBQXJCLHFCQUFxQixDQUFvQjtRQXpFbEQsb0JBQW9CO1FBQ0osY0FBUyxHQUFZLElBQUksQ0FBQztRQUMxQixhQUFRLEdBQVksSUFBSSxDQUFDO1FBQ3pCLGlCQUFZLEdBQVksSUFBSSxDQUFDO1FBQzdCLGFBQVEsR0FBWSxJQUFJLENBQUM7UUFFekMsbUJBQW1CO1FBQ0gsWUFBTyxHQUF5QyxDQUFDLENBQUM7UUFFbEUsd0dBQXdHO1FBRWpHLFVBQUssR0FBMEI7WUFDcEMsU0FBUyxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUc7WUFDcEIsaUJBQWlCLEVBQUUsQ0FBQztZQUNwQixNQUFNLEVBQUUsQ0FBQztZQUNULE9BQU8sRUFBRSxDQUFDO1lBQ1YsTUFBTSxFQUFF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VUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLFVBQVUsQ0FBQyxjQUNuQyxRQUFRO1lBdkxKLGtCQUFrQix1QkF5THRCLE1BQU0sU0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUM7Ozt3QkF2RTdDLEtBQUs7dUJBQ0wsS0FBSzsyQkFDTCxLQUFLO3VCQUNMLEtBQUs7c0JBR0wsS0FBSzt5QkFDTCxLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgSW5qZWN0LCBmb3J3YXJkUmVmLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29ubmVjdFBhZ2luYXRpb24gfSBmcm9tICdpbnN0YW50c2VhcmNoLmpzL2VzL2Nvbm5lY3RvcnMnO1xuaW1wb3J0IHsgVHlwZWRCYXNlV2lkZ2V0IH0gZnJvbSAnLi4vdHlwZWQtYmFzZS13aWRnZXQnO1xuaW1wb3J0IHsgTmdBaXNJbnN0YW50U2VhcmNoIH0gZnJvbSAnLi4vaW5zdGFudHNlYXJjaC9pbnN0YW50c2VhcmNoJztcbmltcG9ydCB7IE5nQWlzSW5kZXggfSBmcm9tICcuLi9pbmRleC13aWRnZXQvaW5kZXgtd2lkZ2V0JztcbmltcG9ydCB7IHBhcnNlTnVtYmVySW5wdXQsIG5vb3AsIHJhbmdlIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtcbiAgUGFnaW5hdGlvbkNvbm5lY3RvclBhcmFtcyxcbiAgUGFnaW5hdGlvbldpZGdldERlc2NyaXB0aW9uLFxuICBQYWdpbmF0aW9uUmVuZGVyU3RhdGUsXG59IGZyb20gJ2luc3RhbnRzZWFyY2guanMvZXMvY29ubmVjdG9ycy9wYWdpbmF0aW9uL2Nvbm5lY3RQYWdpbmF0aW9uJztcblxuZXhwb3J0IHsgUGFnaW5hdGlvbkNvbm5lY3RvclBhcmFtcywgUGFnaW5hdGlvblJlbmRlclN0YXRlIH07XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Fpcy1wYWdpbmF0aW9uJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IFtuZ0NsYXNzXT1cIltjeCgpLCBzdGF0ZS5uYlBhZ2VzIDw9IDEgPyBjeCgnJywgJ25vUmVmaW5lbWVudCcpIDogJyddXCI+XG4gICAgICA8dWwgW2NsYXNzXT1cImN4KCdsaXN0JylcIj5cbiAgICAgICAgPGxpXG4gICAgICAgICAgKm5nSWY9XCJzaG93Rmlyc3RcIlxuICAgICAgICAgIChjbGljayk9XCJyZWZpbmUoJGV2ZW50LCAwKVwiXG4gICAgICAgICAgW2NsYXNzXT1cIlxuICAgICAgICAgICAgY3goJ2l0ZW0nKSArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgY3goJ2l0ZW0nLCAnZmlyc3RQYWdlJykgK1xuICAgICAgICAgICAgKHN0YXRlLmN1cnJlbnRSZWZpbmVtZW50ID09PSAwID8gJyAnICsgY3goJ2l0ZW0nLCAnZGlzYWJsZWQnKSA6ICcnKVxuICAgICAgICAgIFwiXG4gICAgICAgID5cbiAgICAgICAgICA8YVxuICAgICAgICAgICAgW2hyZWZdPVwic3RhdGUuY3JlYXRlVVJMKDApXCJcbiAgICAgICAgICAgIFtjbGFzc109XCJjeCgnbGluaycpXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICDigLnigLlcbiAgICAgICAgICA8L2E+XG4gICAgICAgIDwvbGk+XG5cbiAgICAgICAgPGxpXG4gICAgICAgICAgKm5nSWY9XCJzaG93UHJldmlvdXNcIlxuICAgICAgICAgIChjbGljayk9XCJyZWZpbmUoJGV2ZW50LCBzdGF0ZS5jdXJyZW50UmVmaW5lbWVudCAtIDEpXCJcbiAgICAgICAgICBbY2xhc3NdPVwiXG4gICAgICAgICAgICBjeCgnaXRlbScpICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICBjeCgnaXRlbScsICdwcmV2aW91c1BhZ2UnKSArXG4gICAgICAgICAgICAoc3RhdGUuY3VycmVudFJlZmluZW1lbnQgPT09IDAgPyAnICcgKyBjeCgnaXRlbScsICdkaXNhYmxlZCcpIDogJycpXG4gICAgICAgICAgXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxhXG4gICAgICAgICAgICBbaHJlZl09XCJzdGF0ZS5jcmVhdGVVUkwoc3RhdGUuY3VycmVudFJlZmluZW1lbnQgLSAxKVwiXG4gICAgICAgICAgICBbY2xhc3NdPVwiY3goJ2xpbmsnKVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAg4oC5XG4gICAgICAgICAgPC9hPlxuICAgICAgICA8L2xpPlxuXG4gICAgICAgIDxsaVxuICAgICAgICAgIFtjbGFzc109XCJcbiAgICAgICAgICAgIGN4KCdpdGVtJykgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIGN4KCdpdGVtJywgJ3BhZ2UnKSArXG4gICAgICAgICAgICAoc3RhdGUuY3VycmVudFJlZmluZW1lbnQgPT09IHBhZ2UgPyAnICcgKyBjeCgnaXRlbScsICdzZWxlY3RlZCcpIDogJycpXG4gICAgICAgICAgXCJcbiAgICAgICAgICAqbmdGb3I9XCJsZXQgcGFnZSBvZiBwYWdlc1wiXG4gICAgICAgICAgKGNsaWNrKT1cInJlZmluZSgkZXZlbnQsIHBhZ2UpXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxhXG4gICAgICAgICAgICBbY2xhc3NdPVwiY3goJ2xpbmsnKVwiXG4gICAgICAgICAgICBbaHJlZl09XCJzdGF0ZS5jcmVhdGVVUkwocGFnZSlcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt7cGFnZSArIDF9fVxuICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9saT5cblxuICAgICAgICA8bGlcbiAgICAgICAgICAqbmdJZj1cInNob3dOZXh0XCJcbiAgICAgICAgICAoY2xpY2spPVwicmVmaW5lKCRldmVudCwgc3RhdGUuY3VycmVudFJlZmluZW1lbnQgKyAxKVwiXG4gICAgICAgICAgW2NsYXNzXT1cIlxuICAgICAgICAgICAgY3goJ2l0ZW0nKSArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgY3goJ2l0ZW0nLCAnbmV4dFBhZ2UnKSArXG4gICAgICAgICAgICAoc3RhdGUuY3VycmVudFJlZmluZW1lbnQgKyAxID09PSBzdGF0ZS5uYlBhZ2VzID8gJyAnICsgY3goJ2l0ZW0nLCAnZGlzYWJsZWQnKSA6ICcnKVxuICAgICAgICAgIFwiXG4gICAgICAgID5cbiAgICAgICAgICA8YVxuICAgICAgICAgICAgW2hyZWZdPVwic3RhdGUuY3JlYXRlVVJMKHN0YXRlLmN1cnJlbnRSZWZpbmVtZW50ICsgMSlcIlxuICAgICAgICAgICAgW2NsYXNzXT1cImN4KCdsaW5rJylcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIOKAulxuICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9saT5cblxuICAgICAgICA8bGlcbiAgICAgICAgICAqbmdJZj1cInNob3dMYXN0XCJcbiAgICAgICAgICAoY2xpY2spPVwicmVmaW5lKCRldmVudCwgc3RhdGUubmJQYWdlcyAtIDEpXCJcbiAgICAgICAgICBbY2xhc3NdPVwiXG4gICAgICAgICAgICBjeCgnaXRlbScpICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICBjeCgnaXRlbScsICdsYXN0UGFnZScpICtcbiAgICAgICAgICAgIChzdGF0ZS5jdXJyZW50UmVmaW5lbWVudCArIDEgPT09IHN0YXRlLm5iUGFnZXMgPyAnICcgKyBjeCgnaXRlbScsICdkaXNhYmxlZCcpIDogJycpXG4gICAgICAgICAgXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxhXG4gICAgICAgICAgICBbaHJlZl09XCJzdGF0ZS5jcmVhdGVVUkwoc3RhdGUubmJQYWdlcyAtIDEpXCJcbiAgICAgICAgICAgIFtjbGFzc109XCJjeCgnbGluaycpXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICDigLrigLpcbiAgICAgICAgICA8L2E+XG4gICAgICAgIDwvbGk+XG4gICAgICA8L3VsPlxuICAgIDwvZGl2PlxuICBgLFxufSlcbmV4cG9ydCBjbGFzcyBOZ0Fpc1BhZ2luYXRpb24gZXh0ZW5kcyBUeXBlZEJhc2VXaWRnZXQ8XG4gIFBhZ2luYXRpb25XaWRnZXREZXNjcmlwdGlvbixcbiAgUGFnaW5hdGlvbkNvbm5lY3RvclBhcmFtc1xuPiB7XG4gIC8vIHJlbmRlcmluZyBvcHRpb25zXG4gIEBJbnB1dCgpIHB1YmxpYyBzaG93Rmlyc3Q6IGJvb2xlYW4gPSB0cnVlO1xuICBASW5wdXQoKSBwdWJsaWMgc2hvd0xhc3Q6IGJvb2xlYW4gPSB0cnVlO1xuICBASW5wdXQoKSBwdWJsaWMgc2hvd1ByZXZpb3VzOiBib29sZWFuID0gdHJ1ZTtcbiAgQElucHV0KCkgcHVibGljIHNob3dOZXh0OiBib29sZWFuID0gdHJ1ZTtcblxuICAvLyBpbnN0YW5jZSBvcHRpb25zXG4gIEBJbnB1dCgpIHB1YmxpYyBwYWRkaW5nOiBQYWdpbmF0aW9uQ29ubmVjdG9yUGFyYW1zWydwYWRkaW5nJ10gPSAzO1xuICBASW5wdXQoKSBwdWJsaWMgdG90YWxQYWdlcz86IFBhZ2luYXRpb25Db25uZWN0b3JQYXJhbXNbJ3RvdGFsUGFnZXMnXTtcbiAgLy8gVE9ETzogY2hlY2sgaWYgdGhpcyB3b3JrcywgcGFkZGluZyBhbmQgdG90YWxQYWdlcyBhcmUgbW9zdCBsaWtlbHkgc3RyaW5ncyB3aGVuIHBhc3NlZCB0byB0aGUgdGVtcGxhdGVcblxuICBwdWJsaWMgc3RhdGU6IFBhZ2luYXRpb25SZW5kZXJTdGF0ZSA9IHtcbiAgICBjcmVhdGVVUkw6ICgpID0+ICcjJyxcbiAgICBjdXJyZW50UmVmaW5lbWVudDogMCxcbiAgICBuYkhpdHM6IDAsXG4gICAgbmJQYWdlczogMCxcbiAgICByZWZpbmU6IG5vb3AsXG4gICAgcGFnZXM6IFtdLFxuICAgIGNhblJlZmluZTogZmFsc2UsXG4gICAgaXNGaXJzdFBhZ2U6IGZhbHNlLFxuICAgIGlzTGFzdFBhZ2U6IGZhbHNlLFxuICB9O1xuXG4gIGdldCBwYWdlcygpIHtcbiAgICBjb25zdCB7IG5iUGFnZXMsIGN1cnJlbnRSZWZpbmVtZW50IH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgY29uc3QgcGFnZXNBcnJheSA9IEFycmF5LmFwcGx5KG51bGwsIHsgbGVuZ3RoOiBuYlBhZ2VzIH0pLm1hcChcbiAgICAgIE51bWJlci5jYWxsLFxuICAgICAgTnVtYmVyXG4gICAgKTtcblxuICAgIGNvbnN0IHBhZ2VzUGFkZGluZyA9XG4gICAgICB0eXBlb2YgdGhpcy5wYWRkaW5nID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHBhcnNlSW50KHRoaXMucGFkZGluZywgMTApXG4gICAgICAgIDogdGhpcy5wYWRkaW5nO1xuXG4gICAgaWYgKHBhZ2VzUGFkZGluZyAmJiBwYWdlc1BhZGRpbmcgPiAwKSB7XG4gICAgICAvLyBzaG91bGQgbm90IGRpc3BsYXkgcGFnZXMgdGhhdCBkb2VzIG5vdCBleGlzdHNcbiAgICAgIGlmIChuYlBhZ2VzIDwgcGFnZXNQYWRkaW5nICogMiArIDEpIHtcbiAgICAgICAgcmV0dXJuIHBhZ2VzQXJyYXk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1pbkRlbHRhID0gY3VycmVudFJlZmluZW1lbnQgLSBwYWdlc1BhZGRpbmcgLSAxO1xuICAgICAgY29uc3QgbWF4RGVsdGEgPSBjdXJyZW50UmVmaW5lbWVudCArIHBhZ2VzUGFkZGluZyArIDE7XG5cbiAgICAgIGlmIChtaW5EZWx0YSA8IDApIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlKHtcbiAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICBlbmQ6IGN1cnJlbnRSZWZpbmVtZW50ICsgcGFnZXNQYWRkaW5nICsgTWF0aC5hYnMobWluRGVsdGEpLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heERlbHRhID4gbmJQYWdlcykge1xuICAgICAgICByZXR1cm4gcmFuZ2Uoe1xuICAgICAgICAgIHN0YXJ0OiBjdXJyZW50UmVmaW5lbWVudCAtIHBhZ2VzUGFkZGluZyAtIChtYXhEZWx0YSAtIG5iUGFnZXMpLFxuICAgICAgICAgIGVuZDogbmJQYWdlcyxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYW5nZSh7XG4gICAgICAgIHN0YXJ0OiBjdXJyZW50UmVmaW5lbWVudCAtIHBhZ2VzUGFkZGluZyxcbiAgICAgICAgZW5kOiBjdXJyZW50UmVmaW5lbWVudCArIHBhZ2VzUGFkZGluZyArIDEsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFnZXNBcnJheTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBOZ0Fpc0luZGV4KSlcbiAgICBAT3B0aW9uYWwoKVxuICAgIHB1YmxpYyBwYXJlbnRJbmRleDogTmdBaXNJbmRleCxcbiAgICBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gTmdBaXNJbnN0YW50U2VhcmNoKSlcbiAgICBwdWJsaWMgaW5zdGFudFNlYXJjaEluc3RhbmNlOiBOZ0Fpc0luc3RhbnRTZWFyY2hcbiAgKSB7XG4gICAgc3VwZXIoJ1BhZ2luYXRpb24nKTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmNyZWF0ZVdpZGdldChjb25uZWN0UGFnaW5hdGlvbiwge1xuICAgICAgdG90YWxQYWdlczogcGFyc2VOdW1iZXJJbnB1dCh0aGlzLnRvdGFsUGFnZXMpLFxuICAgIH0pO1xuICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gIH1cblxuICBwdWJsaWMgcmVmaW5lKGV2ZW50OiBNb3VzZUV2ZW50LCBwYWdlOiBudW1iZXIpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKFxuICAgICAgcGFnZSA8IDAgfHxcbiAgICAgIHBhZ2UgPT09IHRoaXMuc3RhdGUuY3VycmVudFJlZmluZW1lbnQgfHxcbiAgICAgIHBhZ2UgPj0gdGhpcy5zdGF0ZS5uYlBhZ2VzXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5yZWZpbmUocGFnZSk7XG4gIH1cbn1cbiJdfQ==