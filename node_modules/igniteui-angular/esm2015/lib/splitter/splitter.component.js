import { Component, Input, ContentChildren, HostBinding, Inject, ElementRef, Output, EventEmitter } from '@angular/core';
import { IgxSplitterPaneComponent } from './splitter-pane/splitter-pane.component';
import { DOCUMENT } from '@angular/common';
/**
 * An enumeration that defines the `SplitterComponent` panes orientation.
 */
export var SplitterType;
(function (SplitterType) {
    SplitterType[SplitterType["Horizontal"] = 0] = "Horizontal";
    SplitterType[SplitterType["Vertical"] = 1] = "Vertical";
})(SplitterType || (SplitterType = {}));
/**
 * Provides a framework for a simple layout, splitting the view horizontally or vertically
 * into multiple smaller resizable and collapsible areas.
 *
 * @igxModule IgxSplitterModule
 *
 * @igxParent Layouts
 *
 * @igxTheme igx-splitter-theme
 *
 * @igxKeywords splitter panes layout
 *
 * @igxGroup presentation
 *
 * @example
 * ```html
 * <igx-splitter>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 * </igx-splitter>
 * ```
 */
export class IgxSplitterComponent {
    constructor(document, elementRef) {
        this.document = document;
        this.elementRef = elementRef;
        /**
         * @hidden @internal
         * Gets/Sets the `overflow` property of the current splitter.
         */
        this.overflow = 'hidden';
        /**
         * @hidden @internal
         * Sets/Gets the `display` property of the current splitter.
         */
        this.display = 'flex';
        /**
         * Event fired when resizing of panes starts.
         *
         * @example
         * ```html
         * <igx-splitter (resizeStart)='resizeStart($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizeStart = new EventEmitter();
        /**
         * Event fired when resizing of panes is in progress.
         *
         * @example
         * ```html
         * <igx-splitter (resizing)='resizing($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizing = new EventEmitter();
        /**
         * Event fired when resizing of panes ends.
         *
         * @example
         * ```html
         * <igx-splitter (resizeEnd)='resizeEnd($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizeEnd = new EventEmitter();
        this._type = SplitterType.Horizontal;
    }
    /**
     * Gets/Sets the splitter orientation.
     *
     * @example
     * ```html
     * <igx-splitter [type]="type">...</igx-splitter>
     * ```
     */
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
        this.resetPaneSizes();
    }
    /**
     * @hidden @internal
     * Gets the `flex-direction` property of the current `SplitterComponent`.
     */
    get direction() {
        return this.type === SplitterType.Horizontal ? 'row' : 'column';
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        this.initPanes();
        this.panes.changes.subscribe(() => {
            this.initPanes();
        });
    }
    /**
     * @hidden @internal
     * This method performs  initialization logic when the user starts dragging the splitter bar between each pair of panes.
     * @param pane - the main pane associated with the currently dragged bar.
     */
    onMoveStart(pane) {
        const panes = this.panes.toArray();
        this.pane = pane;
        this.sibling = panes[panes.indexOf(this.pane) + 1];
        const paneRect = this.pane.element.getBoundingClientRect();
        this.initialPaneSize = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        const siblingRect = this.sibling.element.getBoundingClientRect();
        this.initialSiblingSize = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizeStart.emit(args);
    }
    /**
     * @hidden @internal
     * This method performs calculations concerning the sizes of each pair of panes when the bar between them is dragged.
     * @param delta - The difference along the X (or Y) axis between the initial and the current point when dragging the bar.
     */
    onMoving(delta) {
        const min = parseInt(this.pane.minSize, 10) || 0;
        const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const minSibling = parseInt(this.sibling.minSize, 10) || 0;
        const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {
            return;
        }
        this.pane.dragSize = paneSize + 'px';
        this.sibling.dragSize = siblingSize + 'px';
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizing.emit(args);
    }
    onMoveEnd(delta) {
        const min = parseInt(this.pane.minSize, 10) || 0;
        const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const minSibling = parseInt(this.sibling.minSize, 10) || 0;
        const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {
            return;
        }
        if (this.pane.isPercentageSize) {
            // handle % resizes
            const totalSize = this.getTotalSize();
            const percentPaneSize = (paneSize / totalSize) * 100;
            this.pane.size = percentPaneSize + '%';
        }
        else {
            // px resize
            this.pane.size = paneSize + 'px';
        }
        if (this.sibling.isPercentageSize) {
            // handle % resizes
            const totalSize = this.getTotalSize();
            const percentSiblingPaneSize = (siblingSize / totalSize) * 100;
            this.sibling.size = percentSiblingPaneSize + '%';
        }
        else {
            // px resize
            this.sibling.size = siblingSize + 'px';
        }
        this.pane.dragSize = null;
        this.sibling.dragSize = null;
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizeEnd.emit(args);
    }
    /** @hidden @internal */
    getPaneSiblingsByOrder(order, barIndex) {
        const panes = this.panes.toArray();
        const prevPane = panes[order - barIndex - 1];
        const nextPane = panes[order - barIndex];
        const siblings = [prevPane, nextPane];
        return siblings;
    }
    getTotalSize() {
        const computed = this.document.defaultView.getComputedStyle(this.elementRef.nativeElement);
        const totalSize = this.type === SplitterType.Horizontal ? computed.getPropertyValue('width') : computed.getPropertyValue('height');
        return parseFloat(totalSize);
    }
    /**
     * @hidden @internal
     * This method inits panes with properties.
     */
    initPanes() {
        this.panes.forEach(pane => pane.owner = this);
        this.assignFlexOrder();
        if (this.panes.filter(x => x.collapsed).length > 0) {
            // if any panes are collapsed, reset sizes.
            this.resetPaneSizes();
        }
    }
    /**
     * @hidden @internal
     * This method reset pane sizes.
     */
    resetPaneSizes() {
        if (this.panes) {
            // if type is changed runtime, should reset sizes.
            this.panes.forEach(x => x.size = 'auto');
        }
    }
    /**
     * @hidden @internal
     * This method assigns the order of each pane.
     */
    assignFlexOrder() {
        let k = 0;
        this.panes.forEach((pane) => {
            pane.order = k;
            k += 2;
        });
    }
}
IgxSplitterComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-splitter',
                template: "<ng-content select=\"igx-splitter-pane\"></ng-content>\n<ng-container *ngFor=\"let pane of panes; let last = last; let index= index;\">\n    <igx-splitter-bar *ngIf=\"!last\" [order]='pane.order + 1' role='separator'\n                    [type]=\"type\"\n                    [pane]=\"pane\"\n                    [siblings]='getPaneSiblingsByOrder(pane.order + 1, index)'\n                    (moveStart)=\"onMoveStart($event)\"\n                    (moving)=\"onMoving($event)\"\n                    (movingEnd)='onMoveEnd($event)'>\n    </igx-splitter-bar>\n</ng-container>\n"
            },] }
];
IgxSplitterComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ElementRef }
];
IgxSplitterComponent.propDecorators = {
    panes: [{ type: ContentChildren, args: [IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent },] }],
    overflow: [{ type: HostBinding, args: ['style.overflow',] }],
    display: [{ type: HostBinding, args: ['style.display',] }],
    resizeStart: [{ type: Output }],
    resizing: [{ type: Output }],
    resizeEnd: [{ type: Output }],
    type: [{ type: Input }],
    direction: [{ type: HostBinding, args: ['style.flex-direction',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXR0ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3NwbGl0dGVyL3NwbGl0dGVyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFhLEtBQUssRUFBRSxlQUFlLEVBQW9CLFdBQVcsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUNuRyxNQUFNLEVBQUUsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2pELE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHlDQUF5QyxDQUFDO0FBQ25GLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUUzQzs7R0FFRztBQUNILE1BQU0sQ0FBTixJQUFZLFlBR1g7QUFIRCxXQUFZLFlBQVk7SUFDcEIsMkRBQVUsQ0FBQTtJQUNWLHVEQUFRLENBQUE7QUFDWixDQUFDLEVBSFcsWUFBWSxLQUFaLFlBQVksUUFHdkI7QUFPRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXlCRztBQUtILE1BQU0sT0FBTyxvQkFBb0I7SUE0RjdCLFlBQXFDLFFBQVEsRUFBVSxVQUFzQjtRQUF4QyxhQUFRLEdBQVIsUUFBUSxDQUFBO1FBQVUsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQWhGN0U7OztXQUdHO1FBRUksYUFBUSxHQUFHLFFBQVEsQ0FBQztRQUUzQjs7O1dBR0c7UUFFSSxZQUFPLEdBQUcsTUFBTSxDQUFDO1FBRXhCOzs7Ozs7Ozs7V0FTRztRQUVJLGdCQUFXLEdBQUcsSUFBSSxZQUFZLEVBQStCLENBQUM7UUFFckU7Ozs7Ozs7OztXQVNHO1FBRUksYUFBUSxHQUFHLElBQUksWUFBWSxFQUErQixDQUFDO1FBR2xFOzs7Ozs7Ozs7V0FTRztRQUVJLGNBQVMsR0FBRyxJQUFJLFlBQVksRUFBK0IsQ0FBQztRQUUzRCxVQUFLLEdBQWlCLFlBQVks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QUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ2hELDJDQUEyQztZQUMzQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7U0FDekI7SUFDTCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssY0FBYztRQUNsQixJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDWixrREFBa0Q7WUFDbEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxDQUFDO1NBQzVDO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNLLGVBQWU7UUFDbkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUE4QixFQUFFLEVBQUU7WUFDbEQsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7WUFDZixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ1gsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDOzs7WUFyUUosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxjQUFjO2dCQUN4Qiw0a0JBQXdDO2FBQzNDOzs7NENBNkZnQixNQUFNLFNBQUMsUUFBUTtZQTVJOEQsVUFBVTs7O29CQXlEbkcsZUFBZSxTQUFDLHdCQUF3QixFQUFFLEVBQUUsSUFBSSxFQUFFLHdCQUF3QixFQUFFO3VCQU81RSxXQUFXLFNBQUMsZ0JBQWdCO3NCQU81QixXQUFXLFNBQUMsZUFBZTswQkFhM0IsTUFBTTt1QkFhTixNQUFNO3dCQWNOLE1BQU07bUJBc0NOLEtBQUs7d0JBYUwsV0FBVyxTQUFDLHNCQUFzQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgUXVlcnlMaXN0LCBJbnB1dCwgQ29udGVudENoaWxkcmVuLCBBZnRlckNvbnRlbnRJbml0LCBIb3N0QmluZGluZywgSW5qZWN0LCBFbGVtZW50UmVmLFxuICAgICBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50IH0gZnJvbSAnLi9zcGxpdHRlci1wYW5lL3NwbGl0dGVyLXBhbmUuY29tcG9uZW50JztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiB0aGF0IGRlZmluZXMgdGhlIGBTcGxpdHRlckNvbXBvbmVudGAgcGFuZXMgb3JpZW50YXRpb24uXG4gKi9cbmV4cG9ydCBlbnVtIFNwbGl0dGVyVHlwZSB7XG4gICAgSG9yaXpvbnRhbCxcbiAgICBWZXJ0aWNhbFxufVxuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgSVNwbGl0dGVyQmFyUmVzaXplRXZlbnRBcmdzIHtcbiAgICBwYW5lOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ7XG4gICAgc2libGluZzogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50O1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGEgZnJhbWV3b3JrIGZvciBhIHNpbXBsZSBsYXlvdXQsIHNwbGl0dGluZyB0aGUgdmlldyBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseVxuICogaW50byBtdWx0aXBsZSBzbWFsbGVyIHJlc2l6YWJsZSBhbmQgY29sbGFwc2libGUgYXJlYXMuXG4gKlxuICogQGlneE1vZHVsZSBJZ3hTcGxpdHRlck1vZHVsZVxuICpcbiAqIEBpZ3hQYXJlbnQgTGF5b3V0c1xuICpcbiAqIEBpZ3hUaGVtZSBpZ3gtc3BsaXR0ZXItdGhlbWVcbiAqXG4gKiBAaWd4S2V5d29yZHMgc3BsaXR0ZXIgcGFuZXMgbGF5b3V0XG4gKlxuICogQGlneEdyb3VwIHByZXNlbnRhdGlvblxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sXG4gKiA8aWd4LXNwbGl0dGVyPlxuICogIDxpZ3gtc3BsaXR0ZXItcGFuZT5cbiAqICAgICAgLi4uXG4gKiAgPC9pZ3gtc3BsaXR0ZXItcGFuZT5cbiAqICA8aWd4LXNwbGl0dGVyLXBhbmU+XG4gKiAgICAgIC4uLlxuICogIDwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gKiA8L2lneC1zcGxpdHRlcj5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC1zcGxpdHRlcicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3NwbGl0dGVyLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hTcGxpdHRlckNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxpc3Qgb2Ygc3BsaXR0ZXIgcGFuZXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBwYW5lcyA9IHRoaXMuc3BsaXR0ZXIucGFuZXM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQsIHsgcmVhZDogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50IH0pXG4gICAgcHVibGljIHBhbmVzITogUXVlcnlMaXN0PElneFNwbGl0dGVyUGFuZUNvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMvU2V0cyB0aGUgYG92ZXJmbG93YCBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBzcGxpdHRlci5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLm92ZXJmbG93JylcbiAgICBwdWJsaWMgb3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogU2V0cy9HZXRzIHRoZSBgZGlzcGxheWAgcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgc3BsaXR0ZXIuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5kaXNwbGF5JylcbiAgICBwdWJsaWMgZGlzcGxheSA9ICdmbGV4JztcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gcmVzaXppbmcgb2YgcGFuZXMgc3RhcnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlciAocmVzaXplU3RhcnQpPSdyZXNpemVTdGFydCgkZXZlbnQpJz5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlc2l6ZVN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcjxJU3BsaXR0ZXJCYXJSZXNpemVFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHJlc2l6aW5nIG9mIHBhbmVzIGlzIGluIHByb2dyZXNzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlciAocmVzaXppbmcpPSdyZXNpemluZygkZXZlbnQpJz5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlc2l6aW5nID0gbmV3IEV2ZW50RW1pdHRlcjxJU3BsaXR0ZXJCYXJSZXNpemVFdmVudEFyZ3M+KCk7XG5cblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gcmVzaXppbmcgb2YgcGFuZXMgZW5kcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXIgKHJlc2l6ZUVuZCk9J3Jlc2l6ZUVuZCgkZXZlbnQpJz5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlc2l6ZUVuZCA9IG5ldyBFdmVudEVtaXR0ZXI8SVNwbGl0dGVyQmFyUmVzaXplRXZlbnRBcmdzPigpO1xuXG4gICAgcHJpdmF0ZSBfdHlwZTogU3BsaXR0ZXJUeXBlID0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWw7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEEgZmllbGQgdGhhdCBob2xkcyB0aGUgaW5pdGlhbCBzaXplIG9mIHRoZSBtYWluIGBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnRgIGluIGVhY2ggcGFpciBvZiBwYW5lcyBkaXZpZGVkIGJ5IGEgc3BsaXR0ZXIgYmFyLlxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdGlhbFBhbmVTaXplITogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBBIGZpZWxkIHRoYXQgaG9sZHMgdGhlIGluaXRpYWwgc2l6ZSBvZiB0aGUgc2libGluZyBwYW5lIGluIGVhY2ggcGFpciBvZiBwYW5lcyBkaXZpZGVkIGJ5IGEgZ3JpcHBlci5cbiAgICAgKiBAbWVtYmVyb2YgU3BsaXR0ZXJDb21wb25lbnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRpYWxTaWJsaW5nU2l6ZSE6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogVGhlIG1haW4gcGFuZSBpbiBlYWNoIHBhaXIgb2YgcGFuZXMgZGl2aWRlZCBieSBhIGdyaXBwZXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBwYW5lITogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNpYmxpbmcgcGFuZSBpbiBlYWNoIHBhaXIgb2YgcGFuZXMgZGl2aWRlZCBieSBhIHNwbGl0dGVyIGJhci5cbiAgICAgKi9cbiAgICBwcml2YXRlIHNpYmxpbmchOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ7XG5cbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KERPQ1VNRU5UKSBwdWJsaWMgZG9jdW1lbnQsIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZikge31cbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIHNwbGl0dGVyIG9yaWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlciBbdHlwZV09XCJ0eXBlXCI+Li4uPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHR5cGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdHlwZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnJlc2V0UGFuZVNpemVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXRzIHRoZSBgZmxleC1kaXJlY3Rpb25gIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IGBTcGxpdHRlckNvbXBvbmVudGAuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5mbGV4LWRpcmVjdGlvbicpXG4gICAgcHVibGljIGdldCBkaXJlY3Rpb24oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyAncm93JyA6ICdjb2x1bW4nO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW5pdFBhbmVzKCk7XG4gICAgICAgIHRoaXMucGFuZXMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbml0UGFuZXMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyAgaW5pdGlhbGl6YXRpb24gbG9naWMgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIHNwbGl0dGVyIGJhciBiZXR3ZWVuIGVhY2ggcGFpciBvZiBwYW5lcy5cbiAgICAgKiBAcGFyYW0gcGFuZSAtIHRoZSBtYWluIHBhbmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50bHkgZHJhZ2dlZCBiYXIuXG4gICAgICovXG4gICAgcHVibGljIG9uTW92ZVN0YXJ0KHBhbmU6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBwYW5lcyA9IHRoaXMucGFuZXMudG9BcnJheSgpO1xuICAgICAgICB0aGlzLnBhbmUgPSBwYW5lO1xuICAgICAgICB0aGlzLnNpYmxpbmcgPSBwYW5lc1twYW5lcy5pbmRleE9mKHRoaXMucGFuZSkgKyAxXTtcblxuICAgICAgICBjb25zdCBwYW5lUmVjdCA9IHRoaXMucGFuZS5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLmluaXRpYWxQYW5lU2l6ZSA9IHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyBwYW5lUmVjdC53aWR0aCA6IHBhbmVSZWN0LmhlaWdodDtcblxuICAgICAgICBjb25zdCBzaWJsaW5nUmVjdCA9IHRoaXMuc2libGluZy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZSA9IHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyBzaWJsaW5nUmVjdC53aWR0aCA6IHNpYmxpbmdSZWN0LmhlaWdodDtcbiAgICAgICAgY29uc3QgYXJnczogSVNwbGl0dGVyQmFyUmVzaXplRXZlbnRBcmdzID0ge3BhbmU6IHRoaXMucGFuZSwgc2libGluZzogdGhpcy5zaWJsaW5nfTtcbiAgICAgICAgdGhpcy5yZXNpemVTdGFydC5lbWl0KGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogVGhpcyBtZXRob2QgcGVyZm9ybXMgY2FsY3VsYXRpb25zIGNvbmNlcm5pbmcgdGhlIHNpemVzIG9mIGVhY2ggcGFpciBvZiBwYW5lcyB3aGVuIHRoZSBiYXIgYmV0d2VlbiB0aGVtIGlzIGRyYWdnZWQuXG4gICAgICogQHBhcmFtIGRlbHRhIC0gVGhlIGRpZmZlcmVuY2UgYWxvbmcgdGhlIFggKG9yIFkpIGF4aXMgYmV0d2VlbiB0aGUgaW5pdGlhbCBhbmQgdGhlIGN1cnJlbnQgcG9pbnQgd2hlbiBkcmFnZ2luZyB0aGUgYmFyLlxuICAgICAqL1xuICAgIHB1YmxpYyBvbk1vdmluZyhkZWx0YTogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IHBhcnNlSW50KHRoaXMucGFuZS5taW5TaXplLCAxMCkgfHwgMDtcbiAgICAgICAgY29uc3QgbWF4ID0gcGFyc2VJbnQodGhpcy5wYW5lLm1heFNpemUsIDEwKSB8fCB0aGlzLmluaXRpYWxQYW5lU2l6ZSArIHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplO1xuICAgICAgICBjb25zdCBtaW5TaWJsaW5nID0gcGFyc2VJbnQodGhpcy5zaWJsaW5nLm1pblNpemUsIDEwKSB8fCAwO1xuICAgICAgICBjb25zdCBtYXhTaWJsaW5nID0gcGFyc2VJbnQodGhpcy5zaWJsaW5nLm1heFNpemUsIDEwKSB8fCB0aGlzLmluaXRpYWxQYW5lU2l6ZSArIHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplO1xuXG4gICAgICAgIGNvbnN0IHBhbmVTaXplID0gdGhpcy5pbml0aWFsUGFuZVNpemUgLSBkZWx0YTtcbiAgICAgICAgY29uc3Qgc2libGluZ1NpemUgPSB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZSArIGRlbHRhO1xuICAgICAgICBpZiAocGFuZVNpemUgPCBtaW4gfHwgcGFuZVNpemUgPiBtYXggfHwgc2libGluZ1NpemUgPCBtaW5TaWJsaW5nIHx8IHNpYmxpbmdTaXplID4gbWF4U2libGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFuZS5kcmFnU2l6ZSA9IHBhbmVTaXplICsgJ3B4JztcbiAgICAgICAgdGhpcy5zaWJsaW5nLmRyYWdTaXplID0gc2libGluZ1NpemUgKyAncHgnO1xuXG4gICAgICAgIGNvbnN0IGFyZ3M6IElTcGxpdHRlckJhclJlc2l6ZUV2ZW50QXJncyA9IHsgcGFuZTogdGhpcy5wYW5lLCBzaWJsaW5nOiB0aGlzLnNpYmxpbmcgfTtcbiAgICAgICAgdGhpcy5yZXNpemluZy5lbWl0KGFyZ3MpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvbk1vdmVFbmQoZGVsdGE6IG51bWJlcikge1xuICAgICAgICBjb25zdCBtaW4gPSBwYXJzZUludCh0aGlzLnBhbmUubWluU2l6ZSwgMTApIHx8IDA7XG4gICAgICAgIGNvbnN0IG1heCA9IHBhcnNlSW50KHRoaXMucGFuZS5tYXhTaXplLCAxMCkgfHwgdGhpcy5pbml0aWFsUGFuZVNpemUgKyB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZTtcbiAgICAgICAgY29uc3QgbWluU2libGluZyA9IHBhcnNlSW50KHRoaXMuc2libGluZy5taW5TaXplLCAxMCkgfHwgMDtcbiAgICAgICAgY29uc3QgbWF4U2libGluZyA9IHBhcnNlSW50KHRoaXMuc2libGluZy5tYXhTaXplLCAxMCkgfHwgdGhpcy5pbml0aWFsUGFuZVNpemUgKyB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZTtcblxuICAgICAgICBjb25zdCBwYW5lU2l6ZSA9IHRoaXMuaW5pdGlhbFBhbmVTaXplIC0gZGVsdGE7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdTaXplID0gdGhpcy5pbml0aWFsU2libGluZ1NpemUgKyBkZWx0YTtcblxuICAgICAgICBpZiAocGFuZVNpemUgPCBtaW4gfHwgcGFuZVNpemUgPiBtYXggfHwgc2libGluZ1NpemUgPCBtaW5TaWJsaW5nIHx8IHNpYmxpbmdTaXplID4gbWF4U2libGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhbmUuaXNQZXJjZW50YWdlU2l6ZSkge1xuICAgICAgICAgICAgLy8gaGFuZGxlICUgcmVzaXplc1xuICAgICAgICAgICAgY29uc3QgdG90YWxTaXplID0gdGhpcy5nZXRUb3RhbFNpemUoKTtcbiAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRQYW5lU2l6ZSA9IChwYW5lU2l6ZSAvIHRvdGFsU2l6ZSkgKiAxMDA7XG4gICAgICAgICAgICB0aGlzLnBhbmUuc2l6ZSA9IHBlcmNlbnRQYW5lU2l6ZSArICclJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHB4IHJlc2l6ZVxuICAgICAgICAgICAgdGhpcy5wYW5lLnNpemUgPSBwYW5lU2l6ZSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zaWJsaW5nLmlzUGVyY2VudGFnZVNpemUpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSAlIHJlc2l6ZXNcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IHRoaXMuZ2V0VG90YWxTaXplKCk7XG4gICAgICAgICAgICBjb25zdCBwZXJjZW50U2libGluZ1BhbmVTaXplID0gIChzaWJsaW5nU2l6ZSAvIHRvdGFsU2l6ZSkgKiAxMDA7XG4gICAgICAgICAgICB0aGlzLnNpYmxpbmcuc2l6ZSA9IHBlcmNlbnRTaWJsaW5nUGFuZVNpemUgKyAnJSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBweCByZXNpemVcbiAgICAgICAgICAgIHRoaXMuc2libGluZy5zaXplID0gc2libGluZ1NpemUgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFuZS5kcmFnU2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2libGluZy5kcmFnU2l6ZSA9IG51bGw7XG5cbiAgICAgICAgY29uc3QgYXJnczogSVNwbGl0dGVyQmFyUmVzaXplRXZlbnRBcmdzID0geyBwYW5lOiB0aGlzLnBhbmUsIHNpYmxpbmc6IHRoaXMuc2libGluZyB9O1xuICAgICAgICB0aGlzLnJlc2l6ZUVuZC5lbWl0KGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBnZXRQYW5lU2libGluZ3NCeU9yZGVyKG9yZGVyOiBudW1iZXIsIGJhckluZGV4OiBudW1iZXIpOiBBcnJheTxJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ+IHtcbiAgICAgICAgY29uc3QgcGFuZXMgPSB0aGlzLnBhbmVzLnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3QgcHJldlBhbmUgPSBwYW5lc1tvcmRlciAtIGJhckluZGV4IC0gMV07XG4gICAgICAgIGNvbnN0IG5leHRQYW5lID0gcGFuZXNbb3JkZXIgLSBiYXJJbmRleF07XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gW3ByZXZQYW5lLCBuZXh0UGFuZV07XG4gICAgICAgIHJldHVybiBzaWJsaW5ncztcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRvdGFsU2l6ZSgpIHtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSB0aGlzLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBjb25zdCB0b3RhbFNpemUgPSB0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsID8gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKSA6IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoJ2hlaWdodCcpO1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0b3RhbFNpemUpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBUaGlzIG1ldGhvZCBpbml0cyBwYW5lcyB3aXRoIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0UGFuZXMoKSB7XG4gICAgICAgIHRoaXMucGFuZXMuZm9yRWFjaChwYW5lID0+IHBhbmUub3duZXIgPSB0aGlzKTtcbiAgICAgICAgdGhpcy5hc3NpZ25GbGV4T3JkZXIoKTtcbiAgICAgICAgaWYgKHRoaXMucGFuZXMuZmlsdGVyKHggPT4geC5jb2xsYXBzZWQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIGlmIGFueSBwYW5lcyBhcmUgY29sbGFwc2VkLCByZXNldCBzaXplcy5cbiAgICAgICAgICAgIHRoaXMucmVzZXRQYW5lU2l6ZXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogVGhpcyBtZXRob2QgcmVzZXQgcGFuZSBzaXplcy5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlc2V0UGFuZVNpemVzKCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lcykge1xuICAgICAgICAgICAgLy8gaWYgdHlwZSBpcyBjaGFuZ2VkIHJ1bnRpbWUsIHNob3VsZCByZXNldCBzaXplcy5cbiAgICAgICAgICAgIHRoaXMucGFuZXMuZm9yRWFjaCh4ID0+IHguc2l6ZSA9ICdhdXRvJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRoaXMgbWV0aG9kIGFzc2lnbnMgdGhlIG9yZGVyIG9mIGVhY2ggcGFuZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGFzc2lnbkZsZXhPcmRlcigpIHtcbiAgICAgICAgbGV0IGsgPSAwO1xuICAgICAgICB0aGlzLnBhbmVzLmZvckVhY2goKHBhbmU6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgcGFuZS5vcmRlciA9IGs7XG4gICAgICAgICAgICBrICs9IDI7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdfQ==