import { __awaiter } from "tslib";
import { ExcelStrings } from './excel-strings';
import { yieldingLoop } from '../../core/utils';
import { HeaderType, ExportRecordType } from '../exporter-common/base-export-service';
/**
 * @hidden
 */
export class RootRelsFile {
    writeElement(folder) {
        folder.file('.rels', ExcelStrings.getRels());
    }
}
/**
 * @hidden
 */
export class AppFile {
    writeElement(folder, worksheetData) {
        folder.file('app.xml', ExcelStrings.getApp(worksheetData.options.worksheetName));
    }
}
/**
 * @hidden
 */
export class CoreFile {
    writeElement(folder) {
        folder.file('core.xml', ExcelStrings.getCore());
    }
}
/**
 * @hidden
 */
export class WorkbookRelsFile {
    writeElement(folder, worksheetData) {
        const hasSharedStrings = worksheetData.isEmpty === false;
        folder.file('workbook.xml.rels', ExcelStrings.getWorkbookRels(hasSharedStrings));
    }
}
/**
 * @hidden
 */
export class ThemeFile {
    writeElement(folder) {
        folder.file('theme1.xml', ExcelStrings.getTheme());
    }
}
/**
 * @hidden
 */
export class WorksheetFile {
    constructor() {
        this.maxOutlineLevel = 0;
        this.dimension = '';
        this.freezePane = '';
        this.rowHeight = '';
        this.mergeCellStr = '';
        this.mergeCellsCounter = 0;
        this.rowIndex = 0;
    }
    writeElement() { }
    writeElementAsync(folder, worksheetData) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                this.prepareDataAsync(worksheetData, (cols, rows) => {
                    var _a;
                    const hasTable = !worksheetData.isEmpty && worksheetData.options.exportAsTable;
                    const isHierarchicalGrid = ((_a = worksheetData.data[0]) === null || _a === void 0 ? void 0 : _a.type) === ExportRecordType.HierarchicalGridRecord;
                    folder.file('sheet1.xml', ExcelStrings.getSheetXML(this.dimension, this.freezePane, cols, rows, hasTable, this.maxOutlineLevel, isHierarchicalGrid));
                    resolve();
                });
            });
        });
    }
    prepareDataAsync(worksheetData, done) {
        let sheetData = '';
        let cols = '';
        const dictionary = worksheetData.dataDictionary;
        this.rowIndex = 0;
        if (worksheetData.isEmpty) {
            sheetData += '<sheetData/>';
            this.dimension = 'A1';
            done('', sheetData);
        }
        else {
            const owner = worksheetData.owner;
            const isHierarchicalGrid = worksheetData.data[0].type === ExportRecordType.HierarchicalGridRecord;
            const hasMultiColumnHeader = owner.columns.some(col => !col.skip && col.headerType === HeaderType.MultiColumnHeader);
            const hasUserSetIndex = owner.columns.some(col => col.exportIndex !== undefined);
            const height = worksheetData.options.rowHeight;
            const rowStyle = isHierarchicalGrid ? ' s="3"' : '';
            this.rowHeight = height ? ` ht="${height}" customHeight="1"` : '';
            sheetData += `<sheetData>`;
            for (let i = 0; i <= owner.maxLevel; i++) {
                this.rowIndex++;
                sheetData += `<row r="${this.rowIndex}"${this.rowHeight}>`;
                const headersForLevel = hasMultiColumnHeader ?
                    owner.columns
                        .filter(c => (c.level < i &&
                        c.headerType !== HeaderType.MultiColumnHeader || c.level === i) && c.columnSpan > 0 && !c.skip)
                        .sort((a, b) => a.startIndex - b.startIndex)
                        .sort((a, b) => a.pinnedIndex - b.pinnedIndex) :
                    hasUserSetIndex ?
                        owner.columns.filter(c => !c.skip) :
                        owner.columns.filter(c => !c.skip)
                            .sort((a, b) => a.startIndex - b.startIndex)
                            .sort((a, b) => a.pinnedIndex - b.pinnedIndex);
                let startValue = 0;
                for (const currentCol of headersForLevel) {
                    if (currentCol.level === i) {
                        let columnCoordinate;
                        columnCoordinate = ExcelStrings.getExcelColumn(startValue) + this.rowIndex;
                        const columnValue = dictionary.saveValue(currentCol.header, true);
                        sheetData += `<c r="${columnCoordinate}"${rowStyle} t="s"><v>${columnValue}</v></c>`;
                        if (i !== owner.maxLevel) {
                            this.mergeCellsCounter++;
                            this.mergeCellStr += ` <mergeCell ref="${columnCoordinate}:`;
                            if (currentCol.headerType === HeaderType.ColumnHeader) {
                                columnCoordinate = ExcelStrings.getExcelColumn(startValue) + (owner.maxLevel + 1);
                            }
                            else {
                                for (let k = 1; k < currentCol.columnSpan; k++) {
                                    columnCoordinate = ExcelStrings.getExcelColumn(startValue + k) + this.rowIndex;
                                    sheetData += `<c r="${columnCoordinate}"${rowStyle} />`;
                                }
                            }
                            this.mergeCellStr += `${columnCoordinate}" />`;
                        }
                    }
                    startValue += currentCol.columnSpan;
                }
                sheetData += `</row>`;
            }
            const multiColumnHeaderLevel = worksheetData.options.ignoreMultiColumnHeaders ? 0 : owner.maxLevel;
            const freezeHeaders = worksheetData.options.freezeHeaders ? 2 + multiColumnHeaderLevel : 1;
            if (!isHierarchicalGrid) {
                this.dimension =
                    'A1:' + ExcelStrings.getExcelColumn(worksheetData.columnCount - 1) + (worksheetData.rowCount + owner.maxLevel);
                cols += '<cols>';
                if (!hasMultiColumnHeader) {
                    for (let j = 0; j < worksheetData.columnCount; j++) {
                        const width = dictionary.columnWidths[j];
                        // Use the width provided in the options if it exists
                        let widthInTwips = worksheetData.options.columnWidth !== undefined ?
                            worksheetData.options.columnWidth :
                            Math.max(((width / 96) * 14.4), WorksheetFile.MIN_WIDTH);
                        if (!(widthInTwips > 0)) {
                            widthInTwips = WorksheetFile.MIN_WIDTH;
                        }
                        cols += `<col min="${(j + 1)}" max="${(j + 1)}" width="${widthInTwips}" customWidth="1"/>`;
                    }
                }
                else {
                    cols += `<col min="1" max="${worksheetData.columnCount}" width="15" customWidth="1"/>`;
                }
                cols += '</cols>';
                const indexOfLastPinnedColumn = worksheetData.indexOfLastPinnedColumn;
                const frozenColumnCount = indexOfLastPinnedColumn + 1;
                let firstCell = ExcelStrings.getExcelColumn(frozenColumnCount) + freezeHeaders;
                if (indexOfLastPinnedColumn !== -1 &&
                    !worksheetData.options.ignorePinning &&
                    !worksheetData.options.ignoreColumnsOrder) {
                    this.freezePane =
                        `<pane xSplit="${frozenColumnCount}" ySplit="${freezeHeaders - 1}"
                         topLeftCell="${firstCell}" activePane="topRight" state="frozen"/>`;
                }
                else if (worksheetData.options.freezeHeaders) {
                    firstCell = ExcelStrings.getExcelColumn(0) + freezeHeaders;
                    this.freezePane =
                        `<pane xSplit="0" ySplit="${freezeHeaders - 1}"
                         topLeftCell="${firstCell}" activePane="topRight" state="frozen"/>`;
                }
            }
            else {
                const columnWidth = worksheetData.options.columnWidth ? worksheetData.options.columnWidth : 20;
                cols += `<cols><col min="1" max="${worksheetData.columnCount}" width="${columnWidth}" customWidth="1"/></cols>`;
                if (worksheetData.options.freezeHeaders) {
                    const firstCell = ExcelStrings.getExcelColumn(0) + freezeHeaders;
                    this.freezePane =
                        `<pane xSplit="0" ySplit="${freezeHeaders - 1}"
                         topLeftCell="${firstCell}" activePane="topRight" state="frozen"/>`;
                }
            }
            this.processDataRecordsAsync(worksheetData, (rows) => {
                sheetData += rows;
                sheetData += '</sheetData>';
                if (hasMultiColumnHeader) {
                    sheetData += `<mergeCells count="${this.mergeCellsCounter}">${this.mergeCellStr}</mergeCells>`;
                }
                done(cols, sheetData);
            });
        }
    }
    processDataRecordsAsync(worksheetData, done) {
        const rowDataArr = [];
        const height = worksheetData.options.rowHeight;
        this.rowHeight = height ? ' ht="' + height + '" customHeight="1"' : '';
        const isHierarchicalGrid = worksheetData.data.some(r => r.type === ExportRecordType.HeaderRecord || r.type === ExportRecordType.HierarchicalGridRecord);
        const hasUserSetIndex = worksheetData.owner.columns.some(c => c.exportIndex !== undefined);
        let recordHeaders = [];
        yieldingLoop(worksheetData.rowCount - 1, 1000, (i) => {
            if (!isHierarchicalGrid) {
                if (hasUserSetIndex) {
                    recordHeaders = worksheetData.rootKeys;
                }
                else {
                    recordHeaders = worksheetData.owner.columns
                        .filter(c => c.headerType !== HeaderType.MultiColumnHeader && !c.skip)
                        .sort((a, b) => a.startIndex - b.startIndex)
                        .sort((a, b) => a.pinnedIndex - b.pinnedIndex)
                        .map(c => c.field);
                }
            }
            else {
                const record = worksheetData.data[i];
                if (record.type === ExportRecordType.HeaderRecord) {
                    const recordOwner = worksheetData.owners.get(record.owner);
                    const hasMultiColumnHeaders = recordOwner.columns.some(c => c.headerType === HeaderType.MultiColumnHeader);
                    if (hasMultiColumnHeaders) {
                        this.hGridPrintMultiColHeaders(worksheetData, rowDataArr, record, recordOwner);
                    }
                }
                recordHeaders = Object.keys(worksheetData.data[i].data);
            }
            rowDataArr.push(this.processRow(worksheetData, i, recordHeaders, isHierarchicalGrid));
        }, () => {
            done(rowDataArr.join(''));
        });
    }
    hGridPrintMultiColHeaders(worksheetData, rowDataArr, record, owner) {
        for (let j = 0; j < owner.maxLevel; j++) {
            const recordLevel = record.level;
            const outlineLevel = recordLevel > 0 ? ` outlineLevel="${recordLevel}"` : '';
            this.maxOutlineLevel = this.maxOutlineLevel < recordLevel ? recordLevel : this.maxOutlineLevel;
            const sHidden = record.hidden ? ` hidden="1"` : '';
            this.rowIndex++;
            let row = `<row r="${this.rowIndex}"${this.rowHeight}${outlineLevel}${sHidden}>`;
            const headersForLevel = owner.columns
                .filter(c => (c.level < j &&
                c.headerType !== HeaderType.MultiColumnHeader || c.level === j) && c.columnSpan > 0 && !c.skip)
                .sort((a, b) => a.startIndex - b.startIndex)
                .sort((a, b) => a.pinnedIndex - b.pinnedIndex);
            let startValue = 0 + record.level;
            for (const currentCol of headersForLevel) {
                if (currentCol.level === j) {
                    let columnCoordinate;
                    columnCoordinate =
                        ExcelStrings.getExcelColumn(startValue) + this.rowIndex;
                    const columnValue = worksheetData.dataDictionary.saveValue(currentCol.header, true);
                    row += `<c r="${columnCoordinate}" s="3" t="s"><v>${columnValue}</v></c>`;
                    if (j !== owner.maxLevel) {
                        this.mergeCellsCounter++;
                        this.mergeCellStr += ` <mergeCell ref="${columnCoordinate}:`;
                        if (currentCol.headerType === HeaderType.ColumnHeader) {
                            columnCoordinate = ExcelStrings.getExcelColumn(startValue) +
                                (this.rowIndex + owner.maxLevel - currentCol.level);
                        }
                        else {
                            for (let k = 1; k < currentCol.columnSpan; k++) {
                                columnCoordinate = ExcelStrings.getExcelColumn(startValue + k) + this.rowIndex;
                                row += `<c r="${columnCoordinate}" s="3" />`;
                            }
                        }
                        this.mergeCellStr += `${columnCoordinate}" />`;
                    }
                }
                startValue += currentCol.columnSpan;
            }
            row += `</row>`;
            rowDataArr.push(row);
        }
    }
    processRow(worksheetData, i, headersForLevel, isHierarchicalGrid) {
        const record = worksheetData.data[i];
        const rowData = new Array(worksheetData.columnCount + 2);
        const rowLevel = record.level;
        const outlineLevel = rowLevel > 0 ? ` outlineLevel="${rowLevel}"` : '';
        this.maxOutlineLevel = this.maxOutlineLevel < rowLevel ? rowLevel : this.maxOutlineLevel;
        const sHidden = record.hidden ? ` hidden="1"` : '';
        this.rowIndex++;
        rowData[0] =
            `<row r="${this.rowIndex}"${this.rowHeight}${outlineLevel}${sHidden}>`;
        const keys = worksheetData.isSpecialData ? [record.data] : headersForLevel;
        for (let j = 0; j < keys.length; j++) {
            const col = j + (isHierarchicalGrid ? rowLevel : 0);
            const cellData = this.getCellData(worksheetData, i, col, keys[j]);
            rowData[j + 1] = cellData;
        }
        rowData[keys.length + 1] = '</row>';
        return rowData.join('');
    }
    getCellData(worksheetData, row, column, key) {
        const dictionary = worksheetData.dataDictionary;
        const columnName = ExcelStrings.getExcelColumn(column) + (this.rowIndex);
        const fullRow = worksheetData.data[row];
        const isHeaderRecord = fullRow.type === ExportRecordType.HeaderRecord;
        const cellValue = worksheetData.isSpecialData ?
            fullRow.data :
            fullRow.data[key];
        if (cellValue === undefined || cellValue === null) {
            return `<c r="${columnName}" s="1"/>`;
        }
        else {
            const savedValue = dictionary.saveValue(cellValue, isHeaderRecord);
            const isSavedAsString = savedValue !== -1;
            const isSavedAsDate = !isSavedAsString && cellValue instanceof Date;
            let value = isSavedAsString ? savedValue : cellValue;
            if (isSavedAsDate) {
                const timeZoneOffset = value.getTimezoneOffset() * 60000;
                const isoString = (new Date(value - timeZoneOffset)).toISOString();
                value = isoString.substring(0, isoString.indexOf('.'));
            }
            const type = isSavedAsString ? ` t="s"` : isSavedAsDate ? ` t="d"` : '';
            const format = isHeaderRecord ? ` s="3"` : isSavedAsString ? '' : isSavedAsDate ? ` s="2"` : ` s="1"`;
            return `<c r="${columnName}"${type}${format}><v>${value}</v></c>`;
        }
    }
}
WorksheetFile.MIN_WIDTH = 8.43;
/**
 * @hidden
 */
export class StyleFile {
    writeElement(folder, worksheetData) {
        var _a;
        const hasNumberValues = worksheetData.dataDictionary && worksheetData.dataDictionary.hasNumberValues;
        const hasDateValues = worksheetData.dataDictionary && worksheetData.dataDictionary.hasDateValues;
        const isHierarchicalGrid = ((_a = worksheetData.data[0]) === null || _a === void 0 ? void 0 : _a.type) === ExportRecordType.HierarchicalGridRecord;
        folder.file('styles.xml', ExcelStrings.getStyles(hasNumberValues, hasDateValues, isHierarchicalGrid));
    }
}
/**
 * @hidden
 */
export class WorkbookFile {
    writeElement(folder, worksheetData) {
        folder.file('workbook.xml', ExcelStrings.getWorkbook(worksheetData.options.worksheetName));
    }
}
/**
 * @hidden
 */
export class ContentTypesFile {
    writeElement(folder, worksheetData) {
        folder.file('[Content_Types].xml', ExcelStrings.getContentTypesXML(!worksheetData.isEmpty, worksheetData.options.exportAsTable));
    }
}
/**
 * @hidden
 */
export class SharedStringsFile {
    writeElement(folder, worksheetData) {
        const dict = worksheetData.dataDictionary;
        const sortedValues = dict.getKeys();
        const sharedStrings = new Array(sortedValues.length);
        for (const value of sortedValues) {
            sharedStrings[dict.getSanitizedValue(value)] = '<si><t>' + value + '</t></si>';
        }
        folder.file('sharedStrings.xml', ExcelStrings.getSharedStringXML(dict.stringsCount, sortedValues.length, sharedStrings.join('')));
    }
}
/**
 * @hidden
 */
export class TablesFile {
    writeElement(folder, worksheetData) {
        const columnCount = worksheetData.columnCount;
        const lastColumn = ExcelStrings.getExcelColumn(columnCount - 1) + worksheetData.rowCount;
        const dimension = 'A1:' + lastColumn;
        const hasUserSetIndex = worksheetData.owner.columns.some(c => c.exportIndex !== undefined);
        const values = hasUserSetIndex
            ? worksheetData.rootKeys
            : worksheetData.owner.columns
                .filter(c => !c.skip)
                .sort((a, b) => a.startIndex - b.startIndex)
                .sort((a, b) => a.pinnedIndex - b.pinnedIndex)
                .map(c => c.header);
        let sortString = '';
        let tableColumns = '<tableColumns count="' + columnCount + '">';
        for (let i = 0; i < columnCount; i++) {
            const value = values[i];
            tableColumns += '<tableColumn id="' + (i + 1) + '" name="' + value + '"/>';
        }
        tableColumns += '</tableColumns>';
        if (worksheetData.sort) {
            const sortingExpression = worksheetData.sort;
            const sc = ExcelStrings.getExcelColumn(values.indexOf(sortingExpression.fieldName));
            const dir = sortingExpression.dir - 1;
            sortString = `<sortState ref="A2:${lastColumn}"><sortCondition descending="${dir}" ref="${sc}1:${sc}15"/></sortState>`;
        }
        folder.file('table1.xml', ExcelStrings.getTablesXML(dimension, tableColumns, sortString));
    }
}
/**
 * @hidden
 */
export class WorksheetRelsFile {
    writeElement(folder) {
        folder.file('sheet1.xml.rels', ExcelStrings.getWorksheetRels());
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhjZWwtZmlsZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvc2VydmljZXMvZXhjZWwvZXhjZWwtZmlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUkvQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDaEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxnQkFBZ0IsRUFBOEIsTUFBTSx3Q0FBd0MsQ0FBQztBQUVsSDs7R0FFRztBQUNILE1BQU0sT0FBTyxZQUFZO0lBQ2QsWUFBWSxDQUFDLE1BQWE7UUFDN0IsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFDakQsQ0FBQztDQUNKO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sT0FBTztJQUNULFlBQVksQ0FBQyxNQUFhLEVBQUUsYUFBNEI7UUFDM0QsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsWUFBWSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7SUFDckYsQ0FBQztDQUNKO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sUUFBUTtJQUNWLFlBQVksQ0FBQyxNQUFhO1FBQzdCLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBQ3BELENBQUM7Q0FDSjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLGdCQUFnQjtJQUNsQixZQUFZLENBQUMsTUFBYSxFQUFFLGFBQTRCO1FBQzNELE1BQU0sZ0JBQWdCLEdBQUcsYUFBYSxDQUFDLE9BQU8sS0FBSyxLQUFLLENBQUM7UUFDekQsTUFBTSxDQUFDLElBQUksQ0FBQyxt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QUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDcEYsTUFBTSxHQUFHLEdBQUcsaUJBQWlCLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztZQUN0QyxVQUFVLEdBQUcsc0JBQXNCLFVBQVUsZ0NBQWdDLEdBQUcsVUFBVSxFQUFFLEtBQUssRUFBRSxtQkFBbUIsQ0FBQztTQUMxSDtRQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLFlBQVksQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLFlBQVksRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBQzlGLENBQUM7Q0FDSjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLGlCQUFpQjtJQUNuQixZQUFZLENBQUMsTUFBYTtRQUM3QixNQUFNLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLFlBQVksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7SUFDcEUsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSUV4Y2VsRmlsZSB9IGZyb20gJy4vZXhjZWwtaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBFeGNlbFN0cmluZ3MgfSBmcm9tICcuL2V4Y2VsLXN0cmluZ3MnO1xuaW1wb3J0IHsgV29ya3NoZWV0RGF0YSB9IGZyb20gJy4vd29ya3NoZWV0LWRhdGEnO1xuXG5pbXBvcnQgKiBhcyBKU1ppcCBmcm9tICdqc3ppcCc7XG5pbXBvcnQgeyB5aWVsZGluZ0xvb3AgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IEhlYWRlclR5cGUsIEV4cG9ydFJlY29yZFR5cGUsIElFeHBvcnRSZWNvcmQsIElDb2x1bW5MaXN0IH0gZnJvbSAnLi4vZXhwb3J0ZXItY29tbW9uL2Jhc2UtZXhwb3J0LXNlcnZpY2UnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFJvb3RSZWxzRmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBKU1ppcCkge1xuICAgICAgICBmb2xkZXIuZmlsZSgnLnJlbHMnLCBFeGNlbFN0cmluZ3MuZ2V0UmVscygpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgQXBwRmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBKU1ppcCwgd29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSkge1xuICAgICAgICBmb2xkZXIuZmlsZSgnYXBwLnhtbCcsIEV4Y2VsU3RyaW5ncy5nZXRBcHAod29ya3NoZWV0RGF0YS5vcHRpb25zLndvcmtzaGVldE5hbWUpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgQ29yZUZpbGUgaW1wbGVtZW50cyBJRXhjZWxGaWxlIHtcbiAgICBwdWJsaWMgd3JpdGVFbGVtZW50KGZvbGRlcjogSlNaaXApIHtcbiAgICAgICAgZm9sZGVyLmZpbGUoJ2NvcmUueG1sJywgRXhjZWxTdHJpbmdzLmdldENvcmUoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFdvcmtib29rUmVsc0ZpbGUgaW1wbGVtZW50cyBJRXhjZWxGaWxlIHtcbiAgICBwdWJsaWMgd3JpdGVFbGVtZW50KGZvbGRlcjogSlNaaXAsIHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEpIHtcbiAgICAgICAgY29uc3QgaGFzU2hhcmVkU3RyaW5ncyA9IHdvcmtzaGVldERhdGEuaXNFbXB0eSA9PT0gZmFsc2U7XG4gICAgICAgIGZvbGRlci5maWxlKCd3b3JrYm9vay54bWwucmVscycsIEV4Y2VsU3RyaW5ncy5nZXRXb3JrYm9va1JlbHMoaGFzU2hhcmVkU3RyaW5ncykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBUaGVtZUZpbGUgaW1wbGVtZW50cyBJRXhjZWxGaWxlIHtcbiAgICBwdWJsaWMgd3JpdGVFbGVtZW50KGZvbGRlcjogSlNaaXApIHtcbiAgICAgICAgZm9sZGVyLmZpbGUoJ3RoZW1lMS54bWwnLCBFeGNlbFN0cmluZ3MuZ2V0VGhlbWUoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFdvcmtzaGVldEZpbGUgaW1wbGVtZW50cyBJRXhjZWxGaWxlIHtcbiAgICBwcml2YXRlIHN0YXRpYyBNSU5fV0lEVEggPSA4LjQzO1xuICAgIHByaXZhdGUgbWF4T3V0bGluZUxldmVsID0gMDtcbiAgICBwcml2YXRlIGRpbWVuc2lvbiA9ICcnO1xuICAgIHByaXZhdGUgZnJlZXplUGFuZSA9ICcnO1xuICAgIHByaXZhdGUgcm93SGVpZ2h0ID0gJyc7XG5cbiAgICBwcml2YXRlIG1lcmdlQ2VsbFN0ciA9ICcnO1xuICAgIHByaXZhdGUgbWVyZ2VDZWxsc0NvdW50ZXIgPSAwO1xuICAgIHByaXZhdGUgcm93SW5kZXggPSAwO1xuXG4gICAgcHVibGljIHdyaXRlRWxlbWVudCgpIHt9XG5cbiAgICBwdWJsaWMgYXN5bmMgd3JpdGVFbGVtZW50QXN5bmMoZm9sZGVyOiBKU1ppcCwgd29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByZXBhcmVEYXRhQXN5bmMod29ya3NoZWV0RGF0YSwgKGNvbHMsIHJvd3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNUYWJsZSA9ICF3b3Jrc2hlZXREYXRhLmlzRW1wdHkgJiYgd29ya3NoZWV0RGF0YS5vcHRpb25zLmV4cG9ydEFzVGFibGU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNIaWVyYXJjaGljYWxHcmlkID0gd29ya3NoZWV0RGF0YS5kYXRhWzBdPy50eXBlID09PSBFeHBvcnRSZWNvcmRUeXBlLkhpZXJhcmNoaWNhbEdyaWRSZWNvcmQ7XG5cbiAgICAgICAgICAgICAgICBmb2xkZXIuZmlsZSgnc2hlZXQxLnhtbCcsIEV4Y2VsU3RyaW5ncy5nZXRTaGVldFhNTChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaW1lbnNpb24sIHRoaXMuZnJlZXplUGFuZSwgY29scywgcm93cywgaGFzVGFibGUsIHRoaXMubWF4T3V0bGluZUxldmVsLCBpc0hpZXJhcmNoaWNhbEdyaWQpKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwcmVwYXJlRGF0YUFzeW5jKHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEsIGRvbmU6IChjb2xzOiBzdHJpbmcsIHNoZWV0RGF0YTogc3RyaW5nKSA9PiB2b2lkKSB7XG4gICAgICAgIGxldCBzaGVldERhdGEgPSAnJztcbiAgICAgICAgbGV0IGNvbHMgPSAnJztcbiAgICAgICAgY29uc3QgZGljdGlvbmFyeSA9IHdvcmtzaGVldERhdGEuZGF0YURpY3Rpb25hcnk7XG4gICAgICAgIHRoaXMucm93SW5kZXggPSAwO1xuXG4gICAgICAgIGlmICh3b3Jrc2hlZXREYXRhLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIHNoZWV0RGF0YSArPSAnPHNoZWV0RGF0YS8+JztcbiAgICAgICAgICAgIHRoaXMuZGltZW5zaW9uID0gJ0ExJztcbiAgICAgICAgICAgIGRvbmUoJycsIHNoZWV0RGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvd25lciA9IHdvcmtzaGVldERhdGEub3duZXI7XG4gICAgICAgICAgICBjb25zdCBpc0hpZXJhcmNoaWNhbEdyaWQgPSB3b3Jrc2hlZXREYXRhLmRhdGFbMF0udHlwZSA9PT0gRXhwb3J0UmVjb3JkVHlwZS5IaWVyYXJjaGljYWxHcmlkUmVjb3JkO1xuICAgICAgICAgICAgY29uc3QgaGFzTXVsdGlDb2x1bW5IZWFkZXIgPSBvd25lci5jb2x1bW5zLnNvbWUoY29sID0+ICFjb2wuc2tpcCAmJiBjb2wuaGVhZGVyVHlwZSA9PT0gSGVhZGVyVHlwZS5NdWx0aUNvbHVtbkhlYWRlcik7XG4gICAgICAgICAgICBjb25zdCBoYXNVc2VyU2V0SW5kZXggPSBvd25lci5jb2x1bW5zLnNvbWUoY29sID0+IGNvbC5leHBvcnRJbmRleCAhPT0gdW5kZWZpbmVkKTtcblxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gIHdvcmtzaGVldERhdGEub3B0aW9ucy5yb3dIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCByb3dTdHlsZSA9IGlzSGllcmFyY2hpY2FsR3JpZCA/ICcgcz1cIjNcIicgOiAnJztcbiAgICAgICAgICAgIHRoaXMucm93SGVpZ2h0ID0gaGVpZ2h0ID8gYCBodD1cIiR7aGVpZ2h0fVwiIGN1c3RvbUhlaWdodD1cIjFcImAgOiAnJztcblxuICAgICAgICAgICAgc2hlZXREYXRhICs9IGA8c2hlZXREYXRhPmA7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG93bmVyLm1heExldmVsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvd0luZGV4Kys7XG4gICAgICAgICAgICAgICAgc2hlZXREYXRhICs9IGA8cm93IHI9XCIke3RoaXMucm93SW5kZXh9XCIke3RoaXMucm93SGVpZ2h0fT5gO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyc0ZvckxldmVsID0gaGFzTXVsdGlDb2x1bW5IZWFkZXIgP1xuICAgICAgICAgICAgICAgICAgICBvd25lci5jb2x1bW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGMgPT4gKGMubGV2ZWwgPCBpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5oZWFkZXJUeXBlICE9PSBIZWFkZXJUeXBlLk11bHRpQ29sdW1uSGVhZGVyIHx8IGMubGV2ZWwgPT09IGkpICYmIGMuY29sdW1uU3BhbiA+IDAgJiYgIWMuc2tpcClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0SW5kZXggLSBiLnN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5waW5uZWRJbmRleCAtIGIucGlubmVkSW5kZXgpIDpcbiAgICAgICAgICAgICAgICAgICAgaGFzVXNlclNldEluZGV4ID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyLmNvbHVtbnMuZmlsdGVyKGMgPT4gIWMuc2tpcCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXIuY29sdW1ucy5maWx0ZXIoYyA9PiAhYy5za2lwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0SW5kZXggLSBiLnN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEucGlubmVkSW5kZXggLSBiLnBpbm5lZEluZGV4KTtcblxuICAgICAgICAgICAgICAgIGxldCBzdGFydFZhbHVlID0gMDtcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY3VycmVudENvbCBvZiBoZWFkZXJzRm9yTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDb2wubGV2ZWwgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb2x1bW5Db29yZGluYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uQ29vcmRpbmF0ZSA9IEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbihzdGFydFZhbHVlKSArIHRoaXMucm93SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW5WYWx1ZSA9IGRpY3Rpb25hcnkuc2F2ZVZhbHVlKGN1cnJlbnRDb2wuaGVhZGVyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoZWV0RGF0YSArPSBgPGMgcj1cIiR7Y29sdW1uQ29vcmRpbmF0ZX1cIiR7cm93U3R5bGV9IHQ9XCJzXCI+PHY+JHtjb2x1bW5WYWx1ZX08L3Y+PC9jPmA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBvd25lci5tYXhMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VDZWxsc0NvdW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlQ2VsbFN0ciArPSBgIDxtZXJnZUNlbGwgcmVmPVwiJHtjb2x1bW5Db29yZGluYXRlfTpgO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDb2wuaGVhZGVyVHlwZSA9PT0gSGVhZGVyVHlwZS5Db2x1bW5IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uQ29vcmRpbmF0ZSA9IEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbihzdGFydFZhbHVlKSArIChvd25lci5tYXhMZXZlbCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAxOyBrIDwgY3VycmVudENvbC5jb2x1bW5TcGFuOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkNvb3JkaW5hdGUgPSBFeGNlbFN0cmluZ3MuZ2V0RXhjZWxDb2x1bW4oc3RhcnRWYWx1ZSArIGspICsgdGhpcy5yb3dJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoZWV0RGF0YSArPSBgPGMgcj1cIiR7Y29sdW1uQ29vcmRpbmF0ZX1cIiR7cm93U3R5bGV9IC8+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VDZWxsU3RyICs9IGAke2NvbHVtbkNvb3JkaW5hdGV9XCIgLz5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZSArPSBjdXJyZW50Q29sLmNvbHVtblNwYW47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2hlZXREYXRhICs9IGA8L3Jvdz5gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBtdWx0aUNvbHVtbkhlYWRlckxldmVsID0gd29ya3NoZWV0RGF0YS5vcHRpb25zLmlnbm9yZU11bHRpQ29sdW1uSGVhZGVycyA/IDAgOiBvd25lci5tYXhMZXZlbDtcbiAgICAgICAgICAgIGNvbnN0IGZyZWV6ZUhlYWRlcnMgPSB3b3Jrc2hlZXREYXRhLm9wdGlvbnMuZnJlZXplSGVhZGVycyA/IDIgKyBtdWx0aUNvbHVtbkhlYWRlckxldmVsIDogMTtcblxuICAgICAgICAgICAgaWYgKCFpc0hpZXJhcmNoaWNhbEdyaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpbWVuc2lvbiA9XG4gICAgICAgICAgICAgICAgICAgICdBMTonICsgRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKHdvcmtzaGVldERhdGEuY29sdW1uQ291bnQgLSAxKSArICh3b3Jrc2hlZXREYXRhLnJvd0NvdW50ICsgb3duZXIubWF4TGV2ZWwpO1xuXG4gICAgICAgICAgICAgICAgY29scyArPSAnPGNvbHM+JztcblxuICAgICAgICAgICAgICAgIGlmICghaGFzTXVsdGlDb2x1bW5IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3b3Jrc2hlZXREYXRhLmNvbHVtbkNvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gZGljdGlvbmFyeS5jb2x1bW5XaWR0aHNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHdpZHRoIHByb3ZpZGVkIGluIHRoZSBvcHRpb25zIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoSW5Ud2lwcyA9IHdvcmtzaGVldERhdGEub3B0aW9ucy5jb2x1bW5XaWR0aCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtzaGVldERhdGEub3B0aW9ucy5jb2x1bW5XaWR0aCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgoKHdpZHRoIC8gOTYpICogMTQuNCksIFdvcmtzaGVldEZpbGUuTUlOX1dJRFRIKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHdpZHRoSW5Ud2lwcyA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhJblR3aXBzID0gV29ya3NoZWV0RmlsZS5NSU5fV0lEVEg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHMgKz0gYDxjb2wgbWluPVwiJHsoaiArIDEpfVwiIG1heD1cIiR7KGogKyAxKX1cIiB3aWR0aD1cIiR7d2lkdGhJblR3aXBzfVwiIGN1c3RvbVdpZHRoPVwiMVwiLz5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29scyArPSBgPGNvbCBtaW49XCIxXCIgbWF4PVwiJHt3b3Jrc2hlZXREYXRhLmNvbHVtbkNvdW50fVwiIHdpZHRoPVwiMTVcIiBjdXN0b21XaWR0aD1cIjFcIi8+YDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2xzICs9ICc8L2NvbHM+JztcblxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4T2ZMYXN0UGlubmVkQ29sdW1uID0gd29ya3NoZWV0RGF0YS5pbmRleE9mTGFzdFBpbm5lZENvbHVtbjtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm96ZW5Db2x1bW5Db3VudCA9IGluZGV4T2ZMYXN0UGlubmVkQ29sdW1uICsgMTtcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3RDZWxsID0gRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKGZyb3plbkNvbHVtbkNvdW50KSArIGZyZWV6ZUhlYWRlcnM7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4T2ZMYXN0UGlubmVkQ29sdW1uICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAhd29ya3NoZWV0RGF0YS5vcHRpb25zLmlnbm9yZVBpbm5pbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgIXdvcmtzaGVldERhdGEub3B0aW9ucy5pZ25vcmVDb2x1bW5zT3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmVlemVQYW5lID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGA8cGFuZSB4U3BsaXQ9XCIke2Zyb3plbkNvbHVtbkNvdW50fVwiIHlTcGxpdD1cIiR7ZnJlZXplSGVhZGVycyAtIDF9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICB0b3BMZWZ0Q2VsbD1cIiR7Zmlyc3RDZWxsfVwiIGFjdGl2ZVBhbmU9XCJ0b3BSaWdodFwiIHN0YXRlPVwiZnJvemVuXCIvPmA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3b3Jrc2hlZXREYXRhLm9wdGlvbnMuZnJlZXplSGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdENlbGwgPSBFeGNlbFN0cmluZ3MuZ2V0RXhjZWxDb2x1bW4oMCkgKyBmcmVlemVIZWFkZXJzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyZWV6ZVBhbmUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgYDxwYW5lIHhTcGxpdD1cIjBcIiB5U3BsaXQ9XCIke2ZyZWV6ZUhlYWRlcnMgLSAxfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgdG9wTGVmdENlbGw9XCIke2ZpcnN0Q2VsbH1cIiBhY3RpdmVQYW5lPVwidG9wUmlnaHRcIiBzdGF0ZT1cImZyb3plblwiLz5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sdW1uV2lkdGggPSB3b3Jrc2hlZXREYXRhLm9wdGlvbnMuY29sdW1uV2lkdGggPyB3b3Jrc2hlZXREYXRhLm9wdGlvbnMuY29sdW1uV2lkdGggOiAyMDtcbiAgICAgICAgICAgICAgICBjb2xzICs9IGA8Y29scz48Y29sIG1pbj1cIjFcIiBtYXg9XCIke3dvcmtzaGVldERhdGEuY29sdW1uQ291bnR9XCIgd2lkdGg9XCIke2NvbHVtbldpZHRofVwiIGN1c3RvbVdpZHRoPVwiMVwiLz48L2NvbHM+YDtcbiAgICAgICAgICAgICAgICBpZiAod29ya3NoZWV0RGF0YS5vcHRpb25zLmZyZWV6ZUhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RDZWxsID0gRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKDApICsgZnJlZXplSGVhZGVycztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmVlemVQYW5lID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGA8cGFuZSB4U3BsaXQ9XCIwXCIgeVNwbGl0PVwiJHtmcmVlemVIZWFkZXJzIC0gMX1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExlZnRDZWxsPVwiJHtmaXJzdENlbGx9XCIgYWN0aXZlUGFuZT1cInRvcFJpZ2h0XCIgc3RhdGU9XCJmcm96ZW5cIi8+YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0RhdGFSZWNvcmRzQXN5bmMod29ya3NoZWV0RGF0YSwgKHJvd3MpID0+IHtcbiAgICAgICAgICAgICAgICBzaGVldERhdGEgKz0gcm93cztcbiAgICAgICAgICAgICAgICBzaGVldERhdGEgKz0gJzwvc2hlZXREYXRhPic7XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTXVsdGlDb2x1bW5IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hlZXREYXRhICs9IGA8bWVyZ2VDZWxscyBjb3VudD1cIiR7dGhpcy5tZXJnZUNlbGxzQ291bnRlcn1cIj4ke3RoaXMubWVyZ2VDZWxsU3RyfTwvbWVyZ2VDZWxscz5gO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvbmUoY29scywgc2hlZXREYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwcm9jZXNzRGF0YVJlY29yZHNBc3luYyh3b3Jrc2hlZXREYXRhOiBXb3Jrc2hlZXREYXRhLCBkb25lOiAocm93czogc3RyaW5nKSA9PiB2b2lkKSB7XG4gICAgICAgIGNvbnN0IHJvd0RhdGFBcnIgPSBbXTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gIHdvcmtzaGVldERhdGEub3B0aW9ucy5yb3dIZWlnaHQ7XG4gICAgICAgIHRoaXMucm93SGVpZ2h0ID0gaGVpZ2h0ID8gJyBodD1cIicgKyBoZWlnaHQgKyAnXCIgY3VzdG9tSGVpZ2h0PVwiMVwiJyA6ICcnO1xuXG4gICAgICAgIGNvbnN0IGlzSGllcmFyY2hpY2FsR3JpZCA9XG4gICAgICAgICAgICB3b3Jrc2hlZXREYXRhLmRhdGEuc29tZShyID0+IHIudHlwZSA9PT0gRXhwb3J0UmVjb3JkVHlwZS5IZWFkZXJSZWNvcmQgfHwgci50eXBlID09PSBFeHBvcnRSZWNvcmRUeXBlLkhpZXJhcmNoaWNhbEdyaWRSZWNvcmQpO1xuICAgICAgICBjb25zdCBoYXNVc2VyU2V0SW5kZXggPSB3b3Jrc2hlZXREYXRhLm93bmVyLmNvbHVtbnMuc29tZShjID0+IGMuZXhwb3J0SW5kZXggIT09IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgbGV0IHJlY29yZEhlYWRlcnMgPSBbXTtcblxuICAgICAgICB5aWVsZGluZ0xvb3Aod29ya3NoZWV0RGF0YS5yb3dDb3VudCAtIDEsIDEwMDAsXG4gICAgICAgICAgICAoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaXNIaWVyYXJjaGljYWxHcmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNVc2VyU2V0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZEhlYWRlcnMgPSB3b3Jrc2hlZXREYXRhLnJvb3RLZXlzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkSGVhZGVycyA9IHdvcmtzaGVldERhdGEub3duZXIuY29sdW1uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLmhlYWRlclR5cGUgIT09IEhlYWRlclR5cGUuTXVsdGlDb2x1bW5IZWFkZXIgJiYgIWMuc2tpcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5zdGFydEluZGV4LWIuc3RhcnRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5waW5uZWRJbmRleC1iLnBpbm5lZEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoYyA9PiBjLmZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHdvcmtzaGVldERhdGEuZGF0YVtpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IEV4cG9ydFJlY29yZFR5cGUuSGVhZGVyUmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNvcmRPd25lciA9IHdvcmtzaGVldERhdGEub3duZXJzLmdldChyZWNvcmQub3duZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTXVsdGlDb2x1bW5IZWFkZXJzID0gcmVjb3JkT3duZXIuY29sdW1ucy5zb21lKGMgPT4gYy5oZWFkZXJUeXBlID09PSBIZWFkZXJUeXBlLk11bHRpQ29sdW1uSGVhZGVyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc011bHRpQ29sdW1uSGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaEdyaWRQcmludE11bHRpQ29sSGVhZGVycyh3b3Jrc2hlZXREYXRhLCByb3dEYXRhQXJyLCByZWNvcmQsIHJlY29yZE93bmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZEhlYWRlcnMgPSBPYmplY3Qua2V5cyh3b3Jrc2hlZXREYXRhLmRhdGFbaV0uZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm93RGF0YUFyci5wdXNoKHRoaXMucHJvY2Vzc1Jvdyh3b3Jrc2hlZXREYXRhLCBpLCByZWNvcmRIZWFkZXJzLCBpc0hpZXJhcmNoaWNhbEdyaWQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZG9uZShyb3dEYXRhQXJyLmpvaW4oJycpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoR3JpZFByaW50TXVsdGlDb2xIZWFkZXJzKHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEsIHJvd0RhdGFBcnI6IGFueVtdLCByZWNvcmQ6IElFeHBvcnRSZWNvcmQsXG4gICAgICAgIG93bmVyOiBJQ29sdW1uTGlzdCkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG93bmVyLm1heExldmVsOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZExldmVsID0gcmVjb3JkLmxldmVsO1xuICAgICAgICAgICAgY29uc3Qgb3V0bGluZUxldmVsID0gcmVjb3JkTGV2ZWwgPiAwID8gYCBvdXRsaW5lTGV2ZWw9XCIke3JlY29yZExldmVsfVwiYCA6ICcnO1xuICAgICAgICAgICAgdGhpcy5tYXhPdXRsaW5lTGV2ZWwgPSB0aGlzLm1heE91dGxpbmVMZXZlbCA8IHJlY29yZExldmVsID8gcmVjb3JkTGV2ZWwgOiB0aGlzLm1heE91dGxpbmVMZXZlbDtcbiAgICAgICAgICAgIGNvbnN0IHNIaWRkZW4gPSByZWNvcmQuaGlkZGVuID8gYCBoaWRkZW49XCIxXCJgIDogJyc7XG5cbiAgICAgICAgICAgIHRoaXMucm93SW5kZXgrKztcbiAgICAgICAgICAgIGxldCByb3cgPSBgPHJvdyByPVwiJHt0aGlzLnJvd0luZGV4fVwiJHt0aGlzLnJvd0hlaWdodH0ke291dGxpbmVMZXZlbH0ke3NIaWRkZW59PmA7XG5cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnNGb3JMZXZlbCA9IG93bmVyLmNvbHVtbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGMgPT4gKGMubGV2ZWwgPCBqICYmXG4gICAgICAgICAgICAgICAgICAgIGMuaGVhZGVyVHlwZSAhPT0gSGVhZGVyVHlwZS5NdWx0aUNvbHVtbkhlYWRlciB8fCBjLmxldmVsID09PSBqKSAmJiBjLmNvbHVtblNwYW4gPiAwICYmICFjLnNraXApXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuc3RhcnRJbmRleCAtIGIuc3RhcnRJbmRleClcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5waW5uZWRJbmRleCAtIGIucGlubmVkSW5kZXgpO1xuXG4gICAgICAgICAgICBsZXQgc3RhcnRWYWx1ZSA9IDAgKyByZWNvcmQubGV2ZWw7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgY3VycmVudENvbCBvZiBoZWFkZXJzRm9yTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENvbC5sZXZlbCA9PT0gaikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29sdW1uQ29vcmRpbmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uQ29vcmRpbmF0ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBFeGNlbFN0cmluZ3MuZ2V0RXhjZWxDb2x1bW4oc3RhcnRWYWx1ZSkgKyB0aGlzLnJvd0luZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbHVtblZhbHVlID0gd29ya3NoZWV0RGF0YS5kYXRhRGljdGlvbmFyeS5zYXZlVmFsdWUoY3VycmVudENvbC5oZWFkZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByb3cgKz0gYDxjIHI9XCIke2NvbHVtbkNvb3JkaW5hdGV9XCIgcz1cIjNcIiB0PVwic1wiPjx2PiR7Y29sdW1uVmFsdWV9PC92PjwvYz5gO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChqICE9PSBvd25lci5tYXhMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZUNlbGxzQ291bnRlcisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZUNlbGxTdHIgKz0gYCA8bWVyZ2VDZWxsIHJlZj1cIiR7Y29sdW1uQ29vcmRpbmF0ZX06YDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDb2wuaGVhZGVyVHlwZSA9PT0gSGVhZGVyVHlwZS5Db2x1bW5IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5Db29yZGluYXRlID0gRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKHN0YXJ0VmFsdWUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMucm93SW5kZXggKyBvd25lci5tYXhMZXZlbCAtIGN1cnJlbnRDb2wubGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMTsgayA8IGN1cnJlbnRDb2wuY29sdW1uU3BhbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkNvb3JkaW5hdGUgPSBFeGNlbFN0cmluZ3MuZ2V0RXhjZWxDb2x1bW4oc3RhcnRWYWx1ZSArIGspICsgdGhpcy5yb3dJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93ICs9IGA8YyByPVwiJHtjb2x1bW5Db29yZGluYXRlfVwiIHM9XCIzXCIgLz5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZUNlbGxTdHIgKz0gYCR7Y29sdW1uQ29vcmRpbmF0ZX1cIiAvPmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlICs9IGN1cnJlbnRDb2wuY29sdW1uU3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvdyArPSBgPC9yb3c+YDtcbiAgICAgICAgICAgIHJvd0RhdGFBcnIucHVzaChyb3cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwcm9jZXNzUm93KHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEsIGk6IG51bWJlciwgaGVhZGVyc0ZvckxldmVsOiBhbnlbXSwgaXNIaWVyYXJjaGljYWxHcmlkOiBib29sZWFuKSB7XG4gICAgICAgIGNvbnN0IHJlY29yZCA9IHdvcmtzaGVldERhdGEuZGF0YVtpXTtcblxuICAgICAgICBjb25zdCByb3dEYXRhID0gbmV3IEFycmF5KHdvcmtzaGVldERhdGEuY29sdW1uQ291bnQgKyAyKTtcblxuICAgICAgICBjb25zdCByb3dMZXZlbCA9IHJlY29yZC5sZXZlbDtcbiAgICAgICAgY29uc3Qgb3V0bGluZUxldmVsID0gcm93TGV2ZWwgPiAwID8gYCBvdXRsaW5lTGV2ZWw9XCIke3Jvd0xldmVsfVwiYCA6ICcnO1xuICAgICAgICB0aGlzLm1heE91dGxpbmVMZXZlbCA9IHRoaXMubWF4T3V0bGluZUxldmVsIDwgcm93TGV2ZWwgPyByb3dMZXZlbCA6IHRoaXMubWF4T3V0bGluZUxldmVsO1xuXG4gICAgICAgIGNvbnN0IHNIaWRkZW4gPSByZWNvcmQuaGlkZGVuID8gYCBoaWRkZW49XCIxXCJgIDogJyc7XG5cbiAgICAgICAgdGhpcy5yb3dJbmRleCsrO1xuICAgICAgICByb3dEYXRhWzBdID1cbiAgICAgICAgICAgIGA8cm93IHI9XCIke3RoaXMucm93SW5kZXh9XCIke3RoaXMucm93SGVpZ2h0fSR7b3V0bGluZUxldmVsfSR7c0hpZGRlbn0+YDtcblxuICAgICAgICBjb25zdCBrZXlzID0gd29ya3NoZWV0RGF0YS5pc1NwZWNpYWxEYXRhID8gW3JlY29yZC5kYXRhXSA6IGhlYWRlcnNGb3JMZXZlbDtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IGogKyAoaXNIaWVyYXJjaGljYWxHcmlkID8gcm93TGV2ZWwgOiAwKTtcblxuICAgICAgICAgICAgY29uc3QgY2VsbERhdGEgPSB0aGlzLmdldENlbGxEYXRhKHdvcmtzaGVldERhdGEsIGksIGNvbCwga2V5c1tqXSk7XG5cbiAgICAgICAgICAgIHJvd0RhdGFbaiArIDFdID0gY2VsbERhdGE7XG4gICAgICAgIH1cblxuICAgICAgICByb3dEYXRhW2tleXMubGVuZ3RoICsgMV0gPSAnPC9yb3c+JztcblxuICAgICAgICByZXR1cm4gcm93RGF0YS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldENlbGxEYXRhKHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEsIHJvdzogbnVtYmVyLCBjb2x1bW46IG51bWJlciwga2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBkaWN0aW9uYXJ5ID0gd29ya3NoZWV0RGF0YS5kYXRhRGljdGlvbmFyeTtcbiAgICAgICAgY29uc3QgY29sdW1uTmFtZSA9IEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbihjb2x1bW4pICsgKHRoaXMucm93SW5kZXgpO1xuICAgICAgICBjb25zdCBmdWxsUm93ID0gd29ya3NoZWV0RGF0YS5kYXRhW3Jvd107XG4gICAgICAgIGNvbnN0IGlzSGVhZGVyUmVjb3JkID0gZnVsbFJvdy50eXBlID09PSBFeHBvcnRSZWNvcmRUeXBlLkhlYWRlclJlY29yZDtcblxuICAgICAgICBjb25zdCBjZWxsVmFsdWUgPSB3b3Jrc2hlZXREYXRhLmlzU3BlY2lhbERhdGEgP1xuICAgICAgICAgICAgZnVsbFJvdy5kYXRhIDpcbiAgICAgICAgICAgIGZ1bGxSb3cuZGF0YVtrZXldO1xuXG4gICAgICAgIGlmIChjZWxsVmFsdWUgPT09IHVuZGVmaW5lZCB8fCBjZWxsVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBgPGMgcj1cIiR7Y29sdW1uTmFtZX1cIiBzPVwiMVwiLz5gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2F2ZWRWYWx1ZSA9IGRpY3Rpb25hcnkuc2F2ZVZhbHVlKGNlbGxWYWx1ZSwgaXNIZWFkZXJSZWNvcmQpO1xuICAgICAgICAgICAgY29uc3QgaXNTYXZlZEFzU3RyaW5nID0gc2F2ZWRWYWx1ZSAhPT0gLTE7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzU2F2ZWRBc0RhdGUgPSAhaXNTYXZlZEFzU3RyaW5nICYmIGNlbGxWYWx1ZSBpbnN0YW5jZW9mIERhdGU7XG5cbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGlzU2F2ZWRBc1N0cmluZyA/IHNhdmVkVmFsdWUgOiBjZWxsVmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChpc1NhdmVkQXNEYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZVpvbmVPZmZzZXQgPSB2YWx1ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDA7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNvU3RyaW5nID0gKG5ldyBEYXRlKHZhbHVlIC0gdGltZVpvbmVPZmZzZXQpKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaXNvU3RyaW5nLnN1YnN0cmluZygwLCBpc29TdHJpbmcuaW5kZXhPZignLicpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGlzU2F2ZWRBc1N0cmluZyA/IGAgdD1cInNcImAgOiBpc1NhdmVkQXNEYXRlID8gYCB0PVwiZFwiYCA6ICcnO1xuXG4gICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBpc0hlYWRlclJlY29yZCA/IGAgcz1cIjNcImAgOiBpc1NhdmVkQXNTdHJpbmcgPyAnJyA6IGlzU2F2ZWRBc0RhdGUgPyBgIHM9XCIyXCJgIDogYCBzPVwiMVwiYDtcblxuICAgICAgICAgICAgcmV0dXJuIGA8YyByPVwiJHtjb2x1bW5OYW1lfVwiJHt0eXBlfSR7Zm9ybWF0fT48dj4ke3ZhbHVlfTwvdj48L2M+YDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHlsZUZpbGUgaW1wbGVtZW50cyBJRXhjZWxGaWxlIHtcbiAgICBwdWJsaWMgd3JpdGVFbGVtZW50KGZvbGRlcjogSlNaaXAsIHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEpIHtcbiAgICAgICAgY29uc3QgaGFzTnVtYmVyVmFsdWVzID0gd29ya3NoZWV0RGF0YS5kYXRhRGljdGlvbmFyeSAmJiB3b3Jrc2hlZXREYXRhLmRhdGFEaWN0aW9uYXJ5Lmhhc051bWJlclZhbHVlcztcbiAgICAgICAgY29uc3QgaGFzRGF0ZVZhbHVlcyA9IHdvcmtzaGVldERhdGEuZGF0YURpY3Rpb25hcnkgJiYgd29ya3NoZWV0RGF0YS5kYXRhRGljdGlvbmFyeS5oYXNEYXRlVmFsdWVzO1xuICAgICAgICBjb25zdCBpc0hpZXJhcmNoaWNhbEdyaWQgPSB3b3Jrc2hlZXREYXRhLmRhdGFbMF0/LnR5cGUgPT09IEV4cG9ydFJlY29yZFR5cGUuSGllcmFyY2hpY2FsR3JpZFJlY29yZDtcblxuICAgICAgICBmb2xkZXIuZmlsZSgnc3R5bGVzLnhtbCcsIEV4Y2VsU3RyaW5ncy5nZXRTdHlsZXMoaGFzTnVtYmVyVmFsdWVzLCBoYXNEYXRlVmFsdWVzLCBpc0hpZXJhcmNoaWNhbEdyaWQpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgV29ya2Jvb2tGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHVibGljIHdyaXRlRWxlbWVudChmb2xkZXI6IEpTWmlwLCB3b3Jrc2hlZXREYXRhOiBXb3Jrc2hlZXREYXRhKSB7XG4gICAgICAgIGZvbGRlci5maWxlKCd3b3JrYm9vay54bWwnLCBFeGNlbFN0cmluZ3MuZ2V0V29ya2Jvb2sod29ya3NoZWV0RGF0YS5vcHRpb25zLndvcmtzaGVldE5hbWUpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgQ29udGVudFR5cGVzRmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBKU1ppcCwgd29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSkge1xuICAgICAgICBmb2xkZXIuZmlsZSgnW0NvbnRlbnRfVHlwZXNdLnhtbCcsIEV4Y2VsU3RyaW5ncy5nZXRDb250ZW50VHlwZXNYTUwoIXdvcmtzaGVldERhdGEuaXNFbXB0eSwgd29ya3NoZWV0RGF0YS5vcHRpb25zLmV4cG9ydEFzVGFibGUpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgU2hhcmVkU3RyaW5nc0ZpbGUgaW1wbGVtZW50cyBJRXhjZWxGaWxlIHtcbiAgICBwdWJsaWMgd3JpdGVFbGVtZW50KGZvbGRlcjogSlNaaXAsIHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEpIHtcbiAgICAgICAgY29uc3QgZGljdCA9IHdvcmtzaGVldERhdGEuZGF0YURpY3Rpb25hcnk7XG4gICAgICAgIGNvbnN0IHNvcnRlZFZhbHVlcyA9IGRpY3QuZ2V0S2V5cygpO1xuICAgICAgICBjb25zdCBzaGFyZWRTdHJpbmdzID0gbmV3IEFycmF5PHN0cmluZz4oc29ydGVkVmFsdWVzLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBzb3J0ZWRWYWx1ZXMpIHtcbiAgICAgICAgICAgIHNoYXJlZFN0cmluZ3NbZGljdC5nZXRTYW5pdGl6ZWRWYWx1ZSh2YWx1ZSldID0gJzxzaT48dD4nICsgdmFsdWUgKyAnPC90Pjwvc2k+JztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvbGRlci5maWxlKCdzaGFyZWRTdHJpbmdzLnhtbCcsIEV4Y2VsU3RyaW5ncy5nZXRTaGFyZWRTdHJpbmdYTUwoXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWN0LnN0cmluZ3NDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZFZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRTdHJpbmdzLmpvaW4oJycpKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBUYWJsZXNGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHVibGljIHdyaXRlRWxlbWVudChmb2xkZXI6IEpTWmlwLCB3b3Jrc2hlZXREYXRhOiBXb3Jrc2hlZXREYXRhKSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbkNvdW50ID0gd29ya3NoZWV0RGF0YS5jb2x1bW5Db3VudDtcbiAgICAgICAgY29uc3QgbGFzdENvbHVtbiA9IEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbihjb2x1bW5Db3VudCAtIDEpICsgd29ya3NoZWV0RGF0YS5yb3dDb3VudDtcbiAgICAgICAgY29uc3QgZGltZW5zaW9uID0gJ0ExOicgKyBsYXN0Q29sdW1uO1xuICAgICAgICBjb25zdCBoYXNVc2VyU2V0SW5kZXggPSB3b3Jrc2hlZXREYXRhLm93bmVyLmNvbHVtbnMuc29tZShjID0+IGMuZXhwb3J0SW5kZXggIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGhhc1VzZXJTZXRJbmRleFxuICAgICAgICAgICAgPyB3b3Jrc2hlZXREYXRhLnJvb3RLZXlzXG4gICAgICAgICAgICA6IHdvcmtzaGVldERhdGEub3duZXIuY29sdW1uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoYyA9PiAhYy5za2lwKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0SW5kZXggLSBiLnN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEucGlubmVkSW5kZXggLSBiLnBpbm5lZEluZGV4KVxuICAgICAgICAgICAgICAgIC5tYXAoYyA9PiBjLmhlYWRlcik7XG5cbiAgICAgICAgbGV0IHNvcnRTdHJpbmcgPSAnJztcblxuICAgICAgICBsZXQgdGFibGVDb2x1bW5zID0gJzx0YWJsZUNvbHVtbnMgY291bnQ9XCInICsgY29sdW1uQ291bnQgKyAnXCI+JztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9ICB2YWx1ZXNbaV07XG4gICAgICAgICAgICB0YWJsZUNvbHVtbnMgKz0gJzx0YWJsZUNvbHVtbiBpZD1cIicgKyAoaSArIDEpICsgJ1wiIG5hbWU9XCInICsgdmFsdWUgKyAnXCIvPic7XG4gICAgICAgIH1cblxuICAgICAgICB0YWJsZUNvbHVtbnMgKz0gJzwvdGFibGVDb2x1bW5zPic7XG5cbiAgICAgICAgaWYgKHdvcmtzaGVldERhdGEuc29ydCkge1xuICAgICAgICAgICAgY29uc3Qgc29ydGluZ0V4cHJlc3Npb24gPSB3b3Jrc2hlZXREYXRhLnNvcnQ7XG4gICAgICAgICAgICBjb25zdCBzYyA9IEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbih2YWx1ZXMuaW5kZXhPZihzb3J0aW5nRXhwcmVzc2lvbi5maWVsZE5hbWUpKTtcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IHNvcnRpbmdFeHByZXNzaW9uLmRpciAtIDE7XG4gICAgICAgICAgICBzb3J0U3RyaW5nID0gYDxzb3J0U3RhdGUgcmVmPVwiQTI6JHtsYXN0Q29sdW1ufVwiPjxzb3J0Q29uZGl0aW9uIGRlc2NlbmRpbmc9XCIke2Rpcn1cIiByZWY9XCIke3NjfTE6JHtzY30xNVwiLz48L3NvcnRTdGF0ZT5gO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9sZGVyLmZpbGUoJ3RhYmxlMS54bWwnLCBFeGNlbFN0cmluZ3MuZ2V0VGFibGVzWE1MKGRpbWVuc2lvbiwgdGFibGVDb2x1bW5zLCBzb3J0U3RyaW5nKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFdvcmtzaGVldFJlbHNGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHVibGljIHdyaXRlRWxlbWVudChmb2xkZXI6IEpTWmlwKSB7XG4gICAgICAgIGZvbGRlci5maWxlKCdzaGVldDEueG1sLnJlbHMnLCBFeGNlbFN0cmluZ3MuZ2V0V29ya3NoZWV0UmVscygpKTtcbiAgICB9XG59XG4iXX0=