import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, HostBinding, Input, ViewChild, ViewChildren } from '@angular/core';
import { flatten } from '../../core/utils';
import { IgxGridForOfDirective } from '../../directives/for-of/for_of.directive';
import { IgxGridFilteringRowComponent } from '../filtering/base/grid-filtering-row.component';
import { IgxGridHeaderGroupComponent } from './grid-header-group.component';
/**
 *
 * For all intents & purposes treat this component as what a <thead> usually is in the default <table> element.
 *
 * This container holds the grid header elements and their behavior/interactions.
 *
 * @hidden @internal
 */
export class IgxGridHeaderRowComponent {
    constructor(ref, cdr) {
        this.ref = ref;
        this.cdr = cdr;
        /** Pinned columns of the grid. */
        this.pinnedColumnCollection = [];
        /** Unpinned columns of the grid. */
        this.unpinnedColumnCollection = [];
    }
    /**
     * @hidden
     * @internal
     */
    get cosyStyle() {
        return this.density === 'cosy';
    }
    /**
     * @hidden
     * @internal
     */
    get compactStyle() {
        return this.density === 'compact';
    }
    /**
     * The flattened header groups collection.
     *
     * @hidden @internal
     */
    get groups() {
        var _a, _b;
        return flatten((_b = (_a = this._groups) === null || _a === void 0 ? void 0 : _a.toArray()) !== null && _b !== void 0 ? _b : []);
    }
    /** Header components in the header row. */
    get headers() {
        return this.groups.map(group => group.header);
    }
    /** Filtering cell components in the header row. */
    get filters() {
        return this.groups.map(group => group.filter);
    }
    get navigation() {
        return this.grid.navigation;
    }
    get nativeElement() {
        return this.ref.nativeElement;
    }
    /**
     * Returns whether the current grid instance is a hierarchical grid.
     * as only hierarchical grids have the `isHierarchicalRecord` method.
     *
     * @hidden @internal
     */
    get isHierarchicalGrid() {
        return !!this.grid.isHierarchicalRecord;
    }
    get indentationCSSClasses() {
        return `igx-grid__header-indentation igx-grid__row-indentation--level-${this.grid.groupingExpressions.length}`;
    }
    get rowSelectorsContext() {
        const ctx = {
            $implicit: {
                selectedCount: this.grid.selectionService.filteredSelectedRowIds.length,
                totalCount: this.grid.totalRowsCountAfterFilter
            }
        };
        if (this.isHierarchicalGrid) {
            ctx.$implicit.selectAll = () => this.grid.selectAllRows();
            ctx.$implicit.deselectAll = () => this.grid.deselectAllRows();
        }
        return ctx;
    }
    /**
     * This hook exists as a workaround for the unfortunate fact
     * that when we have pinned columns in the grid, the unpinned columns headers
     * are affected by a delayed change detection cycle after a horizontal scroll :(
     * Thus, we tell the parent grid change detector to check us at each cycle.
     *
     * @hidden @internal
     */
    ngDoCheck() {
        this.cdr.markForCheck();
    }
    headerRowSelection(event) {
        if (!this.grid.isMultiRowSelectionEnabled) {
            return;
        }
        if (this.grid.selectionService.areAllRowSelected()) {
            this.grid.selectionService.clearRowSelection(event);
        }
        else {
            this.grid.selectionService.selectAllRows(event);
        }
    }
}
IgxGridHeaderRowComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-grid-header-row',
                template: "<div role=\"rowgroup\" class=\"igx-grid-thead__wrapper\" [style.width.px]=\"width\"\n    [class.igx-grid__tr--mrl]=\"hasMRL\">\n\n    <!-- Column headers area -->\n    <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n\n        <!-- Left column moving area -->\n        <ng-container *ngIf=\"grid.hasMovableColumns && grid.columnInDrag && pinnedColumnCollection.length <= 0\">\n            <span id=\"left\" class=\"igx-grid__scroll-on-drag-left\" droppable=\"true\" [style.left.px]=\"grid.pinnedWidth\"\n                [igxColumnMovingDrop]=\"headerContainer\"></span>\n        </ng-container>\n        <ng-container *ngIf=\"grid.hasMovableColumns && grid.columnInDrag && pinnedColumnCollection.length > 0\">\n            <span id=\"left\" class=\"igx-grid__scroll-on-drag-pinned\" droppable=\"true\" [style.left.px]=\"grid.pinnedWidth\"\n                [igxColumnMovingDrop]=\"headerContainer\"></span>\n        </ng-container>\n\n        <!-- Row dragging area -->\n        <ng-container *ngIf=\"grid.rowDraggable\">\n            <div #headerDragContainer class=\"igx-grid__drag-indicator igx-grid__tr-action\" (pointerdown)=\"$event.preventDefault()\" [class.igx-grid__drag-indicator--header]=\"!grid.isRowSelectable\">\n                <div style=\"visibility: hidden;\">\n                    <ng-container *ngTemplateOutlet=\"grid.dragIndicatorIconTemplate || grid.dragIndicatorIconBase\"></ng-container>\n                </div>\n            </div>\n        </ng-container>\n\n        <!-- Row selectors area -->\n        <ng-container *ngIf=\"grid.showRowSelectors\">\n            <div #headerSelectorContainer class=\"igx-grid__cbx-selection igx-grid__tr-action\"\n                [class.igx-grid__cbx-selection--push]=\"grid.filteringService.isFilterRowVisible\"\n                (click)=\"headerRowSelection($event)\"\n                (pointerdown)=\"$event.preventDefault()\">\n                <ng-container #headSelector\n                    *ngTemplateOutlet=\"grid.headSelectorTemplate || headSelectorBaseTemplate; context: rowSelectorsContext\">\n                </ng-container>\n            </div>\n        </ng-container>\n\n        <!-- Hierarchical grids expand all area -->\n        <ng-container *ngIf=\"isHierarchicalGrid\">\n            <div #headerHierarchyExpander\n                (click)=\"grid.toggleAll()\"\n                (pointerdown)=\"$event.preventDefault()\"\n                [hidden]=\"!grid.hasExpandableChildren || !grid.hasVisibleColumns\"\n                [ngClass]=\"{\n                    'igx-grid__hierarchical-expander igx-grid__hierarchical-expander--header igx-grid__tr-action': grid.hasExpandableChildren,\n                    'igx-grid__hierarchical-expander--push': grid.filteringService.isFilterRowVisible,\n                    'igx-grid__hierarchical-expander--no-border': grid.isRowSelectable || grid.rowDraggable\n                }\">\n                <ng-container *ngTemplateOutlet=\"grid.iconTemplate; context: { $implicit: grid }\"></ng-container>\n            </div>\n        </ng-container>\n\n\n        <!-- Grouping icon toggle area -->\n        <ng-container *ngIf=\"grid?.groupingExpressions?.length\">\n            <div #headerGroupContainer class=\"{{ indentationCSSClasses }}\"\n                (click)=\"grid.toggleAllGroupRows()\"\n                (pointerdown)=\"$event.preventDefault()\">\n                <ng-container *ngTemplateOutlet=\"grid.iconTemplate\"></ng-container>\n            </div>\n        </ng-container>\n\n        <!-- Pinned columns collection from the start -->\n        <ng-container *ngIf=\"pinnedColumnCollection.length && grid.isPinningToStart\">\n            <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                <igx-grid-header-group\n                    [ngClass]=\"column.headerGroupClasses\"\n                    [ngStyle]=\"column.headerGroupStyles | igxHeaderGroupStyle:column:grid.pipeTrigger\"\n                    [column]=\"column\"\n                    [style.min-width]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                    [style.flex-basis]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\">\n                </igx-grid-header-group>\n            </ng-container>\n        </ng-container>\n\n        <!-- Unpinned columns collection -->\n        <ng-template igxGridFor #headerVirtualContainer let-column\n            [igxGridForOf]=\"unpinnedColumnCollection | igxTopLevel\"\n            [igxForScrollContainer]=\"grid.parentVirtDir\"\n            [igxForContainerSize]=\"grid.unpinnedWidth\"\n            [igxForTrackBy]=\"grid.trackColumnChanges\"\n            [igxForSizePropName]=\"'calcPixelWidth'\"\n            [igxForScrollOrientation]=\"'horizontal'\"\n        >\n            <igx-grid-header-group\n                [ngClass]=\"column.headerGroupClasses\"\n                [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\"\n                [column]=\"column\"\n                [style.min-width]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                [style.flex-basis]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\">\n            </igx-grid-header-group>\n        </ng-template>\n\n        <!-- Pinned columns collection at the end -->\n        <ng-container *ngIf=\"pinnedColumnCollection.length && !grid.isPinningToStart\">\n            <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                <igx-grid-header-group\n                    [ngClass]=\"column.headerGroupClasses\"\n                    [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\"\n                    [column]=\"column\"\n                    [style.min-width]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                    [style.flex-basis]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                    [style.left]=\"column.rightPinnedOffset\">\n                </igx-grid-header-group>\n            </ng-container>\n        </ng-container>\n    </div>\n\n    <!-- Filter row area -->\n    <ng-container *ngIf=\"grid.filteringService.isFilterRowVisible\">\n        <igx-grid-filtering-row #filteringRow\n            [column]=\"grid.filteringService.filteredColumn\"\n            [style.width.px]=\"width\">\n        </igx-grid-filtering-row>\n    </ng-container>\n\n    <!-- Right column moving area -->\n    <ng-container *ngIf=\"grid.hasMovableColumns && grid.columnInDrag\">\n        <span id=\"right\" class=\"igx-grid__scroll-on-drag-right\" droppable=\"true\" [igxColumnMovingDrop]=\"headerContainer\"></span>\n    </ng-container>\n</div>\n\n<!-- Header thumb area -->\n<div class=\"igx-grid-thead__thumb\" [hidden]=\"!grid.hasVerticalScroll()\" [style.width.px]=\"grid.scrollSize\"></div>\n\n<!-- Default row selection header checkbox template -->\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            [disableRipple]=\"true\"\n            [ngStyle]=\"{'visibility': grid.isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"grid.headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n"
            },] }
];
IgxGridHeaderRowComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
IgxGridHeaderRowComponent.propDecorators = {
    grid: [{ type: Input }],
    pinnedColumnCollection: [{ type: Input }],
    unpinnedColumnCollection: [{ type: Input }],
    activeDescendant: [{ type: Input }],
    hasMRL: [{ type: Input }],
    width: [{ type: Input }],
    density: [{ type: Input }],
    cosyStyle: [{ type: HostBinding, args: ['class.igx-grid-thead--cosy',] }],
    compactStyle: [{ type: HostBinding, args: ['class.igx-grid-thead--compact',] }],
    _groups: [{ type: ViewChildren, args: [IgxGridHeaderGroupComponent,] }],
    headerContainer: [{ type: ViewChild, args: ['headerVirtualContainer', { read: IgxGridForOfDirective, static: true },] }],
    headerDragContainer: [{ type: ViewChild, args: ['headerDragContainer',] }],
    headerSelectorContainer: [{ type: ViewChild, args: ['headerSelectorContainer',] }],
    headerGroupContainer: [{ type: ViewChild, args: ['headerGroupContainer',] }],
    headSelectorBaseTemplate: [{ type: ViewChild, args: ['headSelectorBaseTemplate',] }],
    filterRow: [{ type: ViewChild, args: [IgxGridFilteringRowComponent,] }],
    headerHierarchyExpander: [{ type: ViewChild, args: ['headerHierarchyExpander',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC1oZWFkZXItcm93LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9oZWFkZXJzL2dyaWQtaGVhZGVyLXJvdy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUVULFVBQVUsRUFDVixXQUFXLEVBQ1gsS0FBSyxFQUdMLFNBQVMsRUFDVCxZQUFZLEVBQ2YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBRWpGLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLGdEQUFnRCxDQUFDO0FBRTlGLE9BQU8sRUFBRSwyQkFBMkIsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBVzVFOzs7Ozs7O0dBT0c7QUFNSCxNQUFNLE9BQU8seUJBQXlCO0lBOElsQyxZQUNZLEdBQTRCLEVBQzVCLEdBQXNCO1FBRHRCLFFBQUcsR0FBSCxHQUFHLENBQXlCO1FBQzVCLFFBQUcsR0FBSCxHQUFHLENBQW1CO1FBMUlsQyxrQ0FBa0M7UUFFM0IsMkJBQXNCLEdBQXlCLEVBQUUsQ0FBQztRQUV6RCxvQ0FBb0M7UUFFN0IsNkJBQXdCLEdBQXlCLEVBQUUsQ0FBQztJQXFJdkQsQ0FBQztJQXZITDs7O09BR0c7SUFDSCxJQUNXLFNBQVM7UUFDaEIsT0FBTyxJQUFJLENBQUMsT0FBTyxLQUFLLE1BQU0sQ0FBQztJQUNuQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFDVyxZQUFZO1FBQ25CLE9BQU8sSUFBSSxDQUFDLE9BQU8sS0FBSyxTQUFTLENBQUM7SUFDdEMsQ0FBQztJQWVEOzs7O09BSUc7SUFDSCxJQUFXLE1BQU07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QUUsSUFBSSxFQUFFO2tDQUdqRixTQUFTLFNBQUMscUJBQXFCO3NDQUcvQixTQUFTLFNBQUMseUJBQXlCO21DQUduQyxTQUFTLFNBQUMsc0JBQXNCO3VDQUdoQyxTQUFTLFNBQUMsMEJBQTBCO3dCQUdwQyxTQUFTLFNBQUMsNEJBQTRCO3NDQVN0QyxTQUFTLFNBQUMseUJBQXlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgRG9DaGVjayxcbiAgICBFbGVtZW50UmVmLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIElucHV0LFxuICAgIFF1ZXJ5TGlzdCxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3Q2hpbGQsXG4gICAgVmlld0NoaWxkcmVuXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGlzcGxheURlbnNpdHkgfSBmcm9tICcuLi8uLi9jb3JlL2Rpc3BsYXlEZW5zaXR5JztcbmltcG9ydCB7IGZsYXR0ZW4gfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IElneEdyaWRGb3JPZkRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvZm9yLW9mL2Zvcl9vZi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgR3JpZFR5cGUgfSBmcm9tICcuLi9jb21tb24vZ3JpZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSWd4R3JpZEZpbHRlcmluZ1Jvd0NvbXBvbmVudCB9IGZyb20gJy4uL2ZpbHRlcmluZy9iYXNlL2dyaWQtZmlsdGVyaW5nLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4Q29sdW1uQ29tcG9uZW50IH0gZnJvbSAnLi4vcHVibGljX2FwaSc7XG5pbXBvcnQgeyBJZ3hHcmlkSGVhZGVyR3JvdXBDb21wb25lbnQgfSBmcm9tICcuL2dyaWQtaGVhZGVyLWdyb3VwLmNvbXBvbmVudCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSWd4R3JpZFJvd1NlbGVjdG9yc1RlbXBsYXRlQ29udGV4dCB7XG4gICAgJGltcGxpY2l0OiB7XG4gICAgICAgIHNlbGVjdGVkQ291bnQ6IG51bWJlcjtcbiAgICAgICAgdG90YWxDb3VudDogbnVtYmVyO1xuICAgICAgICBzZWxlY3RBbGw/OiAoKSA9PiB2b2lkO1xuICAgICAgICBkZXNlbGVjdEFsbD86ICgpID0+IHZvaWQ7XG4gICAgfTtcbn1cblxuLyoqXG4gKlxuICogRm9yIGFsbCBpbnRlbnRzICYgcHVycG9zZXMgdHJlYXQgdGhpcyBjb21wb25lbnQgYXMgd2hhdCBhIDx0aGVhZD4gdXN1YWxseSBpcyBpbiB0aGUgZGVmYXVsdCA8dGFibGU+IGVsZW1lbnQuXG4gKlxuICogVGhpcyBjb250YWluZXIgaG9sZHMgdGhlIGdyaWQgaGVhZGVyIGVsZW1lbnRzIGFuZCB0aGVpciBiZWhhdmlvci9pbnRlcmFjdGlvbnMuXG4gKlxuICogQGhpZGRlbiBAaW50ZXJuYWxcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgc2VsZWN0b3I6ICdpZ3gtZ3JpZC1oZWFkZXItcm93JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZ3JpZC1oZWFkZXItcm93LmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hHcmlkSGVhZGVyUm93Q29tcG9uZW50IGltcGxlbWVudHMgRG9DaGVjayB7XG5cbiAgICAvKiogVGhlIGdyaWQgY29tcG9uZW50IGNvbnRhaW5pbmcgdGhpcyBlbGVtZW50LiAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdyaWQ6IGFueTsgLy9HcmlkVHlwZTtcblxuICAgIC8qKiBQaW5uZWQgY29sdW1ucyBvZiB0aGUgZ3JpZC4gKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBwaW5uZWRDb2x1bW5Db2xsZWN0aW9uOiBJZ3hDb2x1bW5Db21wb25lbnRbXSA9IFtdO1xuXG4gICAgLyoqIFVucGlubmVkIGNvbHVtbnMgb2YgdGhlIGdyaWQuICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdW5waW5uZWRDb2x1bW5Db2xsZWN0aW9uOiBJZ3hDb2x1bW5Db21wb25lbnRbXSA9IFtdO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgYWN0aXZlRGVzY2VuZGFudDogc3RyaW5nO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaGFzTVJMOiBib29sZWFuO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgd2lkdGg6IG51bWJlcjtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGRlbnNpdHk6IERpc3BsYXlEZW5zaXR5O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWdyaWQtdGhlYWQtLWNvc3knKVxuICAgIHB1YmxpYyBnZXQgY29zeVN0eWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZW5zaXR5ID09PSAnY29zeSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWdyaWQtdGhlYWQtLWNvbXBhY3QnKVxuICAgIHB1YmxpYyBnZXQgY29tcGFjdFN0eWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZW5zaXR5ID09PSAnY29tcGFjdCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVhZGVyIGdyb3VwcyBpbnNpZGUgdGhlIGhlYWRlciByb3cuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrXG4gICAgICogTm90ZTogVGhlc2UgYXJlIG9ubHkgdGhlIHRvcCBsZXZlbCBoZWFkZXIgZ3JvdXBzIGluIGNhc2UgdGhlcmUgYXJlIG11bHRpLWNvbHVtbiBoZWFkZXJzXG4gICAgICogb3IgYSBzcGVjaWZpYyBjb2x1bW4gbGF5b3V0LiBJZiB5b3Ugd2FudCB0byBnZXQgdGhlIGZsYXR0ZW5lZCBjb2xsZWN0aW9uIHVzZSB0aGUgYGdyb3Vwc2BcbiAgICAgKiBwcm9wZXJ0eSBiZWxvdy5cbiAgICAgKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogKi9cbiAgICBAVmlld0NoaWxkcmVuKElneEdyaWRIZWFkZXJHcm91cENvbXBvbmVudClcbiAgICBwdWJsaWMgX2dyb3VwczogUXVlcnlMaXN0PElneEdyaWRIZWFkZXJHcm91cENvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhdHRlbmVkIGhlYWRlciBncm91cHMgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBncm91cHMoKTogSWd4R3JpZEhlYWRlckdyb3VwQ29tcG9uZW50W10ge1xuICAgICAgICByZXR1cm4gZmxhdHRlbih0aGlzLl9ncm91cHM/LnRvQXJyYXkoKSA/PyBbXSk7XG4gICAgfVxuXG4gICAgLyoqIEhlYWRlciBjb21wb25lbnRzIGluIHRoZSBoZWFkZXIgcm93LiAqL1xuICAgIHB1YmxpYyBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzLm1hcChncm91cCA9PiBncm91cC5oZWFkZXIpO1xuICAgIH1cblxuICAgIC8qKiBGaWx0ZXJpbmcgY2VsbCBjb21wb25lbnRzIGluIHRoZSBoZWFkZXIgcm93LiAqL1xuICAgIHB1YmxpYyBnZXQgZmlsdGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzLm1hcChncm91cCA9PiBncm91cC5maWx0ZXIpO1xuICAgIH1cblxuICAgIC8qKiBUaGUgdmlydHVhbGl6ZWQgcGFydCBvZiB0aGUgaGVhZGVyIHJvdyBjb250YWluaW5nIHRoZSB1bnBpbm5lZCBoZWFkZXIgZ3JvdXBzLiAqL1xuICAgIEBWaWV3Q2hpbGQoJ2hlYWRlclZpcnR1YWxDb250YWluZXInLCB7IHJlYWQ6IElneEdyaWRGb3JPZkRpcmVjdGl2ZSwgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGhlYWRlckNvbnRhaW5lcjogSWd4R3JpZEZvck9mRGlyZWN0aXZlPElneEdyaWRIZWFkZXJHcm91cENvbXBvbmVudD47XG5cbiAgICBAVmlld0NoaWxkKCdoZWFkZXJEcmFnQ29udGFpbmVyJylcbiAgICBwdWJsaWMgaGVhZGVyRHJhZ0NvbnRhaW5lcjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG5cbiAgICBAVmlld0NoaWxkKCdoZWFkZXJTZWxlY3RvckNvbnRhaW5lcicpXG4gICAgcHVibGljIGhlYWRlclNlbGVjdG9yQ29udGFpbmVyOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PjtcblxuICAgIEBWaWV3Q2hpbGQoJ2hlYWRlckdyb3VwQ29udGFpbmVyJylcbiAgICBwdWJsaWMgaGVhZGVyR3JvdXBDb250YWluZXI6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuXG4gICAgQFZpZXdDaGlsZCgnaGVhZFNlbGVjdG9yQmFzZVRlbXBsYXRlJylcbiAgICBwdWJsaWMgaGVhZFNlbGVjdG9yQmFzZVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxJZ3hHcmlkUm93U2VsZWN0b3JzVGVtcGxhdGVDb250ZXh0PjtcblxuICAgIEBWaWV3Q2hpbGQoSWd4R3JpZEZpbHRlcmluZ1Jvd0NvbXBvbmVudClcbiAgICBwdWJsaWMgZmlsdGVyUm93OiBJZ3hHcmlkRmlsdGVyaW5nUm93Q29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogRXhwYW5kL2NvbGxhcHNlIGFsbCBjaGlsZCBncmlkcyBhcmVhIGluIGEgaGllcmFyY2hpY2FsIGdyaWQuXG4gICAgICogYHVuZGVmaW5lZGAgaW4gdGhlIGJhc2UgYW5kIHRyZWUgZ3JpZHMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWwgQGhpZGRlblxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2hlYWRlckhpZXJhcmNoeUV4cGFuZGVyJylcbiAgICBwdWJsaWMgaGVhZGVySGllcmFyY2h5RXhwYW5kZXI6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuXG4gICAgcHVibGljIGdldCBuYXZpZ2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLm5hdmlnYXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBuYXRpdmVFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgZ3JpZCBpbnN0YW5jZSBpcyBhIGhpZXJhcmNoaWNhbCBncmlkLlxuICAgICAqIGFzIG9ubHkgaGllcmFyY2hpY2FsIGdyaWRzIGhhdmUgdGhlIGBpc0hpZXJhcmNoaWNhbFJlY29yZGAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGlzSGllcmFyY2hpY2FsR3JpZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5ncmlkLmlzSGllcmFyY2hpY2FsUmVjb3JkO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgaW5kZW50YXRpb25DU1NDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gYGlneC1ncmlkX19oZWFkZXItaW5kZW50YXRpb24gaWd4LWdyaWRfX3Jvdy1pbmRlbnRhdGlvbi0tbGV2ZWwtJHt0aGlzLmdyaWQuZ3JvdXBpbmdFeHByZXNzaW9ucy5sZW5ndGh9YDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHJvd1NlbGVjdG9yc0NvbnRleHQoKTogSWd4R3JpZFJvd1NlbGVjdG9yc1RlbXBsYXRlQ29udGV4dCB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgICRpbXBsaWNpdDoge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkQ291bnQ6IHRoaXMuZ3JpZC5zZWxlY3Rpb25TZXJ2aWNlLmZpbHRlcmVkU2VsZWN0ZWRSb3dJZHMubGVuZ3RoIGFzIG51bWJlcixcbiAgICAgICAgICAgICAgICB0b3RhbENvdW50OiB0aGlzLmdyaWQudG90YWxSb3dzQ291bnRBZnRlckZpbHRlciBhcyBudW1iZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBhcyBJZ3hHcmlkUm93U2VsZWN0b3JzVGVtcGxhdGVDb250ZXh0O1xuXG4gICAgICAgIGlmICh0aGlzLmlzSGllcmFyY2hpY2FsR3JpZCkge1xuICAgICAgICAgICAgY3R4LiRpbXBsaWNpdC5zZWxlY3RBbGwgPSAoKSA9PiB0aGlzLmdyaWQuc2VsZWN0QWxsUm93cygpO1xuICAgICAgICAgICAgY3R4LiRpbXBsaWNpdC5kZXNlbGVjdEFsbCA9ICgpID0+IHRoaXMuZ3JpZC5kZXNlbGVjdEFsbFJvd3MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjdHg7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgcmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICAgICAgcHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmXG4gICAgKSB7IH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaG9vayBleGlzdHMgYXMgYSB3b3JrYXJvdW5kIGZvciB0aGUgdW5mb3J0dW5hdGUgZmFjdFxuICAgICAqIHRoYXQgd2hlbiB3ZSBoYXZlIHBpbm5lZCBjb2x1bW5zIGluIHRoZSBncmlkLCB0aGUgdW5waW5uZWQgY29sdW1ucyBoZWFkZXJzXG4gICAgICogYXJlIGFmZmVjdGVkIGJ5IGEgZGVsYXllZCBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlIGFmdGVyIGEgaG9yaXpvbnRhbCBzY3JvbGwgOihcbiAgICAgKiBUaHVzLCB3ZSB0ZWxsIHRoZSBwYXJlbnQgZ3JpZCBjaGFuZ2UgZGV0ZWN0b3IgdG8gY2hlY2sgdXMgYXQgZWFjaCBjeWNsZS5cbiAgICAgKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG5nRG9DaGVjaygpIHtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGhlYWRlclJvd1NlbGVjdGlvbihldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZC5pc011bHRpUm93U2VsZWN0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5zZWxlY3Rpb25TZXJ2aWNlLmFyZUFsbFJvd1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5zZWxlY3Rpb25TZXJ2aWNlLmNsZWFyUm93U2VsZWN0aW9uKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5zZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdEFsbFJvd3MoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19