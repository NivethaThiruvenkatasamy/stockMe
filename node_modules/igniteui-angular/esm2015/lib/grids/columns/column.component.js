import { __decorate } from "tslib";
import { Subject } from 'rxjs';
import { ChangeDetectorRef, ChangeDetectionStrategy, Component, ContentChild, ContentChildren, Input, Output, EventEmitter, } from '@angular/core';
import { notifyChanges } from '../watch-changes';
import { WatchColumnChanges } from '../watch-changes';
import { GridColumnDataType } from '../../data-operations/data-util';
import { IgxBooleanFilteringOperand, IgxNumberFilteringOperand, IgxDateFilteringOperand, IgxStringFilteringOperand, IgxDateTimeFilteringOperand, IgxTimeFilteringOperand } from '../../data-operations/filtering-condition';
import { DefaultSortingStrategy } from '../../data-operations/sorting-strategy';
import { DisplayDensity } from '../../core/displayDensity';
import { IgxRowDirective } from '../row.directive';
import { GridBaseAPIService } from '../api.service';
import { IgxSummaryOperand, IgxNumberSummaryOperand, IgxDateSummaryOperand, IgxTimeSummaryOperand } from '../summaries/grid-summary';
import { IgxCellTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellEditorTemplateDirective, IgxCollapsibleIndicatorTemplateDirective, IgxFilterCellTemplateDirective } from './templates.directive';
import { DropPosition } from '../moving/moving.service';
import { isConstructor, PlatformUtil } from '../../core/utils';
import { IgxGridCell } from '../grid-public-cell';
const DEFAULT_DATE_FORMAT = 'mediumDate';
const DEFAULT_TIME_FORMAT = 'mediumTime';
const DEFAULT_DATE_TIME_FORMAT = 'medium';
const DEFAULT_DIGITS_INFO = '1.0-3';
/**
 * **Ignite UI for Angular Column** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid/grid#columns-configuration)
 *
 * The Ignite UI Column is used within an `igx-grid` element to define what data the column will show. Features such as sorting,
 * filtering & editing are enabled at the column level.  You can also provide a template containing custom content inside
 * the column using `ng-template` which will be used for all cells within the column.
 */
export class IgxColumnComponent {
    constructor(gridAPI, cdr, platform) {
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.platform = platform;
        /**
         * Sets/gets the `header` value.
         * ```typescript
         * let columnHeader = this.column.header;
         * ```
         * ```html
         * <igx-column [header] = "'ID'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.header = '';
        /**
         * Sets/gets the `title` value.
         * ```typescript
         * let title = this.column.title;
         * ```
         * ```html
         * <igx-column [title] = "'Some column tooltip'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.title = '';
        /**
         * Sets/gets whether the column is sortable.
         * Default value is `false`.
         * ```typescript
         * let isSortable = this.column.sortable;
         * ```
         * ```html
         * <igx-column [sortable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.sortable = false;
        /**
         * Sets/gets whether the column is groupable.
         * Default value is `false`.
         * ```typescript
         * let isGroupable = this.column.groupable;
         * ```
         * ```html
         * <igx-column [groupable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.groupable = false;
        /**
         * Sets/gets whether the column is filterable.
         * Default value is `true`.
         * ```typescript
         * let isFilterable = this.column.filterable;
         * ```
         * ```html
         * <igx-column [filterable] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.filterable = true;
        /**
         * Sets/gets whether the column is resizable.
         * Default value is `false`.
         * ```typescript
         * let isResizable = this.column.resizable;
         * ```
         * ```html
         * <igx-column [resizable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.resizable = false;
        /**
         * Sets/gets whether the column header is included in autosize logic.
         * Useful when template for a column header is sized based on parent, for example a default `div`.
         * Default value is `false`.
         * ```typescript
         * let isResizable = this.column.resizable;
         * ```
         * ```html
         * <igx-column [resizable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.autosizeHeader = true;
        /**
         * @hidden
         */
        this.hiddenChange = new EventEmitter();
        /** @hidden */
        this.expandedChange = new EventEmitter();
        /** @hidden */
        this.collapsibleChange = new EventEmitter();
        /** @hidden */
        this.visibleWhenCollapsedChange = new EventEmitter();
        /** @hidden */
        this.columnChange = new EventEmitter();
        /**
         * Gets whether the hiding is disabled.
         * ```typescript
         * let isHidingDisabled =  this.column.disableHiding;
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.disableHiding = false;
        /**
         * Gets whether the pinning is disabled.
         * ```typescript
         * let isPinningDisabled =  this.column.disablePinning;
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.disablePinning = false;
        /**
         * Sets/gets whether the column is movable.
         * Default value is `false`.
         * ```typescript
         * let isMovable = this.column.movable;
         * ```
         * ```html
         * <igx-column [movable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.movable = false;
        /**
         * Sets/gets the class selector of the column header.
         * ```typescript
         * let columnHeaderClass = this.column.headerClasses;
         * ```
         * ```html
         * <igx-column [headerClasses] = "'column-header'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.headerClasses = '';
        /**
         * Sets conditional style properties on the column header.
         * Similar to `ngStyle` it accepts an object literal where the keys are
         * the style properties and the value is the expression to be evaluated.
         * ```typescript
         * styles = {
         *  background: 'royalblue',
         *  color: (column) => column.pinned ? 'red': 'inherit'
         * }
         * ```
         * ```html
         * <igx-column [headerStyles]="styles"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.headerStyles = null;
        /**
         * Sets/gets the class selector of the column group header.
         * ```typescript
         * let columnHeaderClass = this.column.headerGroupClasses;
         * ```
         * ```html
         * <igx-column [headerGroupClasses] = "'column-group-header'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.headerGroupClasses = '';
        /**
         * Sets conditional style properties on the column header group wrapper.
         * Similar to `ngStyle` it accepts an object literal where the keys are
         * the style properties and the value is the expression to be evaluated.
         * ```typescript
         * styles = {
         *  background: 'royalblue',
         *  color: (column) => column.pinned ? 'red': 'inherit'
         * }
         * ```
         * ```html
         * <igx-column [headerGroupStyles]="styles"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.headerGroupStyles = null;
        /**
         * Sets conditional style properties on the column cells.
         * Similar to `ngStyle` it accepts an object literal where the keys are
         * the style properties and the value is the expression to be evaluated.
         * As with `cellClasses` it accepts a callback function.
         * ```typescript
         * styles = {
         *  background: 'royalblue',
         *  color: (rowData, columnKey, cellValue, rowIndex) => value.startsWith('Important') ? 'red': 'inherit'
         * }
         * ```
         * ```html
         * <igx-column [cellStyles]="styles"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.cellStyles = null;
        /**
         * Sets/gets whether the column filtering should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let filteringIgnoreCase = this.column.filteringIgnoreCase;
         * ```
         * ```html
         * <igx-column [filteringIgnoreCase] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.filteringIgnoreCase = true;
        /**
         * Sets/gets whether the column sorting should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let sortingIgnoreCase = this.column.sortingIgnoreCase;
         * ```
         * ```html
         * <igx-column [sortingIgnoreCase] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.sortingIgnoreCase = true;
        /**
         * Sets/gets whether the column is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.column.searchable';
         * ```
         * ```html
         *  <igx-column [searchable] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.searchable = true;
        /**
         * Sets/gets the data type of the column values.
         * Default value is `string`.
         * ```typescript
         * let columnDataType = this.column.dataType;
         * ```
         * ```html
         * <igx-column [dataType] = "'number'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.dataType = GridColumnDataType.String;
        /**
         * @hidden
         */
        this.widthChange = new EventEmitter();
        /**
         * @hidden
         */
        this.pinnedChange = new EventEmitter();
        /**
         * @hidden
         * @internal
         */
        this.defaultTimeFormat = 'hh:mm:ss tt';
        /**
         * @hidden
         * @internal
         */
        this.defaultDateTimeFormat = 'dd/MM/yyyy HH:mm:ss tt';
        /**
         * Sets/gets the parent column.
         * ```typescript
         * let parentColumn = this.column.parent;
         * ```
         * ```typescript
         * this.column.parent = higherLevelColumn;
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.parent = null;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        /**
         * @hidden
         */
        this._applySelectableClass = false;
        this._vIndex = NaN;
        /**
         * @hidden
         */
        this._pinned = false;
        /**
         * @hidden
         */
        this._summaries = null;
        /**
         * @hidden
         */
        this._filters = null;
        /**
         * @hidden
         */
        this._sortStrategy = DefaultSortingStrategy.instance();
        /**
         * @hidden
         */
        this._hidden = false;
        /**
         * @hidden
         */
        this._disablePinning = false;
        /**
         * @hidden
         */
        this._defaultMinWidth = '';
        /**
         * @hidden
         */
        this._hasSummary = false;
        /**
         * @hidden
         */
        this._collapsible = false;
        /**
         * @hidden
         */
        this._expanded = true;
        /**
         * @hidden
         */
        this._selectable = true;
        this._calcWidth = null;
        this._columnPipeArgs = { digitsInfo: DEFAULT_DIGITS_INFO };
    }
    /**
     * Sets/gets the `field` value.
     * ```typescript
     * let columnField = this.column.field;
     * ```
     * ```html
     * <igx-column [field] = "'ID'"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set field(value) {
        this._field = value;
        this.hasNestedPath = value === null || value === void 0 ? void 0 : value.includes('.');
    }
    get field() {
        return this._field;
    }
    /**
     * Returns if the column is selectable.
     * ```typescript
     * let columnSelectable = this.column.selectable;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get selectable() {
        return this._selectable;
    }
    /**
     * Sets if the column is selectable.
     * Default value is `true`.
     * ```html
     * <igx-column [selectable] = "false"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set selectable(value) {
        this._selectable = value;
    }
    /**
     * Gets whether the column is editable.
     * Default value is `false`.
     * ```typescript
     * let isEditable = this.column.editable;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get editable() {
        // Updating the primary key when grid has transactions (incl. row edit)
        // should not be allowed, as that can corrupt transaction state.
        const rowEditable = this.grid && this.grid.rowEditable;
        const hasTransactions = this.grid && this.grid.transactions.enabled;
        if (this.isPrimaryColumn && (rowEditable || hasTransactions)) {
            return false;
        }
        if (this._editable !== undefined) {
            return this._editable;
        }
        else {
            return rowEditable;
        }
    }
    /**
     * Sets whether the column is editable.
     * ```typescript
     * this.column.editable = true;
     * ```
     * ```html
     * <igx-column [editable] = "true"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set editable(editable) {
        this._editable = editable;
    }
    /**
     * Gets a value indicating whether the summary for the column is enabled.
     * ```typescript
     * let hasSummary = this.column.hasSummary;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get hasSummary() {
        return this._hasSummary;
    }
    /**
     * Sets a value indicating whether the summary for the column is enabled.
     * Default value is `false`.
     * ```html
     * <igx-column [hasSummary] = "true"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set hasSummary(value) {
        this._hasSummary = value;
        if (this.grid) {
            this.grid.summaryService.resetSummaryHeight();
        }
    }
    /**
     * Gets whether the column is hidden.
     * ```typescript
     * let isHidden = this.column.hidden;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get hidden() {
        return this._hidden;
    }
    /**
     * Sets the column hidden property.
     * Default value is `false`.
     * ```html
     * <igx-column [hidden] = "true"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(hidden)] = "model.isHidden"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set hidden(value) {
        if (this._hidden !== value) {
            this._hidden = value;
            this.hiddenChange.emit(this._hidden);
            if (this.columnLayoutChild && this.parent.hidden !== value) {
                this.parent.hidden = value;
                return;
            }
            if (this.grid) {
                this.grid.crudService.endEdit(false);
                this.grid.summaryService.resetSummaryHeight();
                this.grid.filteringService.refreshExpressions();
                this.grid.filteringService.hideFilteringRowOnColumnVisibilityChange(this);
                this.grid.notifyChanges();
            }
        }
    }
    /**
     * Returns if the column is selected.
     * ```typescript
     * let isSelected = this.column.selected;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get selected() {
        return this.grid.selectionService.isColumnSelected(this.field);
    }
    /**
     * Select/deselect a column.
     * Default value is `false`.
     * ```typescript
     * this.column.selected = true;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set selected(value) {
        if (this.selectable && value !== this.selected) {
            if (value) {
                this.grid.selectionService.selectColumnsWithNoEvent([this.field]);
            }
            else {
                this.grid.selectionService.deselectColumnsWithNoEvent([this.field]);
            }
            this.grid.notifyChanges();
        }
    }
    /**
     * Gets the `width` of the column.
     * ```typescript
     * let columnWidth = this.column.width;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get width() {
        return this.widthSetByUser ? this._width : this.defaultWidth;
    }
    /**
     * Sets the `width` of the column.
     * ```html
     * <igx-column [width] = "'25%'"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(width)]="model.columns[0].width"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set width(value) {
        if (value) {
            this._calcWidth = null;
            this.calcPixelWidth = NaN;
            this.widthSetByUser = true;
            // width could be passed as number from the template
            // host bindings are not px affixed so we need to ensure we affix simple number strings
            if (typeof (value) === 'number' || value.match(/^[0-9]*$/)) {
                value = value + 'px';
            }
            this._width = value;
            if (this.grid) {
                this.cacheCalcWidth();
            }
            this.widthChange.emit(this._width);
        }
    }
    /**
     * @hidden
     */
    get calcWidth() {
        return this.getCalcWidth();
    }
    /**
     * @hidden
     */
    get maxWidthPx() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.maxWidth && typeof this.maxWidth === 'string' && this.maxWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.maxWidth) / 100 * gridAvailableSize : parseFloat(this.maxWidth);
    }
    /**
     * @hidden
     */
    get maxWidthPercent() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.maxWidth && typeof this.maxWidth === 'string' && this.maxWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.maxWidth) : parseFloat(this.maxWidth) / gridAvailableSize * 100;
    }
    /**
     * @hidden
     */
    get minWidthPx() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.minWidth && typeof this.minWidth === 'string' && this.minWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.minWidth) / 100 * gridAvailableSize : parseFloat(this.minWidth);
    }
    /**
     * @hidden
     */
    get minWidthPercent() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.minWidth && typeof this.minWidth === 'string' && this.minWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.minWidth) : parseFloat(this.minWidth) / gridAvailableSize * 100;
    }
    /**
     * Sets/gets the minimum `width` of the column.
     * Default value is `88`;
     * ```typescript
     * let columnMinWidth = this.column.minWidth;
     * ```
     * ```html
     * <igx-column [minWidth] = "'100px'"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set minWidth(value) {
        const minVal = parseFloat(value);
        if (Number.isNaN(minVal)) {
            return;
        }
        this._defaultMinWidth = value;
    }
    get minWidth() {
        return !this._defaultMinWidth ? this.defaultMinWidth : this._defaultMinWidth;
    }
    /**
     * Gets the column index.
     * ```typescript
     * let columnIndex = this.column.index;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get index() {
        return this.grid.columns.indexOf(this);
    }
    /**
     * Gets whether the column is `pinned`.
     * ```typescript
     * let isPinned = this.column.pinned;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get pinned() {
        return this._pinned;
    }
    /**
     * Sets whether the column is pinned.
     * Default value is `false`.
     * ```html
     * <igx-column [pinned] = "true"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(pinned)] = "model.columns[0].isPinned"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set pinned(value) {
        if (this._pinned !== value) {
            if (this.grid && this.width && !isNaN(parseInt(this.width, 10))) {
                if (value) {
                    this.pin();
                }
                else {
                    this.unpin();
                }
                return;
            }
            /* No grid/width available at initialization. `initPinning` in the grid
               will re-init the group (if present)
            */
            this._pinned = value;
            this.pinnedChange.emit(this._pinned);
        }
    }
    /**
     * Gets the column `summaries`.
     * ```typescript
     * let columnSummaries = this.column.summaries;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get summaries() {
        return this._summaries;
    }
    /**
     * Sets the column `summaries`.
     * ```typescript
     * this.column.summaries = IgxNumberSummaryOperand;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set summaries(classRef) {
        if (isConstructor(classRef)) {
            this._summaries = new classRef();
        }
        if (this.grid) {
            this.grid.summaryService.removeSummariesCachePerColumn(this.field);
            this.grid.summaryPipeTrigger++;
            this.grid.summaryService.resetSummaryHeight();
        }
    }
    /**
     * Gets the column `filters`.
     * ```typescript
     * let columnFilters = this.column.filters'
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filters() {
        return this._filters;
    }
    /**
     * Sets the column `filters`.
     * ```typescript
     * this.column.filters = IgxBooleanFilteringOperand.instance().
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set filters(instance) {
        this._filters = instance;
    }
    /**
     * Gets the column `sortStrategy`.
     * ```typescript
     * let sortStrategy = this.column.sortStrategy
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get sortStrategy() {
        return this._sortStrategy;
    }
    /**
     * Sets the column `sortStrategy`.
     * ```typescript
     * this.column.sortStrategy = new CustomSortingStrategy().
     * class CustomSortingStrategy extends SortingStrategy {...}
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set sortStrategy(classRef) {
        this._sortStrategy = classRef;
    }
    /**
     * Gets the function that compares values for grouping.
     * ```typescript
     * let groupingComparer = this.column.groupingComparer'
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get groupingComparer() {
        return this._groupingComparer;
    }
    /**
     * Sets a custom function to compare values for grouping.
     * Subsequent values in the sorted data that the function returns 0 for are grouped.
     * ```typescript
     * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set groupingComparer(funcRef) {
        this._groupingComparer = funcRef;
    }
    /**
     * Gets the default minimum `width` of the column.
     * ```typescript
     * let defaultMinWidth =  this.column.defaultMinWidth;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get defaultMinWidth() {
        if (!this.grid) {
            return '80';
        }
        switch (this.grid.displayDensity) {
            case DisplayDensity.cosy:
                return '64';
            case DisplayDensity.compact:
                return '56';
            default:
                return '80';
        }
    }
    /**
     * The reference to the `igx-grid` owner.
     * ```typescript
     * let gridComponent = this.column.grid;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Returns a reference to the `bodyTemplate`.
     * ```typescript
     * let bodyTemplate = this.column.bodyTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get bodyTemplate() {
        return this._bodyTemplate;
    }
    /**
     * Sets the body template.
     * ```html
     * <ng-template #bodyTemplate igxCell let-val>
     *    <div style = "background-color: yellowgreen" (click) = "changeColor(val)">
     *       <span> {{val}} </span>
     *    </div>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'bodyTemplate'", {read: TemplateRef })
     * public bodyTemplate: TemplateRef<any>;
     * this.column.bodyTemplate = this.bodyTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set bodyTemplate(template) {
        this._bodyTemplate = template;
    }
    /**
     * Returns a reference to the header template.
     * ```typescript
     * let headerTemplate = this.column.headerTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get headerTemplate() {
        return this._headerTemplate;
    }
    /**
     * Sets the header template.
     * Note that the column header height is fixed and any content bigger than it will be cut off.
     * ```html
     * <ng-template #headerTemplate>
     *   <div style = "background-color:black" (click) = "changeColor(val)">
     *       <span style="color:red" >{{column.field}}</span>
     *   </div>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'headerTemplate'", {read: TemplateRef })
     * public headerTemplate: TemplateRef<any>;
     * this.column.headerTemplate = this.headerTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set headerTemplate(template) {
        this._headerTemplate = template;
    }
    /**
     * Returns a reference to the inline editor template.
     * ```typescript
     * let inlineEditorTemplate = this.column.inlineEditorTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get inlineEditorTemplate() {
        return this._inlineEditorTemplate;
    }
    /**
     * Sets the inline editor template.
     * ```html
     * <ng-template #inlineEditorTemplate igxCellEditor let-cell="cell">
     *     <input type="string" [(ngModel)]="cell.value"/>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'inlineEditorTemplate'", {read: TemplateRef })
     * public inlineEditorTemplate: TemplateRef<any>;
     * this.column.inlineEditorTemplate = this.inlineEditorTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set inlineEditorTemplate(template) {
        this._inlineEditorTemplate = template;
    }
    /**
     * Returns a reference to the `filterCellTemplate`.
     * ```typescript
     * let filterCellTemplate = this.column.filterCellTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filterCellTemplate() {
        return this._filterCellTemplate;
    }
    /**
     * Sets the quick filter template.
     * ```html
     * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column="column">
     *    <input (input)="onInput()">
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'filterCellTemplate'", {read: TemplateRef })
     * public filterCellTemplate: TemplateRef<any>;
     * this.column.filterCellTemplate = this.filterCellTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set filterCellTemplate(template) {
        this._filterCellTemplate = template;
    }
    /**
     * Gets the cells of the column.
     * ```typescript
     * let columnCells = this.column._cells;
     * ```
     *
     */
    get cells() {
        // TODO calclulate index for remote data scenarios
        // check indexes in this.dataRowList.first and this.dataRowList.last
        return this.grid.dataView
            .map((rec, index) => {
            if (!this.grid.isGroupByRecord(rec) && !this.grid.isSummaryRow(rec)) {
                const cell = new IgxGridCell(this.grid, index, this.field);
                return cell;
            }
        }).filter(cell => cell);
    }
    /**
     * @hidden @internal
     */
    get _cells() {
        return this.grid.rowList.filter((row) => row instanceof IgxRowDirective)
            .map((row) => {
            if (row._cells) {
                return row._cells.filter((cell) => cell.columnIndex === this.index);
            }
        }).reduce((a, b) => a.concat(b), []);
    }
    /**
     * Gets the column visible index.
     * If the column is not visible, returns `-1`.
     * ```typescript
     * let visibleColumnIndex =  this.column.visibleIndex;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get visibleIndex() {
        if (!isNaN(this._vIndex)) {
            return this._vIndex;
        }
        const unpinnedColumns = this.grid.unpinnedColumns.filter(c => !c.columnGroup);
        const pinnedColumns = this.grid.pinnedColumns.filter(c => !c.columnGroup);
        let col = this;
        let vIndex = -1;
        if (this.columnGroup) {
            col = this.allChildren.filter(c => !c.columnGroup && !c.hidden)[0];
        }
        if (this.columnLayoutChild) {
            return this.parent.childrenVisibleIndexes.find(x => x.column === this).index;
        }
        if (!this.pinned) {
            const indexInCollection = unpinnedColumns.indexOf(col);
            vIndex = indexInCollection === -1 ?
                -1 :
                (this.grid.isPinningToStart ?
                    pinnedColumns.length + indexInCollection :
                    indexInCollection);
        }
        else {
            const indexInCollection = pinnedColumns.indexOf(col);
            vIndex = this.grid.isPinningToStart ?
                indexInCollection :
                unpinnedColumns.length + indexInCollection;
        }
        this._vIndex = vIndex;
        return vIndex;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnGroup`.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get columnGroup() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get columnLayout() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a child of a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnLayoutChild =  this.column.columnLayoutChild;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get columnLayoutChild() {
        return this.parent && this.parent.columnLayout;
    }
    /**
     * Returns the children columns collection.
     * Returns an empty array if the column does not contain children columns.
     * ```typescript
     * let childrenColumns =  this.column.allChildren;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get allChildren() {
        return [];
    }
    /**
     * Returns the level of the column in a column group.
     * Returns `0` if the column doesn't have a `parent`.
     * ```typescript
     * let columnLevel =  this.column.level;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get level() {
        let ptr = this.parent;
        let lvl = 0;
        while (ptr) {
            lvl++;
            ptr = ptr.parent;
        }
        return lvl;
    }
    get isLastPinned() {
        return this.grid.isPinningToStart &&
            this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1] === this;
    }
    get isFirstPinned() {
        const pinnedCols = this.grid.pinnedColumns.filter(x => !x.columnGroup);
        return !this.grid.isPinningToStart && pinnedCols[0] === this;
    }
    get rightPinnedOffset() {
        return this.pinned && !this.grid.isPinningToStart ?
            -this.grid.pinnedWidth - this.grid.headerFeaturesWidth + 'px' :
            null;
    }
    get gridRowSpan() {
        return this.rowEnd && this.rowStart ? this.rowEnd - this.rowStart : 1;
    }
    get gridColumnSpan() {
        return this.colEnd && this.colStart ? this.colEnd - this.colStart : 1;
    }
    /**
     * Indicates whether the column will be visible when its parent is collapsed.
     * ```html
     * <igx-column-group>
     *   <igx-column [visibleWhenCollapsed]="true"></igx-column>
     * </igx-column-group>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set visibleWhenCollapsed(value) {
        this._visibleWhenCollapsed = value;
        this.visibleWhenCollapsedChange.emit(this._visibleWhenCollapsed);
        if (this.parent) {
            this.parent.setExpandCollapseState();
        }
    }
    get visibleWhenCollapsed() {
        return this._visibleWhenCollapsed;
    }
    /**
     * @remarks
     * Pass optional parameters for DatePipe and/or DecimalPipe to format the display value for date and numeric columns.
     * Accepts an `IColumnPipeArgs` object with any of the `format`, `timezone` and `digitsInfo` properties.
     * For more details see https://angular.io/api/common/DatePipe and https://angular.io/api/common/DecimalPipe
     * @example
     * ```typescript
     * const pipeArgs: IColumnPipeArgs = {
     *      format: 'longDate',
     *      timezone: 'UTC',
     *      digitsInfo: '1.1-2'
     * }
     * ```
     * ```html
     * <igx-column dataType="date" [pipeArgs]="pipeArgs"></igx-column>
     * <igx-column dataType="number" [pipeArgs]="pipeArgs"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set pipeArgs(value) {
        this._columnPipeArgs = Object.assign(this._columnPipeArgs, value);
        this.grid.summaryService.clearSummaryCache();
        this.grid.pipeTrigger++;
    }
    get pipeArgs() {
        return this._columnPipeArgs;
    }
    /**
     * @hidden
     * @internal
     */
    get collapsible() {
        return false;
    }
    set collapsible(_value) { }
    /**
     * @hidden
     * @internal
     */
    get expanded() {
        return true;
    }
    set expanded(_value) { }
    /**
     * Returns the filteringExpressionsTree of the column.
     * ```typescript
     * let tree =  this.column.filteringExpressionsTree;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filteringExpressionsTree() {
        return this.grid.filteringExpressionsTree.find(this.field);
    }
    /**
     * @hidden
     */
    get isPrimaryColumn() {
        return this.field !== undefined && this.grid !== undefined && this.field === this.grid.primaryKey;
    }
    /**
     * @hidden
     * @internal
     */
    resetCaches() {
        this._vIndex = NaN;
        if (this.grid) {
            this.cacheCalcWidth();
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.cellTemplate) {
            this._bodyTemplate = this.cellTemplate.template;
        }
        if (this.headTemplate && this.headTemplate.length) {
            this._headerTemplate = this.headTemplate.toArray()[0].template;
        }
        if (this.editorTemplate) {
            this._inlineEditorTemplate = this.editorTemplate.template;
        }
        if (this.filterCellTemplateDirective) {
            this._filterCellTemplate = this.filterCellTemplateDirective.template;
        }
        if (!this._columnPipeArgs.format) {
            this._columnPipeArgs.format = this.dataType === GridColumnDataType.Time ?
                DEFAULT_TIME_FORMAT : this.dataType === GridColumnDataType.DateTime ?
                DEFAULT_DATE_TIME_FORMAT : DEFAULT_DATE_FORMAT;
        }
        if (!this.summaries) {
            switch (this.dataType) {
                case GridColumnDataType.String:
                case GridColumnDataType.Boolean:
                    this.summaries = IgxSummaryOperand;
                    break;
                case GridColumnDataType.Number:
                case GridColumnDataType.Currency:
                case GridColumnDataType.Percent:
                    this.summaries = IgxNumberSummaryOperand;
                    break;
                case GridColumnDataType.Date:
                case GridColumnDataType.DateTime:
                    this.summaries = IgxDateSummaryOperand;
                    break;
                case GridColumnDataType.Time:
                    this.summaries = IgxTimeSummaryOperand;
                    break;
                default:
                    this.summaries = IgxSummaryOperand;
                    break;
            }
        }
        if (!this.filters) {
            switch (this.dataType) {
                case GridColumnDataType.Boolean:
                    this.filters = IgxBooleanFilteringOperand.instance();
                    break;
                case GridColumnDataType.Number:
                case GridColumnDataType.Currency:
                case GridColumnDataType.Percent:
                    this.filters = IgxNumberFilteringOperand.instance();
                    break;
                case GridColumnDataType.Date:
                    this.filters = IgxDateFilteringOperand.instance();
                    break;
                case GridColumnDataType.Time:
                    this.filters = IgxTimeFilteringOperand.instance();
                    break;
                case GridColumnDataType.DateTime:
                    this.filters = IgxDateTimeFilteringOperand.instance();
                    break;
                case GridColumnDataType.String:
                default:
                    this.filters = IgxStringFilteringOperand.instance();
                    break;
            }
        }
    }
    /**
     * @hidden
     */
    getGridTemplate(isRow, isIE) {
        if (isRow) {
            const rowsCount = this.grid.multiRowLayoutRowSize;
            return isIE ?
                `(1fr)[${rowsCount}]` :
                `repeat(${rowsCount},1fr)`;
        }
        else {
            return this.getColumnSizesString(this.children);
        }
    }
    getInitialChildColumnSizes(children) {
        const columnSizes = [];
        // find the smallest col spans
        children.forEach(col => {
            if (!col.colStart) {
                return;
            }
            const newWidthSet = col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            const newSpanSmaller = columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].colSpan > col.gridColumnSpan;
            const bothWidthsSet = col.widthSetByUser && columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].widthSetByUser;
            const bothWidthsNotSet = !col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            if (columnSizes[col.colStart - 1] === undefined) {
                // If nothing is defined yet take any column at first
                // We use colEnd to know where the column actually ends, because not always it starts where we have it set in columnSizes.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (newWidthSet || (newSpanSmaller && ((bothWidthsSet) || (bothWidthsNotSet)))) {
                // If a column is set already it should either not have width defined or have width with bigger span than the new one.
                /**
                 *  If replaced column has bigger span, we want to fill the remaining columns
                 *  that the replacing column does not fill with the old one.
                 */
                if (bothWidthsSet && newSpanSmaller) {
                    // Start from where the new column set would end and apply the old column to the rest depending on how much it spans.
                    // We have not yet replaced it so we can use it directly from the columnSizes collection.
                    // This is where colEnd is used because the colStart of the old column is not actually i + 1.
                    for (let i = col.colStart - 1 + col.gridColumnSpan; i < columnSizes[col.colStart - 1].colEnd - 1; i++) {
                        if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                            columnSizes[i] = columnSizes[col.colStart - 1];
                        }
                        else {
                            break;
                        }
                    }
                }
                // Replace the old column with the new one.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (bothWidthsSet && columnSizes[col.colStart - 1].colSpan < col.gridColumnSpan) {
                // If the column already in the columnSizes has smaller span, we still need to fill any empty places with the current col.
                // Start from where the smaller column set would end and apply the bigger column to the rest depending on how much it spans.
                // Since here we do not have it in columnSizes we set it as a new column keeping the same colSpan.
                for (let i = col.colStart - 1 + columnSizes[col.colStart - 1].colSpan; i < col.colStart - 1 + col.gridColumnSpan; i++) {
                    if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                        columnSizes[i] = {
                            ref: col,
                            width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                            colSpan: col.gridColumnSpan,
                            colEnd: col.colStart + col.gridColumnSpan,
                            widthSetByUser: col.widthSetByUser
                        };
                    }
                    else {
                        break;
                    }
                }
            }
        });
        // Flatten columnSizes so there are not columns with colSpan > 1
        for (let i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && columnSizes[i].colSpan > 1) {
                let j = 1;
                // Replace all empty places depending on how much the current column spans starting from next col.
                for (; j < columnSizes[i].colSpan && i + j + 1 < columnSizes[i].colEnd; j++) {
                    if (columnSizes[i + j] &&
                        ((!columnSizes[i].width && columnSizes[i + j].width) ||
                            (!columnSizes[i].width && !columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan) ||
                            (!!columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan))) {
                        // If we reach an already defined column that has width and the current doesn't have or
                        // if the reached column has bigger colSpan we stop.
                        break;
                    }
                    else {
                        const width = columnSizes[i].widthSetByUser ?
                            columnSizes[i].width / columnSizes[i].colSpan :
                            columnSizes[i].width;
                        columnSizes[i + j] = {
                            ref: columnSizes[i].ref,
                            width,
                            colSpan: 1,
                            colEnd: columnSizes[i].colEnd,
                            widthSetByUser: columnSizes[i].widthSetByUser
                        };
                    }
                }
                // Update the current column width so it is divided between all columns it spans and set it to 1.
                columnSizes[i].width = columnSizes[i].widthSetByUser ?
                    columnSizes[i].width / columnSizes[i].colSpan :
                    columnSizes[i].width;
                columnSizes[i].colSpan = 1;
                // Update the index based on how much we have replaced. Subtract 1 because we started from 1.
                i += j - 1;
            }
        }
        return columnSizes;
    }
    getFilledChildColumnSizes(children) {
        const columnSizes = this.getInitialChildColumnSizes(children);
        // fill the gaps if there are any
        const result = [];
        for (const size of columnSizes) {
            if (size && !!size.width) {
                result.push(size.width + 'px');
            }
            else {
                result.push(parseInt(this.grid.getPossibleColumnWidth(), 10) + 'px');
            }
        }
        return result;
    }
    getResizableColUnderEnd() {
        if (this.columnLayout || !this.columnLayoutChild || this.columnGroup) {
            return [{ target: this, spanUsed: 1 }];
        }
        const columnSized = this.getInitialChildColumnSizes(this.parent.children);
        const targets = [];
        const colEnd = this.colEnd ? this.colEnd : this.colStart + 1;
        for (let i = 0; i < columnSized.length; i++) {
            if (this.colStart <= i + 1 && i + 1 < colEnd) {
                targets.push({ target: columnSized[i].ref, spanUsed: 1 });
            }
        }
        const targetsSquashed = [];
        for (const target of targets) {
            if (targetsSquashed.length && targetsSquashed[targetsSquashed.length - 1].target.field === target.target.field) {
                targetsSquashed[targetsSquashed.length - 1].spanUsed++;
            }
            else {
                targetsSquashed.push(target);
            }
        }
        return targetsSquashed;
    }
    /**
     * Pins the column at the provided index in the pinned area.
     * Defaults to index `0` if not provided, or to the initial index in the pinned area.
     * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
     * Column cannot be pinned if:
     * - Is already pinned
     * - index argument is out of range
     * - The pinned area exceeds 80% of the grid width
     * ```typescript
     * let success = this.column.pin();
     * ```
     *
     * @memberof IgxColumnComponent
     */
    pin(index) {
        // TODO: Probably should the return type of the old functions
        // should be moved as a event parameter.
        const grid = this.grid;
        if (this._pinned) {
            return false;
        }
        if (this.parent && !this.parent.pinned) {
            return this.topLevelParent.pin(index);
        }
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index > grid.pinnedColumns.length)) {
            return false;
        }
        if (!this.parent && !this.pinnable) {
            return false;
        }
        const rootPinnedCols = grid._pinnedColumns.filter((c) => c.level === 0);
        index = hasIndex ? index : rootPinnedCols.length;
        const args = { column: this, insertAtIndex: index, isPinned: false, cancel: false };
        this.grid.columnPin.emit(args);
        if (args.cancel) {
            return;
        }
        this.grid.crudService.endEdit(false);
        this._pinned = true;
        this.pinnedChange.emit(this._pinned);
        // it is possible that index is the last position, so will need to find target column by [index-1]
        const targetColumn = args.insertAtIndex === grid._pinnedColumns.length ?
            grid._pinnedColumns[args.insertAtIndex - 1] : grid._pinnedColumns[args.insertAtIndex];
        if (grid._pinnedColumns.indexOf(this) === -1) {
            if (!grid.hasColumnGroups) {
                grid._pinnedColumns.splice(args.insertAtIndex, 0, this);
            }
            else {
                // insert based only on root collection
                rootPinnedCols.splice(args.insertAtIndex, 0, this);
                let allPinned = [];
                // re-create hierarchy
                rootPinnedCols.forEach(group => {
                    allPinned.push(group);
                    allPinned = allPinned.concat(group.allChildren);
                });
                grid._pinnedColumns = allPinned;
            }
            if (grid._unpinnedColumns.indexOf(this) !== -1) {
                const childrenCount = this.allChildren.length;
                grid._unpinnedColumns.splice(grid._unpinnedColumns.indexOf(this), 1 + childrenCount);
            }
        }
        if (hasIndex) {
            grid._moveColumns(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.pin());
            grid.reinitPinStates();
        }
        grid.resetCaches();
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        const eventArgs = { column: this, insertAtIndex: index, isPinned: true };
        this.grid.columnPinned.emit(eventArgs);
        return true;
    }
    /**
     * Unpins the column and place it at the provided index in the unpinned area.
     * Defaults to index `0` if not provided, or to the initial index in the unpinned area.
     * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
     * Column cannot be unpinned if:
     * - Is already unpinned
     * - index argument is out of range
     * ```typescript
     * let success = this.column.unpin();
     * ```
     *
     * @memberof IgxColumnComponent
     */
    unpin(index) {
        const grid = this.grid;
        if (!this._pinned) {
            return false;
        }
        if (this.parent && this.parent.pinned) {
            return this.topLevelParent.unpin(index);
        }
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index > grid._unpinnedColumns.length)) {
            return false;
        }
        // estimate the exact index at which column will be inserted
        // takes into account initial unpinned index of the column
        if (!hasIndex) {
            const indices = grid.unpinnedColumns.map(col => col.index);
            indices.push(this.index);
            indices.sort((a, b) => a - b);
            index = indices.indexOf(this.index);
        }
        const args = { column: this, insertAtIndex: index, isPinned: true, cancel: false };
        this.grid.columnPin.emit(args);
        if (args.cancel) {
            return;
        }
        this.grid.crudService.endEdit(false);
        this._pinned = false;
        this.pinnedChange.emit(this._pinned);
        // it is possible that index is the last position, so will need to find target column by [index-1]
        const targetColumn = args.insertAtIndex === grid._unpinnedColumns.length ?
            grid._unpinnedColumns[args.insertAtIndex - 1] : grid._unpinnedColumns[args.insertAtIndex];
        if (!hasIndex) {
            grid._unpinnedColumns.splice(index, 0, this);
            if (grid._pinnedColumns.indexOf(this) !== -1) {
                grid._pinnedColumns.splice(grid._pinnedColumns.indexOf(this), 1);
            }
        }
        if (hasIndex) {
            grid.moveColumn(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.unpin());
        }
        grid.reinitPinStates();
        grid.resetCaches();
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        this.grid.columnPinned.emit({ column: this, insertAtIndex: index, isPinned: false });
        return true;
    }
    /**
     * Moves a column to the specified visible index.
     * If passed index is invalid, or if column would receive a different visible index after moving, moving is not performed.
     * If passed index would move the column to a different column group. moving is not performed.
     *
     * @example
     * ```typescript
     * column.move(index);
     * ```
     * @memberof IgxColumnComponent
     */
    move(index) {
        let target;
        const grid = this.grid;
        let columns = grid.columnList.filter(c => c.visibleIndex > -1);
        // grid last visible index
        const li = columns.map(c => c.visibleIndex).reduce((a, b) => Math.max(a, b));
        const parent = this.parent;
        const isPreceding = this.visibleIndex < index;
        if (index === this.visibleIndex || index < 0 || index > li) {
            return;
        }
        if (parent) {
            columns = columns.filter(c => c.level >= this.level && c !== this && c.parent !== this &&
                c.topLevelParent === this.topLevelParent);
        }
        /* eslint-disable max-len */
        // If isPreceding, find a target such that when the current column is placed after it, current colummn will receive a visibleIndex === index. This takes into account visible children of the columns.
        // If !isPreceding, finds a column of the same level and visible index that equals the passed index agument (c.visibleIndex === index). No need to consider the children here.
        /* eslint-enable max-len */
        if (isPreceding) {
            columns = columns.filter(c => c.visibleIndex > this.visibleIndex);
            target = columns.find(c => c.level === this.level && c.visibleIndex + c.calcChildren() - this.calcChildren() === index);
        }
        else {
            columns = columns.filter(c => c.visibleIndex < this.visibleIndex);
            target = columns.find(c => c.level === this.level && c.visibleIndex === index);
        }
        if (!target || (target.pinned && this.disablePinning)) {
            return;
        }
        const pos = isPreceding ? DropPosition.AfterDropTarget : DropPosition.BeforeDropTarget;
        grid.moveColumn(this, target, pos);
    }
    /**
     * No children for the column, so will returns 1 or 0, if the column is hidden.
     *
     * @hidden
     */
    calcChildren() {
        const children = this.hidden ? 0 : 1;
        return children;
    }
    /**
     * Toggles column vibisility and emits the respective event.
     *
     * @hidden
     */
    toggleVisibility(value) {
        const newValue = value !== null && value !== void 0 ? value : !this.hidden;
        const eventArgs = { column: this, newValue, cancel: false };
        this.grid.columnVisibilityChanging.emit(eventArgs);
        if (eventArgs.cancel) {
            return;
        }
        this.hidden = newValue;
        this.grid.columnVisibilityChanged.emit({ column: this, newValue });
    }
    /**
     * Returns a reference to the top level parent column.
     * ```typescript
     * let topLevelParent =  this.column.topLevelParent;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get topLevelParent() {
        let parent = this.parent;
        while (parent && parent.parent) {
            parent = parent.parent;
        }
        return parent;
    }
    /**
     * Returns a reference to the header of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let headerCell = column.headerCell;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get headerCell() {
        return this.grid.headerCellList.find((header) => header.column === this);
    }
    /**
     * Returns a reference to the filter cell of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let filterell = column.filterell;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filterCell() {
        return this.grid.filterCellList.find((filterCell) => filterCell.column === this);
    }
    /**
     * Returns a reference to the header group of the column.
     *
     * @memberof IgxColumnComponent
     */
    get headerGroup() {
        return this.grid.headerGroupsList.find(group => group.column === this);
    }
    /**
     * Autosize the column to the longest currently visible cell value, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * column.autosize();
     * ```
     *
     * @memberof IgxColumnComponent
     * @param byHeaderOnly Set if column should be autosized based only on the header content.
     */
    autosize(byHeaderOnly = false) {
        if (!this.columnGroup) {
            this.width = this.getAutoSize(byHeaderOnly);
            this.grid.reflow();
        }
    }
    /**
     * @hidden
     */
    getAutoSize(byHeader = false) {
        const size = !byHeader ? this.getLargestCellWidth() :
            (Object.values(this.getHeaderCellWidths()).reduce((a, b) => a + b) + 'px');
        const isPercentageWidth = this.width && typeof this.width === 'string' && this.width.indexOf('%') !== -1;
        let newWidth;
        if (isPercentageWidth) {
            const gridAvailableSize = this.grid.calcWidth;
            const percentageSize = parseFloat(size) / gridAvailableSize * 100;
            newWidth = percentageSize + '%';
        }
        else {
            newWidth = size;
        }
        const maxWidth = isPercentageWidth ? this.maxWidthPercent : this.maxWidthPx;
        const minWidth = isPercentageWidth ? this.minWidthPercent : this.minWidthPx;
        if (this.maxWidth && (parseFloat(newWidth) > maxWidth)) {
            newWidth = isPercentageWidth ? maxWidth + '%' : maxWidth + 'px';
        }
        else if (parseFloat(newWidth) < minWidth) {
            newWidth = isPercentageWidth ? minWidth + '%' : minWidth + 'px';
        }
        return newWidth;
    }
    /**
     * @hidden
     */
    getCalcWidth() {
        if (this._calcWidth && !isNaN(this.calcPixelWidth)) {
            return this._calcWidth;
        }
        this.cacheCalcWidth();
        return this._calcWidth;
    }
    /**
     * @hidden
     * Returns the width and padding of a header cell.
     */
    getHeaderCellWidths() {
        const range = this.grid.document.createRange();
        // We do not cover cases where there are children with width 100% and etc,
        // because then we try to get new column size, based on header content, which is sized based on column size...
        const headerWidth = this.platform.getNodeSizeViaRange(range, this.headerCell.nativeElement, this.headerGroup.nativeElement);
        const headerStyle = this.grid.document.defaultView.getComputedStyle(this.headerCell.nativeElement);
        const headerPadding = parseFloat(headerStyle.paddingLeft) + parseFloat(headerStyle.paddingRight) +
            parseFloat(headerStyle.borderRightWidth);
        // Take into consideration the header group element, since column pinning applies borders to it if its not a columnGroup.
        const headerGroupStyle = this.grid.document.defaultView.getComputedStyle(this.headerGroup.nativeElement);
        const borderSize = !this.parent ? parseFloat(headerGroupStyle.borderRightWidth) + parseFloat(headerGroupStyle.borderLeftWidth) : 0;
        return { width: Math.ceil(headerWidth), padding: Math.ceil(headerPadding + borderSize) };
    }
    /**
     * @hidden
     * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let size = column.getLargestCellWidth();
     * ```
     * @memberof IgxColumnComponent
     */
    getLargestCellWidth() {
        const range = this.grid.document.createRange();
        const largest = new Map();
        if (this._cells.length > 0) {
            const cellsContentWidths = [];
            this._cells.forEach((cell) => cellsContentWidths.push(cell.calculateSizeToFit(range)));
            const index = cellsContentWidths.indexOf(Math.max(...cellsContentWidths));
            const cellStyle = this.grid.document.defaultView.getComputedStyle(this._cells[index].nativeElement);
            const cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight) +
                parseFloat(cellStyle.borderLeftWidth) + parseFloat(cellStyle.borderRightWidth);
            largest.set(Math.max(...cellsContentWidths), cellPadding);
        }
        if (this.headerCell && this.autosizeHeader) {
            const headerCellWidths = this.getHeaderCellWidths();
            largest.set(headerCellWidths.width, headerCellWidths.padding);
        }
        const largestCell = Math.max(...Array.from(largest.keys()));
        const width = Math.ceil(largestCell + largest.get(largestCell));
        if (Number.isNaN(width)) {
            return this.width;
        }
        else {
            return width + 'px';
        }
    }
    /**
     * @hidden
     */
    getCellWidth() {
        const colWidth = this.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (this.columnLayoutChild) {
            return '';
        }
        if (colWidth && !isPercentageWidth) {
            let cellWidth = colWidth;
            if (typeof cellWidth !== 'string' || cellWidth.endsWith('px') === false) {
                cellWidth += 'px';
            }
            return cellWidth;
        }
        else {
            return colWidth;
        }
    }
    /**
     * @hidden
     */
    populateVisibleIndexes() { }
    getColumnSizesString(children) {
        const res = this.getFilledChildColumnSizes(children);
        return res.join(' ');
    }
    /**
     * @hidden
     * @internal
     */
    cacheCalcWidth() {
        const grid = this.gridAPI.grid;
        const colWidth = this.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (isPercentageWidth) {
            this._calcWidth = parseFloat(colWidth) / 100 * grid.calcWidth;
        }
        else if (!colWidth) {
            // no width
            this._calcWidth = this.defaultWidth || grid.getPossibleColumnWidth();
        }
        else {
            this._calcWidth = this.width;
        }
        this.calcPixelWidth = parseFloat(this._calcWidth);
    }
    /**
     * @hidden
     * @internal
     */
    setExpandCollapseState() {
        this.children.filter(col => (col.visibleWhenCollapsed !== undefined)).forEach(c => {
            if (!this.collapsible) {
                c.hidden = this.hidden;
                return;
            }
            c.hidden = this._expanded ? c.visibleWhenCollapsed : !c.visibleWhenCollapsed;
        });
    }
    /**
     * @hidden
     * @internal
     */
    checkCollapsibleState() {
        if (!this.children) {
            return false;
        }
        const cols = this.children.map(child => child.visibleWhenCollapsed);
        return (cols.some(c => c === true) && cols.some(c => c === false));
    }
    /**
     * @hidden
     */
    get pinnable() {
        return this.grid._init || !this.pinned;
    }
    /**
     * @hidden
     */
    get applySelectableClass() {
        return this._applySelectableClass;
    }
    /**
     * @hidden
     */
    set applySelectableClass(value) {
        if (this.selectable) {
            this._applySelectableClass = value;
        }
    }
}
IgxColumnComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-column',
                template: ``
            },] }
];
IgxColumnComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef },
    { type: PlatformUtil }
];
IgxColumnComponent.propDecorators = {
    field: [{ type: Input }],
    header: [{ type: Input }],
    title: [{ type: Input }],
    sortable: [{ type: Input }],
    selectable: [{ type: Input }],
    groupable: [{ type: Input }],
    editable: [{ type: Input }],
    filterable: [{ type: Input }],
    resizable: [{ type: Input }],
    autosizeHeader: [{ type: Input }],
    hasSummary: [{ type: Input }],
    hidden: [{ type: Input }],
    hiddenChange: [{ type: Output }],
    expandedChange: [{ type: Output }],
    collapsibleChange: [{ type: Output }],
    visibleWhenCollapsedChange: [{ type: Output }],
    columnChange: [{ type: Output }],
    disableHiding: [{ type: Input }],
    disablePinning: [{ type: Input }],
    movable: [{ type: Input }],
    width: [{ type: Input }],
    maxWidth: [{ type: Input }],
    headerClasses: [{ type: Input }],
    headerStyles: [{ type: Input }],
    headerGroupClasses: [{ type: Input }],
    headerGroupStyles: [{ type: Input }],
    cellClasses: [{ type: Input }],
    cellStyles: [{ type: Input }],
    formatter: [{ type: Input }],
    summaryFormatter: [{ type: Input }],
    filteringIgnoreCase: [{ type: Input }],
    sortingIgnoreCase: [{ type: Input }],
    searchable: [{ type: Input }],
    dataType: [{ type: Input }],
    collapsibleIndicatorTemplate: [{ type: Input }],
    rowEnd: [{ type: Input }],
    colEnd: [{ type: Input }],
    rowStart: [{ type: Input }],
    colStart: [{ type: Input }],
    additionalTemplateContext: [{ type: Input }],
    widthChange: [{ type: Output }],
    pinnedChange: [{ type: Output }],
    filterCellTemplateDirective: [{ type: ContentChild, args: [IgxFilterCellTemplateDirective, { read: IgxFilterCellTemplateDirective },] }],
    cellTemplate: [{ type: ContentChild, args: [IgxCellTemplateDirective, { read: IgxCellTemplateDirective },] }],
    headTemplate: [{ type: ContentChildren, args: [IgxCellHeaderTemplateDirective, { read: IgxCellHeaderTemplateDirective, descendants: false },] }],
    editorTemplate: [{ type: ContentChild, args: [IgxCellEditorTemplateDirective, { read: IgxCellEditorTemplateDirective },] }],
    collapseIndicatorTemplate: [{ type: ContentChild, args: [IgxCollapsibleIndicatorTemplateDirective, { read: IgxCollapsibleIndicatorTemplateDirective, static: false },] }],
    minWidth: [{ type: Input }],
    pinned: [{ type: Input }],
    summaries: [{ type: Input }],
    filters: [{ type: Input }],
    sortStrategy: [{ type: Input }],
    groupingComparer: [{ type: Input }],
    bodyTemplate: [{ type: Input, args: ['cellTemplate',] }],
    headerTemplate: [{ type: Input }],
    inlineEditorTemplate: [{ type: Input, args: ['cellEditorTemplate',] }],
    filterCellTemplate: [{ type: Input, args: ['filterCellTemplate',] }],
    visibleWhenCollapsed: [{ type: Input }],
    pipeArgs: [{ type: Input }]
};
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "header", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "title", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "sortable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "selectable", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "groupable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "editable", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filterable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "resizable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "autosizeHeader", void 0);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "hasSummary", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "hidden", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "disableHiding", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "disablePinning", void 0);
__decorate([
    WatchColumnChanges(),
    notifyChanges()
], IgxColumnComponent.prototype, "movable", void 0);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "width", null);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "maxWidth", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerStyles", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerGroupClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerGroupStyles", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "cellClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "cellStyles", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "formatter", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "summaryFormatter", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filteringIgnoreCase", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "sortingIgnoreCase", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "searchable", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "minWidth", null);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "pinned", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "summaries", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "bodyTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "inlineEditorTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filterCellTemplate", null);
__decorate([
    notifyChanges(true)
], IgxColumnComponent.prototype, "visibleWhenCollapsed", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "pipeArgs", null);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sdW1uLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9jb2x1bW5zL2NvbHVtbi5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUVILGlCQUFpQixFQUNqQix1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFlBQVksRUFDWixlQUFlLEVBQ2YsS0FBSyxFQUdMLE1BQU0sRUFDTixZQUFZLEdBRWYsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQ3JFLE9BQU8sRUFFSCwwQkFBMEIsRUFDMUIseUJBQXlCLEVBQ3pCLHVCQUF1QixFQUN2Qix5QkFBeUIsRUFDekIsMkJBQTJCLEVBQzNCLHVCQUF1QixFQUMxQixNQUFNLDJDQUEyQyxDQUFDO0FBQ25ELE9BQU8sRUFBb0Isc0JBQXNCLEVBQUUsTUFBTSx3Q0FBd0MsQ0FBQztBQUNsRyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFHM0QsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRW5ELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBS3BELE9BQU8sRUFDSCxpQkFBaUIsRUFBRSx1QkFBdUIsRUFBRSxxQkFBcUIsRUFDL0MscUJBQXFCLEVBQzFDLE1BQU0sMkJBQTJCLENBQUM7QUFDbkMsT0FBTyxFQUNILHdCQUF3QixFQUN4Qiw4QkFBOEIsRUFDOUIsOEJBQThCLEVBQzlCLHdD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YUFBYSxFQUFFO0lBQ2Ysa0JBQWtCLEVBQUU7c0RBSXBCO0FBZ0NEO0lBSEMsYUFBYSxFQUFFO0lBQ2Ysa0JBQWtCLEVBQUU7d0RBSXBCO0FBaUNEO0lBSEMsYUFBYSxFQUFFO0lBQ2Ysa0JBQWtCLEVBQUU7OERBSXBCO0FBOEJEO0lBSEMsYUFBYSxFQUFFO0lBQ2Ysa0JBQWtCLEVBQUU7NERBSXBCO0FBbU1EO0lBRkMsYUFBYSxDQUFDLElBQUksQ0FBQzs4REFRbkI7QUE0QkQ7SUFIQyxhQUFhLEVBQUU7SUFDZixrQkFBa0IsRUFBRTtrREFNcEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBDb250ZW50Q2hpbGRyZW4sXG4gICAgSW5wdXQsXG4gICAgUXVlcnlMaXN0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIE91dHB1dCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgT25EZXN0cm95LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IG5vdGlmeUNoYW5nZXMgfSBmcm9tICcuLi93YXRjaC1jaGFuZ2VzJztcbmltcG9ydCB7IFdhdGNoQ29sdW1uQ2hhbmdlcyB9IGZyb20gJy4uL3dhdGNoLWNoYW5nZXMnO1xuaW1wb3J0IHsgR3JpZENvbHVtbkRhdGFUeXBlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2RhdGEtdXRpbCc7XG5pbXBvcnQge1xuICAgIElneEZpbHRlcmluZ09wZXJhbmQsXG4gICAgSWd4Qm9vbGVhbkZpbHRlcmluZ09wZXJhbmQsXG4gICAgSWd4TnVtYmVyRmlsdGVyaW5nT3BlcmFuZCxcbiAgICBJZ3hEYXRlRmlsdGVyaW5nT3BlcmFuZCxcbiAgICBJZ3hTdHJpbmdGaWx0ZXJpbmdPcGVyYW5kLFxuICAgIElneERhdGVUaW1lRmlsdGVyaW5nT3BlcmFuZCxcbiAgICBJZ3hUaW1lRmlsdGVyaW5nT3BlcmFuZFxufSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZmlsdGVyaW5nLWNvbmRpdGlvbic7XG5pbXBvcnQgeyBJU29ydGluZ1N0cmF0ZWd5LCBEZWZhdWx0U29ydGluZ1N0cmF0ZWd5IH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL3NvcnRpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgRGlzcGxheURlbnNpdHkgfSBmcm9tICcuLi8uLi9jb3JlL2Rpc3BsYXlEZW5zaXR5JztcbmltcG9ydCB7IElneEdyaWRCYXNlRGlyZWN0aXZlIH0gZnJvbSAnLi4vZ3JpZC1iYXNlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hHcmlkQ2VsbENvbXBvbmVudCB9IGZyb20gJy4uL2NlbGwuY29tcG9uZW50JztcbmltcG9ydCB7IElneFJvd0RpcmVjdGl2ZSB9IGZyb20gJy4uL3Jvdy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2ZpbHRlcmluZy1leHByZXNzaW9ucy10cmVlJztcbmltcG9ydCB7IEdyaWRCYXNlQVBJU2VydmljZSB9IGZyb20gJy4uL2FwaS5zZXJ2aWNlJztcbmltcG9ydCB7IEdyaWRUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElneEdyaWRIZWFkZXJDb21wb25lbnQgfSBmcm9tICcuLi9oZWFkZXJzL2dyaWQtaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hHcmlkRmlsdGVyaW5nQ2VsbENvbXBvbmVudCB9IGZyb20gJy4uL2ZpbHRlcmluZy9iYXNlL2dyaWQtZmlsdGVyaW5nLWNlbGwuY29tcG9uZW50JztcbmltcG9ydCB7IElneEdyaWRIZWFkZXJHcm91cENvbXBvbmVudCB9IGZyb20gJy4uL2hlYWRlcnMvZ3JpZC1oZWFkZXItZ3JvdXAuY29tcG9uZW50JztcbmltcG9ydCB7XG4gICAgSWd4U3VtbWFyeU9wZXJhbmQsIElneE51bWJlclN1bW1hcnlPcGVyYW5kLCBJZ3hEYXRlU3VtbWFyeU9wZXJhbmQsXG4gICAgSWd4U3VtbWFyeVJlc3VsdCwgSWd4VGltZVN1bW1hcnlPcGVyYW5kXG59IGZyb20gJy4uL3N1bW1hcmllcy9ncmlkLXN1bW1hcnknO1xuaW1wb3J0IHtcbiAgICBJZ3hDZWxsVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgSWd4Q2VsbEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIElneENlbGxFZGl0b3JUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBJZ3hDb2xsYXBzaWJsZUluZGljYXRvclRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIElneEZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZVxufSBmcm9tICcuL3RlbXBsYXRlcy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTVJMUmVzaXplQ29sdW1uSW5mbywgTVJMQ29sdW1uU2l6ZUluZm8sIElDb2x1bW5QaXBlQXJncyB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBEcm9wUG9zaXRpb24gfSBmcm9tICcuLi9tb3ZpbmcvbW92aW5nLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4Q29sdW1uR3JvdXBDb21wb25lbnQgfSBmcm9tICcuL2NvbHVtbi1ncm91cC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSUNvbHVtblZpc2liaWxpdHlDaGFuZ2luZ0V2ZW50QXJncywgSVBpbkNvbHVtbkNhbmNlbGxhYmxlRXZlbnRBcmdzLCBJUGluQ29sdW1uRXZlbnRBcmdzIH0gZnJvbSAnLi4vY29tbW9uL2V2ZW50cyc7XG5pbXBvcnQgeyBpc0NvbnN0cnVjdG9yLCBQbGF0Zm9ybVV0aWwgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IENlbGxUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2NlbGwuaW50ZXJmYWNlJztcbmltcG9ydCB7IElneEdyaWRDZWxsIH0gZnJvbSAnLi4vZ3JpZC1wdWJsaWMtY2VsbCc7XG5cbmNvbnN0IERFRkFVTFRfREFURV9GT1JNQVQgPSAnbWVkaXVtRGF0ZSc7XG5jb25zdCBERUZBVUxUX1RJTUVfRk9STUFUID0gJ21lZGl1bVRpbWUnO1xuY29uc3QgREVGQVVMVF9EQVRFX1RJTUVfRk9STUFUID0gJ21lZGl1bSc7XG5jb25zdCBERUZBVUxUX0RJR0lUU19JTkZPID0gJzEuMC0zJztcblxuLyoqXG4gKiAqKklnbml0ZSBVSSBmb3IgQW5ndWxhciBDb2x1bW4qKiAtXG4gKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cuaW5mcmFnaXN0aWNzLmNvbS9wcm9kdWN0cy9pZ25pdGUtdWktYW5ndWxhci9hbmd1bGFyL2NvbXBvbmVudHMvZ3JpZC9ncmlkI2NvbHVtbnMtY29uZmlndXJhdGlvbilcbiAqXG4gKiBUaGUgSWduaXRlIFVJIENvbHVtbiBpcyB1c2VkIHdpdGhpbiBhbiBgaWd4LWdyaWRgIGVsZW1lbnQgdG8gZGVmaW5lIHdoYXQgZGF0YSB0aGUgY29sdW1uIHdpbGwgc2hvdy4gRmVhdHVyZXMgc3VjaCBhcyBzb3J0aW5nLFxuICogZmlsdGVyaW5nICYgZWRpdGluZyBhcmUgZW5hYmxlZCBhdCB0aGUgY29sdW1uIGxldmVsLiAgWW91IGNhbiBhbHNvIHByb3ZpZGUgYSB0ZW1wbGF0ZSBjb250YWluaW5nIGN1c3RvbSBjb250ZW50IGluc2lkZVxuICogdGhlIGNvbHVtbiB1c2luZyBgbmctdGVtcGxhdGVgIHdoaWNoIHdpbGwgYmUgdXNlZCBmb3IgYWxsIGNlbGxzIHdpdGhpbiB0aGUgY29sdW1uLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBzZWxlY3RvcjogJ2lneC1jb2x1bW4nLFxuICAgIHRlbXBsYXRlOiBgYFxufSlcbmV4cG9ydCBjbGFzcyBJZ3hDb2x1bW5Db21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgYGZpZWxkYCB2YWx1ZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkZpZWxkID0gdGhpcy5jb2x1bW4uZmllbGQ7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtmaWVsZF0gPSBcIidJRCdcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IGZpZWxkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fZmllbGQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNOZXN0ZWRQYXRoID0gdmFsdWU/LmluY2x1ZGVzKCcuJyk7XG4gICAgfVxuICAgIHB1YmxpYyBnZXQgZmllbGQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGBoZWFkZXJgIHZhbHVlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uSGVhZGVyID0gdGhpcy5jb2x1bW4uaGVhZGVyO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbaGVhZGVyXSA9IFwiJ0lEJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaGVhZGVyID0gJyc7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBgdGl0bGVgIHZhbHVlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgdGl0bGUgPSB0aGlzLmNvbHVtbi50aXRsZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW3RpdGxlXSA9IFwiJ1NvbWUgY29sdW1uIHRvb2x0aXAnXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0aXRsZSA9ICcnO1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgc29ydGFibGUuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNTb3J0YWJsZSA9IHRoaXMuY29sdW1uLnNvcnRhYmxlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbc29ydGFibGVdID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNvcnRhYmxlID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgY29sdW1uIGlzIHNlbGVjdGFibGUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5TZWxlY3RhYmxlID0gdGhpcy5jb2x1bW4uc2VsZWN0YWJsZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgc2VsZWN0YWJsZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGFibGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpZiB0aGUgY29sdW1uIGlzIHNlbGVjdGFibGUuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtzZWxlY3RhYmxlXSA9IFwiZmFsc2VcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHNldCBzZWxlY3RhYmxlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGFibGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIGdyb3VwYWJsZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc0dyb3VwYWJsZSA9IHRoaXMuY29sdW1uLmdyb3VwYWJsZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2dyb3VwYWJsZV0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXModHJ1ZSlcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBncm91cGFibGUgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBlZGl0YWJsZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc0VkaXRhYmxlID0gdGhpcy5jb2x1bW4uZWRpdGFibGU7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGVkaXRhYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBVcGRhdGluZyB0aGUgcHJpbWFyeSBrZXkgd2hlbiBncmlkIGhhcyB0cmFuc2FjdGlvbnMgKGluY2wuIHJvdyBlZGl0KVxuICAgICAgICAvLyBzaG91bGQgbm90IGJlIGFsbG93ZWQsIGFzIHRoYXQgY2FuIGNvcnJ1cHQgdHJhbnNhY3Rpb24gc3RhdGUuXG4gICAgICAgIGNvbnN0IHJvd0VkaXRhYmxlID0gdGhpcy5ncmlkICYmIHRoaXMuZ3JpZC5yb3dFZGl0YWJsZTtcbiAgICAgICAgY29uc3QgaGFzVHJhbnNhY3Rpb25zID0gdGhpcy5ncmlkICYmIHRoaXMuZ3JpZC50cmFuc2FjdGlvbnMuZW5hYmxlZDtcblxuICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnlDb2x1bW4gJiYgKHJvd0VkaXRhYmxlIHx8IGhhc1RyYW5zYWN0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9lZGl0YWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZWRpdGFibGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcm93RWRpdGFibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgZWRpdGFibGUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLmVkaXRhYmxlID0gdHJ1ZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2VkaXRhYmxlXSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGVkaXRhYmxlKGVkaXRhYmxlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2VkaXRhYmxlID0gZWRpdGFibGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgZmlsdGVyYWJsZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzRmlsdGVyYWJsZSA9IHRoaXMuY29sdW1uLmZpbHRlcmFibGU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtmaWx0ZXJhYmxlXSA9IFwiZmFsc2VcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGZpbHRlcmFibGUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgcmVzaXphYmxlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzUmVzaXphYmxlID0gdGhpcy5jb2x1bW4ucmVzaXphYmxlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbcmVzaXphYmxlXSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyByZXNpemFibGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaGVhZGVyIGlzIGluY2x1ZGVkIGluIGF1dG9zaXplIGxvZ2ljLlxuICAgICAqIFVzZWZ1bCB3aGVuIHRlbXBsYXRlIGZvciBhIGNvbHVtbiBoZWFkZXIgaXMgc2l6ZWQgYmFzZWQgb24gcGFyZW50LCBmb3IgZXhhbXBsZSBhIGRlZmF1bHQgYGRpdmAuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNSZXNpemFibGUgPSB0aGlzLmNvbHVtbi5yZXNpemFibGU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtyZXNpemFibGVdID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGF1dG9zaXplSGVhZGVyID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHN1bW1hcnkgZm9yIHRoZSBjb2x1bW4gaXMgZW5hYmxlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGhhc1N1bW1hcnkgPSB0aGlzLmNvbHVtbi5oYXNTdW1tYXJ5O1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKHRydWUpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGhhc1N1bW1hcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNTdW1tYXJ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzdW1tYXJ5IGZvciB0aGUgY29sdW1uIGlzIGVuYWJsZWQuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbaGFzU3VtbWFyeV0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHNldCBoYXNTdW1tYXJ5KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hhc1N1bW1hcnkgPSB2YWx1ZTtcblxuICAgICAgICBpZiAodGhpcy5ncmlkKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuc3VtbWFyeVNlcnZpY2UucmVzZXRTdW1tYXJ5SGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgaGlkZGVuLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNIaWRkZW4gPSB0aGlzLmNvbHVtbi5oaWRkZW47XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXModHJ1ZSlcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgaGlkZGVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlkZGVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2x1bW4gaGlkZGVuIHByb3BlcnR5LlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2hpZGRlbl0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUd28td2F5IGRhdGEgYmluZGluZy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gWyhoaWRkZW4pXSA9IFwibW9kZWwuaXNIaWRkZW5cIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHNldCBoaWRkZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2hpZGRlbiAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZGRlbiA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5oaWRkZW5DaGFuZ2UuZW1pdCh0aGlzLl9oaWRkZW4pO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1uTGF5b3V0Q2hpbGQgJiYgdGhpcy5wYXJlbnQuaGlkZGVuICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmhpZGRlbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuY3J1ZFNlcnZpY2UuZW5kRWRpdChmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLnN1bW1hcnlTZXJ2aWNlLnJlc2V0U3VtbWFyeUhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5maWx0ZXJpbmdTZXJ2aWNlLnJlZnJlc2hFeHByZXNzaW9ucygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5maWx0ZXJpbmdTZXJ2aWNlLmhpZGVGaWx0ZXJpbmdSb3dPbkNvbHVtblZpc2liaWxpdHlDaGFuZ2UodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGNvbHVtbiBpcyBzZWxlY3RlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzU2VsZWN0ZWQgPSB0aGlzLmNvbHVtbi5zZWxlY3RlZDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNlbGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnNlbGVjdGlvblNlcnZpY2UuaXNDb2x1bW5TZWxlY3RlZCh0aGlzLmZpZWxkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QvZGVzZWxlY3QgYSBjb2x1bW4uXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHNldCBzZWxlY3RlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RhYmxlICYmIHZhbHVlICE9PSB0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuc2VsZWN0aW9uU2VydmljZS5zZWxlY3RDb2x1bW5zV2l0aE5vRXZlbnQoW3RoaXMuZmllbGRdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLnNlbGVjdGlvblNlcnZpY2UuZGVzZWxlY3RDb2x1bW5zV2l0aE5vRXZlbnQoW3RoaXMuZmllbGRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ3JpZC5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGhpZGRlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGV4cGFuZGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgY29sbGFwc2libGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgdmlzaWJsZVdoZW5Db2xsYXBzZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBjb2x1bW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGhpZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzSGlkaW5nRGlzYWJsZWQgPSAgdGhpcy5jb2x1bW4uZGlzYWJsZUhpZGluZztcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZGlzYWJsZUhpZGluZyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcGlubmluZyBpcyBkaXNhYmxlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzUGlubmluZ0Rpc2FibGVkID0gIHRoaXMuY29sdW1uLmRpc2FibGVQaW5uaW5nO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkaXNhYmxlUGlubmluZyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgbW92YWJsZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc01vdmFibGUgPSB0aGlzLmNvbHVtbi5tb3ZhYmxlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbbW92YWJsZV0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIG1vdmFibGUgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBgd2lkdGhgIG9mIHRoZSBjb2x1bW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5XaWR0aCA9IHRoaXMuY29sdW1uLndpZHRoO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKHRydWUpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHdpZHRoKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoU2V0QnlVc2VyID8gdGhpcy5fd2lkdGggOiB0aGlzLmRlZmF1bHRXaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgd2lkdGhgIG9mIHRoZSBjb2x1bW4uXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFt3aWR0aF0gPSBcIicyNSUnXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVHdvLXdheSBkYXRhIGJpbmRpbmcuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFsod2lkdGgpXT1cIm1vZGVsLmNvbHVtbnNbMF0ud2lkdGhcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHNldCB3aWR0aCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FsY1dpZHRoID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY2FsY1BpeGVsV2lkdGggPSBOYU47XG4gICAgICAgICAgICB0aGlzLndpZHRoU2V0QnlVc2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHdpZHRoIGNvdWxkIGJlIHBhc3NlZCBhcyBudW1iZXIgZnJvbSB0aGUgdGVtcGxhdGVcbiAgICAgICAgICAgIC8vIGhvc3QgYmluZGluZ3MgYXJlIG5vdCBweCBhZmZpeGVkIHNvIHdlIG5lZWQgdG8gZW5zdXJlIHdlIGFmZml4IHNpbXBsZSBudW1iZXIgc3RyaW5nc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSAnbnVtYmVyJyB8fCB2YWx1ZS5tYXRjaCgvXlswLTldKiQvKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlQ2FsY1dpZHRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndpZHRoQ2hhbmdlLmVtaXQodGhpcy5fd2lkdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBtYXhpbXVtIGB3aWR0aGAgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbk1heFdpZHRoID0gdGhpcy5jb2x1bW4ud2lkdGg7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFttYXhXaWR0aF0gPSBcIicxNTBweCdcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgbWF4V2lkdGg6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgY2xhc3Mgc2VsZWN0b3Igb2YgdGhlIGNvbHVtbiBoZWFkZXIuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5IZWFkZXJDbGFzcyA9IHRoaXMuY29sdW1uLmhlYWRlckNsYXNzZXM7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtoZWFkZXJDbGFzc2VzXSA9IFwiJ2NvbHVtbi1oZWFkZXInXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBoZWFkZXJDbGFzc2VzID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGNvbmRpdGlvbmFsIHN0eWxlIHByb3BlcnRpZXMgb24gdGhlIGNvbHVtbiBoZWFkZXIuXG4gICAgICogU2ltaWxhciB0byBgbmdTdHlsZWAgaXQgYWNjZXB0cyBhbiBvYmplY3QgbGl0ZXJhbCB3aGVyZSB0aGUga2V5cyBhcmVcbiAgICAgKiB0aGUgc3R5bGUgcHJvcGVydGllcyBhbmQgdGhlIHZhbHVlIGlzIHRoZSBleHByZXNzaW9uIHRvIGJlIGV2YWx1YXRlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogc3R5bGVzID0ge1xuICAgICAqICBiYWNrZ3JvdW5kOiAncm95YWxibHVlJyxcbiAgICAgKiAgY29sb3I6IChjb2x1bW4pID0+IGNvbHVtbi5waW5uZWQgPyAncmVkJzogJ2luaGVyaXQnXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbaGVhZGVyU3R5bGVzXT1cInN0eWxlc1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaGVhZGVyU3R5bGVzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgY2xhc3Mgc2VsZWN0b3Igb2YgdGhlIGNvbHVtbiBncm91cCBoZWFkZXIuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5IZWFkZXJDbGFzcyA9IHRoaXMuY29sdW1uLmhlYWRlckdyb3VwQ2xhc3NlcztcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2hlYWRlckdyb3VwQ2xhc3Nlc10gPSBcIidjb2x1bW4tZ3JvdXAtaGVhZGVyJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaGVhZGVyR3JvdXBDbGFzc2VzID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGNvbmRpdGlvbmFsIHN0eWxlIHByb3BlcnRpZXMgb24gdGhlIGNvbHVtbiBoZWFkZXIgZ3JvdXAgd3JhcHBlci5cbiAgICAgKiBTaW1pbGFyIHRvIGBuZ1N0eWxlYCBpdCBhY2NlcHRzIGFuIG9iamVjdCBsaXRlcmFsIHdoZXJlIHRoZSBrZXlzIGFyZVxuICAgICAqIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGFuZCB0aGUgdmFsdWUgaXMgdGhlIGV4cHJlc3Npb24gdG8gYmUgZXZhbHVhdGVkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBzdHlsZXMgPSB7XG4gICAgICogIGJhY2tncm91bmQ6ICdyb3lhbGJsdWUnLFxuICAgICAqICBjb2xvcjogKGNvbHVtbikgPT4gY29sdW1uLnBpbm5lZCA/ICdyZWQnOiAnaW5oZXJpdCdcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtoZWFkZXJHcm91cFN0eWxlc109XCJzdHlsZXNcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGhlYWRlckdyb3VwU3R5bGVzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBjb25kaXRpb25hbCBjbGFzcyBzZWxlY3RvciBvZiB0aGUgY29sdW1uIGNlbGxzLlxuICAgICAqIEFjY2VwdHMgYW4gb2JqZWN0IGxpdGVyYWwsIGNvbnRhaW5pbmcga2V5LXZhbHVlIHBhaXJzLFxuICAgICAqIHdoZXJlIHRoZSBrZXkgaXMgdGhlIG5hbWUgb2YgdGhlIENTUyBjbGFzcywgd2hpbGUgdGhlXG4gICAgICogdmFsdWUgaXMgZWl0aGVyIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYm9vbGVhbixcbiAgICAgKiBvciBib29sZWFuLCBsaWtlIHNvOlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjYWxsYmFjayA9IChyb3dEYXRhLCBjb2x1bW5LZXksIGNlbGxWYWx1ZSwgcm93SW5kZXgpID0+IHsgcmV0dXJuIHJvd0RhdGFbY29sdW1uS2V5XSA+IDY7IH1cbiAgICAgKiBjZWxsQ2xhc3NlcyA9IHsgJ2NsYXNzTmFtZScgOiB0aGlzLmNhbGxiYWNrIH07XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtjZWxsQ2xhc3Nlc10gPSBcImNlbGxDbGFzc2VzXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDxpZ3gtY29sdW1uIFtjZWxsQ2xhc3Nlc10gPSBcInsnY2xhc3MxJyA6IHRydWUgfVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY2VsbENsYXNzZXM6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29uZGl0aW9uYWwgc3R5bGUgcHJvcGVydGllcyBvbiB0aGUgY29sdW1uIGNlbGxzLlxuICAgICAqIFNpbWlsYXIgdG8gYG5nU3R5bGVgIGl0IGFjY2VwdHMgYW4gb2JqZWN0IGxpdGVyYWwgd2hlcmUgdGhlIGtleXMgYXJlXG4gICAgICogdGhlIHN0eWxlIHByb3BlcnRpZXMgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgZXhwcmVzc2lvbiB0byBiZSBldmFsdWF0ZWQuXG4gICAgICogQXMgd2l0aCBgY2VsbENsYXNzZXNgIGl0IGFjY2VwdHMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogc3R5bGVzID0ge1xuICAgICAqICBiYWNrZ3JvdW5kOiAncm95YWxibHVlJyxcbiAgICAgKiAgY29sb3I6IChyb3dEYXRhLCBjb2x1bW5LZXksIGNlbGxWYWx1ZSwgcm93SW5kZXgpID0+IHZhbHVlLnN0YXJ0c1dpdGgoJ0ltcG9ydGFudCcpID8gJ3JlZCc6ICdpbmhlcml0J1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2NlbGxTdHlsZXNdPVwic3R5bGVzXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBjZWxsU3R5bGVzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGRpc3BsYXkgZm9ybWF0IHRvIGNlbGwgdmFsdWVzIGluIHRoZSBjb2x1bW4uIERvZXMgbm90IG1vZGlmeSB0aGUgdW5kZXJseWluZyBkYXRhLlxuICAgICAqXG4gICAgICogQHJlbWFya1xuICAgICAqIE5vdGU6IEFzIHRoZSBmb3JtYXR0ZXIgaXMgdXNlZCBpbiBwbGFjZXMgbGlrZSB0aGUgRXhjZWwgc3R5bGUgZmlsdGVyaW5nIGRpYWxvZywgaW4gY2VydGFpblxuICAgICAqIHNjZW5hcmlvcyAocmVtb3RlIGZpbHRlcmluZyBmb3IgZXhhbXBsZSksIHRoZSByb3cgZGF0YSBhcmd1bWVudCBjYW4gYmUgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEluIHRoaXMgZXhhbXBsZSwgd2UgY2hlY2sgdG8gc2VlIGlmIHRoZSBjb2x1bW4gbmFtZSBpcyBTYWxhcnksIGFuZCB0aGVuIHByb3ZpZGUgYSBtZXRob2QgYXMgdGhlIGNvbHVtbiBmb3JtYXR0ZXJcbiAgICAgKiB0byBmb3JtYXQgdGhlIHZhbHVlIGludG8gYSBjdXJyZW5jeSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb2x1bW5Jbml0KGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50KSB7XG4gICAgICogICBpZiAoY29sdW1uLmZpZWxkID09IFwiU2FsYXJ5XCIpIHtcbiAgICAgKiAgICAgY29sdW1uLmZvcm1hdHRlciA9IChzYWxhcnkgPT4gdGhpcy5mb3JtYXQoc2FsYXJ5KSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogZm9ybWF0KHZhbHVlOiBudW1iZXIpIDogc3RyaW5nIHtcbiAgICAgKiAgIHJldHVybiBmb3JtYXRDdXJyZW5jeSh2YWx1ZSwgXCJlbi11c1wiLCBcIiRcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgY29sdW1uID0gdGhpcy5ncmlkLmdldENvbHVtbkJ5TmFtZSgnQWRkcmVzcycpO1xuICAgICAqIGNvbnN0IGFkZHJlc3NGb3JtYXR0ZXIgPSAoYWRkcmVzczogc3RyaW5nLCByb3dEYXRhOiBhbnkpID0+IGRhdGEucHJpdmFjeUVuYWJsZWQgPyAndW5rbm93bicgOiBhZGRyZXNzO1xuICAgICAqIGNvbHVtbi5mb3JtYXR0ZXIgPSBhZGRyZXNzRm9ybWF0dGVyO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBmb3JtYXR0ZXI6ICh2YWx1ZTogYW55LCByb3dEYXRhPzogYW55KSA9PiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3VtbWFyeUZvcm1hdHRlciBpcyB1c2VkIHRvIGZvcm1hdCB0aGUgZGlzcGxheSBvZiB0aGUgY29sdW1uIHN1bW1hcmllcy5cbiAgICAgKlxuICAgICAqIEluIHRoaXMgZXhhbXBsZSwgd2UgY2hlY2sgdG8gc2VlIGlmIHRoZSBjb2x1bW4gbmFtZSBpcyBPcmRlckRhdGUsIGFuZCB0aGVuIHByb3ZpZGUgYSBtZXRob2QgYXMgdGhlIHN1bW1hcnlGb3JtYXR0ZXJcbiAgICAgKiB0byBjaGFuZ2UgdGhlIGxvY2FsZSBmb3IgdGhlIGRhdGVzIHRvICdmci1GUicuIFRoZSBzdW1tYXJpZXMgd2l0aCB0aGUgY291bnQga2V5IGFyZSBza2lwcGVkIHNvIHRoZXkgYXJlIGRpc3BsYXllZCBhcyBudW1iZXJzLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbHVtbkluaXQoY29sdW1uOiBJZ3hDb2x1bW5Db21wb25lbnQpIHtcbiAgICAgKiAgIGlmIChjb2x1bW4uZmllbGQgPT0gXCJPcmRlckRhdGVcIikge1xuICAgICAqICAgICBjb2x1bW4uc3VtbWFyeUZvcm1hdHRlciA9IHRoaXMuc3VtbWFyeUZvcm1hdDtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBzdW1tYXJ5Rm9ybWF0KHN1bW1hcnk6IElneFN1bW1hcnlSZXN1bHQsIHN1bW1hcnlPcGVyYW5kOiBJZ3hTdW1tYXJ5T3BlcmFuZCk6IHN0cmluZyB7XG4gICAgICogICBjb25zdCByZXN1bHQgPSBzdW1tYXJ5LnN1bW1hcnlSZXN1bHQ7XG4gICAgICogICBpZihzdW1tYXJ5UmVzdWx0LmtleSAhPT0gJ2NvdW50JyAmJiByZXN1bHQgIT09IG51bGwgJiYgcmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgKiAgICAgIGNvbnN0IHBpcGUgPSBuZXcgRGF0ZVBpcGUoJ2ZyLUZSJyk7XG4gICAgICogICAgICByZXR1cm4gcGlwZS50cmFuc2Zvcm0ocmVzdWx0LCdtZWRpdW1EYXRlJyk7XG4gICAgICogICB9XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc3VtbWFyeUZvcm1hdHRlcjogKHN1bW1hcnk6IElneFN1bW1hcnlSZXN1bHQsIHN1bW1hcnlPcGVyYW5kOiBJZ3hTdW1tYXJ5T3BlcmFuZCkgPT4gYW55O1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBmaWx0ZXJpbmcgc2hvdWxkIGJlIGNhc2Ugc2Vuc2l0aXZlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYHRydWVgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZmlsdGVyaW5nSWdub3JlQ2FzZSA9IHRoaXMuY29sdW1uLmZpbHRlcmluZ0lnbm9yZUNhc2U7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtmaWx0ZXJpbmdJZ25vcmVDYXNlXSA9IFwiZmFsc2VcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZmlsdGVyaW5nSWdub3JlQ2FzZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBzb3J0aW5nIHNob3VsZCBiZSBjYXNlIHNlbnNpdGl2ZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHNvcnRpbmdJZ25vcmVDYXNlID0gdGhpcy5jb2x1bW4uc29ydGluZ0lnbm9yZUNhc2U7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtzb3J0aW5nSWdub3JlQ2FzZV0gPSBcImZhbHNlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNvcnRpbmdJZ25vcmVDYXNlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIGBzZWFyY2hhYmxlYC5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzU2VhcmNoYWJsZSA9ICB0aGlzLmNvbHVtbi5zZWFyY2hhYmxlJztcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogIDxpZ3gtY29sdW1uIFtzZWFyY2hhYmxlXSA9IFwiZmFsc2VcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNlYXJjaGFibGUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgZGF0YSB0eXBlIG9mIHRoZSBjb2x1bW4gdmFsdWVzLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYHN0cmluZ2AuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5EYXRhVHlwZSA9IHRoaXMuY29sdW1uLmRhdGFUeXBlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbZGF0YVR5cGVdID0gXCInbnVtYmVyJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkYXRhVHlwZTogR3JpZENvbHVtbkRhdGFUeXBlID0gR3JpZENvbHVtbkRhdGFUeXBlLlN0cmluZztcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY29sbGFwc2libGVJbmRpY2F0b3JUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIFJvdyBpbmRleCB3aGVyZSB0aGUgY3VycmVudCBmaWVsZCBzaG91bGQgZW5kLlxuICAgICAqIFRoZSBhbW91bnQgb2Ygcm93cyBiZXR3ZWVuIHJvd1N0YXJ0IGFuZCByb3dFbmQgd2lsbCBkZXRlcm1pbmUgdGhlIGFtb3VudCBvZiBzcGFubmluZyByb3dzIHRvIHRoYXQgZmllbGRcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4tbGF5b3V0PlxuICAgICAqICAgPGlneC1jb2x1bW4gW3Jvd0VuZF09XCIyXCIgW3Jvd1N0YXJ0XT1cIjFcIiBbY29sU3RhcnRdPVwiMVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiA8L2lneC1jb2x1bW4tbGF5b3V0PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHJvd0VuZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ29sdW1uIGluZGV4IHdoZXJlIHRoZSBjdXJyZW50IGZpZWxkIHNob3VsZCBlbmQuXG4gICAgICogVGhlIGFtb3VudCBvZiBjb2x1bW5zIGJldHdlZW4gY29sU3RhcnQgYW5kIGNvbEVuZCB3aWxsIGRldGVybWluZSB0aGUgYW1vdW50IG9mIHNwYW5uaW5nIGNvbHVtbnMgdG8gdGhhdCBmaWVsZFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbi1sYXlvdXQ+XG4gICAgICogICA8aWd4LWNvbHVtbiBbY29sRW5kXT1cIjNcIiBbcm93U3RhcnRdPVwiMVwiIFtjb2xTdGFydF09XCIxXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDwvaWd4LWNvbHVtbi1sYXlvdXQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY29sRW5kOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBSb3cgaW5kZXggZnJvbSB3aGljaCB0aGUgZmllbGQgaXMgc3RhcnRpbmcuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiAgIDxpZ3gtY29sdW1uIFtyb3dTdGFydF09XCIxXCIgW2NvbFN0YXJ0XT1cIjFcIj48L2lneC1jb2x1bW4+XG4gICAgICogPC9pZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyByb3dTdGFydDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ29sdW1uIGluZGV4IGZyb20gd2hpY2ggdGhlIGZpZWxkIGlzIHN0YXJ0aW5nLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbi1sYXlvdXQ+XG4gICAgICogICA8aWd4LWNvbHVtbiBbY29sU3RhcnRdPVwiMVwiIFtyb3dTdGFydF09XCIxXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDwvaWd4LWNvbHVtbi1sYXlvdXQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY29sU3RhcnQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyBjdXN0b20gcHJvcGVydGllcyBwcm92aWRlZCBpbiBhZGRpdGlvbmFsIHRlbXBsYXRlIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2FkZGl0aW9uYWxUZW1wbGF0ZUNvbnRleHRdPVwiY29udGV4dE9iamVjdFwiPlxuICAgICAqICAgPG5nLXRlbXBsYXRlIGlneENlbGwgbGV0LWNlbGw9XCJjZWxsXCIgbGV0LXByb3BzPVwiYWRkaXRpb25hbFRlbXBsYXRlQ29udGV4dFwiPlxuICAgICAqICAgICAge3sgcHJvcHMgfX1cbiAgICAgKiAgIDwvbmctdGVtcGxhdGU+XG4gICAgICogPC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGFkZGl0aW9uYWxUZW1wbGF0ZUNvbnRleHQ6IGFueTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgd2lkdGhDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcGlubmVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneEZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hGaWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUgfSlcbiAgICBwdWJsaWMgZmlsdGVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlOiBJZ3hGaWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmU7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4Q2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IElneENlbGxUZW1wbGF0ZURpcmVjdGl2ZSB9KVxuICAgIHByb3RlY3RlZCBjZWxsVGVtcGxhdGU6IElneENlbGxUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihJZ3hDZWxsSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4Q2VsbEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLCBkZXNjZW5kYW50czogZmFsc2UgfSlcbiAgICBwcm90ZWN0ZWQgaGVhZFRlbXBsYXRlOiBRdWVyeUxpc3Q8SWd4Q2VsbEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlPjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hDZWxsRWRpdG9yVGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4Q2VsbEVkaXRvclRlbXBsYXRlRGlyZWN0aXZlIH0pXG4gICAgcHJvdGVjdGVkIGVkaXRvclRlbXBsYXRlOiBJZ3hDZWxsRWRpdG9yVGVtcGxhdGVEaXJlY3RpdmU7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4Q29sbGFwc2libGVJbmRpY2F0b3JUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hDb2xsYXBzaWJsZUluZGljYXRvclRlbXBsYXRlRGlyZWN0aXZlLCBzdGF0aWM6IGZhbHNlIH0pXG4gICAgcHJvdGVjdGVkIGNvbGxhcHNlSW5kaWNhdG9yVGVtcGxhdGU6IElneENvbGxhcHNpYmxlSW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmU7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBjYWxjV2lkdGgoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FsY1dpZHRoKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGNhbGNQaXhlbFdpZHRoOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBtYXhXaWR0aFB4KCkge1xuICAgICAgICBjb25zdCBncmlkQXZhaWxhYmxlU2l6ZSA9IHRoaXMuZ3JpZC5jYWxjV2lkdGg7XG4gICAgICAgIGNvbnN0IGlzUGVyY2VudGFnZVdpZHRoID0gdGhpcy5tYXhXaWR0aCAmJiB0eXBlb2YgdGhpcy5tYXhXaWR0aCA9PT0gJ3N0cmluZycgJiYgdGhpcy5tYXhXaWR0aC5pbmRleE9mKCclJykgIT09IC0xO1xuICAgICAgICByZXR1cm4gaXNQZXJjZW50YWdlV2lkdGggPyBwYXJzZUZsb2F0KHRoaXMubWF4V2lkdGgpIC8gMTAwICogZ3JpZEF2YWlsYWJsZVNpemUgOiBwYXJzZUZsb2F0KHRoaXMubWF4V2lkdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1heFdpZHRoUGVyY2VudCgpIHtcbiAgICAgICAgY29uc3QgZ3JpZEF2YWlsYWJsZVNpemUgPSB0aGlzLmdyaWQuY2FsY1dpZHRoO1xuICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IHRoaXMubWF4V2lkdGggJiYgdHlwZW9mIHRoaXMubWF4V2lkdGggPT09ICdzdHJpbmcnICYmIHRoaXMubWF4V2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcbiAgICAgICAgcmV0dXJuIGlzUGVyY2VudGFnZVdpZHRoID8gcGFyc2VGbG9hdCh0aGlzLm1heFdpZHRoKSA6IHBhcnNlRmxvYXQodGhpcy5tYXhXaWR0aCkgLyBncmlkQXZhaWxhYmxlU2l6ZSAqIDEwMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBtaW5XaWR0aFB4KCkge1xuICAgICAgICBjb25zdCBncmlkQXZhaWxhYmxlU2l6ZSA9IHRoaXMuZ3JpZC5jYWxjV2lkdGg7XG4gICAgICAgIGNvbnN0IGlzUGVyY2VudGFnZVdpZHRoID0gdGhpcy5taW5XaWR0aCAmJiB0eXBlb2YgdGhpcy5taW5XaWR0aCA9PT0gJ3N0cmluZycgJiYgdGhpcy5taW5XaWR0aC5pbmRleE9mKCclJykgIT09IC0xO1xuICAgICAgICByZXR1cm4gaXNQZXJjZW50YWdlV2lkdGggPyBwYXJzZUZsb2F0KHRoaXMubWluV2lkdGgpIC8gMTAwICogZ3JpZEF2YWlsYWJsZVNpemUgOiBwYXJzZUZsb2F0KHRoaXMubWluV2lkdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1pbldpZHRoUGVyY2VudCgpIHtcbiAgICAgICAgY29uc3QgZ3JpZEF2YWlsYWJsZVNpemUgPSB0aGlzLmdyaWQuY2FsY1dpZHRoO1xuICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IHRoaXMubWluV2lkdGggJiYgdHlwZW9mIHRoaXMubWluV2lkdGggPT09ICdzdHJpbmcnICYmIHRoaXMubWluV2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcbiAgICAgICAgcmV0dXJuIGlzUGVyY2VudGFnZVdpZHRoID8gcGFyc2VGbG9hdCh0aGlzLm1pbldpZHRoKSA6IHBhcnNlRmxvYXQodGhpcy5taW5XaWR0aCkgLyBncmlkQXZhaWxhYmxlU2l6ZSAqIDEwMDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgbWluaW11bSBgd2lkdGhgIG9mIHRoZSBjb2x1bW4uXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgODhgO1xuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uTWluV2lkdGggPSB0aGlzLmNvbHVtbi5taW5XaWR0aDtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW21pbldpZHRoXSA9IFwiJzEwMHB4J1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IG1pbldpZHRoKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgbWluVmFsID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4obWluVmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlZmF1bHRNaW5XaWR0aCA9IHZhbHVlO1xuXG4gICAgfVxuICAgIHB1YmxpYyBnZXQgbWluV2lkdGgoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9kZWZhdWx0TWluV2lkdGggPyB0aGlzLmRlZmF1bHRNaW5XaWR0aCA6IHRoaXMuX2RlZmF1bHRNaW5XaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gaW5kZXguXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5JbmRleCA9IHRoaXMuY29sdW1uLmluZGV4O1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5jb2x1bW5zLmluZGV4T2YodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgYHBpbm5lZGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc1Bpbm5lZCA9IHRoaXMuY29sdW1uLnBpbm5lZDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgcGlubmVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGlubmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBwaW5uZWQuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbcGlubmVkXSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFR3by13YXkgZGF0YSBiaW5kaW5nLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbKHBpbm5lZCldID0gXCJtb2RlbC5jb2x1bW5zWzBdLmlzUGlubmVkXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgcGlubmVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh0aGlzLl9waW5uZWQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ncmlkICYmIHRoaXMud2lkdGggJiYgIWlzTmFOKHBhcnNlSW50KHRoaXMud2lkdGgsIDEwKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waW4oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVucGluKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIE5vIGdyaWQvd2lkdGggYXZhaWxhYmxlIGF0IGluaXRpYWxpemF0aW9uLiBgaW5pdFBpbm5pbmdgIGluIHRoZSBncmlkXG4gICAgICAgICAgICAgICB3aWxsIHJlLWluaXQgdGhlIGdyb3VwIChpZiBwcmVzZW50KVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3Bpbm5lZCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5waW5uZWRDaGFuZ2UuZW1pdCh0aGlzLl9waW5uZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29sdW1uIGBzdW1tYXJpZXNgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uU3VtbWFyaWVzID0gdGhpcy5jb2x1bW4uc3VtbWFyaWVzO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKHRydWUpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHN1bW1hcmllcygpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VtbWFyaWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2x1bW4gYHN1bW1hcmllc2AuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLnN1bW1hcmllcyA9IElneE51bWJlclN1bW1hcnlPcGVyYW5kO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgc3VtbWFyaWVzKGNsYXNzUmVmOiBhbnkpIHtcbiAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IoY2xhc3NSZWYpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdW1tYXJpZXMgPSBuZXcgY2xhc3NSZWYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5zdW1tYXJ5U2VydmljZS5yZW1vdmVTdW1tYXJpZXNDYWNoZVBlckNvbHVtbih0aGlzLmZpZWxkKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5zdW1tYXJ5UGlwZVRyaWdnZXIrKztcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5zdW1tYXJ5U2VydmljZS5yZXNldFN1bW1hcnlIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gYGZpbHRlcnNgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uRmlsdGVycyA9IHRoaXMuY29sdW1uLmZpbHRlcnMnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGZpbHRlcnMoKTogSWd4RmlsdGVyaW5nT3BlcmFuZCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2x1bW4gYGZpbHRlcnNgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbi5maWx0ZXJzID0gSWd4Qm9vbGVhbkZpbHRlcmluZ09wZXJhbmQuaW5zdGFuY2UoKS5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGZpbHRlcnMoaW5zdGFuY2U6IElneEZpbHRlcmluZ09wZXJhbmQpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVycyA9IGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gYHNvcnRTdHJhdGVneWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBzb3J0U3RyYXRlZ3kgPSB0aGlzLmNvbHVtbi5zb3J0U3RyYXRlZ3lcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgc29ydFN0cmF0ZWd5KCk6IElTb3J0aW5nU3RyYXRlZ3kge1xuICAgICAgICByZXR1cm4gdGhpcy5fc29ydFN0cmF0ZWd5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2x1bW4gYHNvcnRTdHJhdGVneWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLnNvcnRTdHJhdGVneSA9IG5ldyBDdXN0b21Tb3J0aW5nU3RyYXRlZ3koKS5cbiAgICAgKiBjbGFzcyBDdXN0b21Tb3J0aW5nU3RyYXRlZ3kgZXh0ZW5kcyBTb3J0aW5nU3RyYXRlZ3kgey4uLn1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHNvcnRTdHJhdGVneShjbGFzc1JlZjogSVNvcnRpbmdTdHJhdGVneSkge1xuICAgICAgICB0aGlzLl9zb3J0U3RyYXRlZ3kgPSBjbGFzc1JlZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZnVuY3Rpb24gdGhhdCBjb21wYXJlcyB2YWx1ZXMgZm9yIGdyb3VwaW5nLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZ3JvdXBpbmdDb21wYXJlciA9IHRoaXMuY29sdW1uLmdyb3VwaW5nQ29tcGFyZXInXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGdyb3VwaW5nQ29tcGFyZXIoKTogKGE6IGFueSwgYjogYW55KSA9PiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBpbmdDb21wYXJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIGN1c3RvbSBmdW5jdGlvbiB0byBjb21wYXJlIHZhbHVlcyBmb3IgZ3JvdXBpbmcuXG4gICAgICogU3Vic2VxdWVudCB2YWx1ZXMgaW4gdGhlIHNvcnRlZCBkYXRhIHRoYXQgdGhlIGZ1bmN0aW9uIHJldHVybnMgMCBmb3IgYXJlIGdyb3VwZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLmdyb3VwaW5nQ29tcGFyZXIgPSAoYTogYW55LCBiOiBhbnkpID0+IHsgcmV0dXJuIGEgPT09IGIgPyAwIDogLTE7IH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGdyb3VwaW5nQ29tcGFyZXIoZnVuY1JlZjogKGE6IGFueSwgYjogYW55KSA9PiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBpbmdDb21wYXJlciA9IGZ1bmNSZWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRlZmF1bHQgbWluaW11bSBgd2lkdGhgIG9mIHRoZSBjb2x1bW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBkZWZhdWx0TWluV2lkdGggPSAgdGhpcy5jb2x1bW4uZGVmYXVsdE1pbldpZHRoO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZGVmYXVsdE1pbldpZHRoKCk6IHN0cmluZyB7XG4gICAgICAgIGlmICghdGhpcy5ncmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJzgwJztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMuZ3JpZC5kaXNwbGF5RGVuc2l0eSkge1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb3N5OlxuICAgICAgICAgICAgICAgIHJldHVybiAnNjQnO1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnNTYnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJzgwJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVmZXJlbmNlIHRvIHRoZSBgaWd4LWdyaWRgIG93bmVyLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZ3JpZENvbXBvbmVudCA9IHRoaXMuY29sdW1uLmdyaWQ7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldCBncmlkKCk6IElneEdyaWRCYXNlRGlyZWN0aXZlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZEFQSS5ncmlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgYm9keVRlbXBsYXRlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGJvZHlUZW1wbGF0ZSA9IHRoaXMuY29sdW1uLmJvZHlUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KCdjZWxsVGVtcGxhdGUnKVxuICAgIHB1YmxpYyBnZXQgYm9keVRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9keVRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBib2R5IHRlbXBsYXRlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgI2JvZHlUZW1wbGF0ZSBpZ3hDZWxsIGxldC12YWw+XG4gICAgICogICAgPGRpdiBzdHlsZSA9IFwiYmFja2dyb3VuZC1jb2xvcjogeWVsbG93Z3JlZW5cIiAoY2xpY2spID0gXCJjaGFuZ2VDb2xvcih2YWwpXCI+XG4gICAgICogICAgICAgPHNwYW4+IHt7dmFsfX0gPC9zcGFuPlxuICAgICAqICAgIDwvZGl2PlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCInYm9keVRlbXBsYXRlJ1wiLCB7cmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICAgKiBwdWJsaWMgYm9keVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgICAqIHRoaXMuY29sdW1uLmJvZHlUZW1wbGF0ZSA9IHRoaXMuYm9keVRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgYm9keVRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBoZWFkZXIgdGVtcGxhdGUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBoZWFkZXJUZW1wbGF0ZSA9IHRoaXMuY29sdW1uLmhlYWRlclRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgaGVhZGVyVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVhZGVyIHRlbXBsYXRlLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgY29sdW1uIGhlYWRlciBoZWlnaHQgaXMgZml4ZWQgYW5kIGFueSBjb250ZW50IGJpZ2dlciB0aGFuIGl0IHdpbGwgYmUgY3V0IG9mZi5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNoZWFkZXJUZW1wbGF0ZT5cbiAgICAgKiAgIDxkaXYgc3R5bGUgPSBcImJhY2tncm91bmQtY29sb3I6YmxhY2tcIiAoY2xpY2spID0gXCJjaGFuZ2VDb2xvcih2YWwpXCI+XG4gICAgICogICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWRcIiA+e3tjb2x1bW4uZmllbGR9fTwvc3Bhbj5cbiAgICAgKiAgIDwvZGl2PlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCInaGVhZGVyVGVtcGxhdGUnXCIsIHtyZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgICAqIHB1YmxpYyBoZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAgKiB0aGlzLmNvbHVtbi5oZWFkZXJUZW1wbGF0ZSA9IHRoaXMuaGVhZGVyVGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHNldCBoZWFkZXJUZW1wbGF0ZSh0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Pikge1xuICAgICAgICB0aGlzLl9oZWFkZXJUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBpbmxpbmUgZWRpdG9yIHRlbXBsYXRlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaW5saW5lRWRpdG9yVGVtcGxhdGUgPSB0aGlzLmNvbHVtbi5pbmxpbmVFZGl0b3JUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KCdjZWxsRWRpdG9yVGVtcGxhdGUnKVxuICAgIHB1YmxpYyBnZXQgaW5saW5lRWRpdG9yVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmxpbmVFZGl0b3JUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5saW5lIGVkaXRvciB0ZW1wbGF0ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNpbmxpbmVFZGl0b3JUZW1wbGF0ZSBpZ3hDZWxsRWRpdG9yIGxldC1jZWxsPVwiY2VsbFwiPlxuICAgICAqICAgICA8aW5wdXQgdHlwZT1cInN0cmluZ1wiIFsobmdNb2RlbCldPVwiY2VsbC52YWx1ZVwiLz5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiJ2lubGluZUVkaXRvclRlbXBsYXRlJ1wiLCB7cmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICAgKiBwdWJsaWMgaW5saW5lRWRpdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgICogdGhpcy5jb2x1bW4uaW5saW5lRWRpdG9yVGVtcGxhdGUgPSB0aGlzLmlubGluZUVkaXRvclRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgaW5saW5lRWRpdG9yVGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pIHtcbiAgICAgICAgdGhpcy5faW5saW5lRWRpdG9yVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYGZpbHRlckNlbGxUZW1wbGF0ZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBmaWx0ZXJDZWxsVGVtcGxhdGUgPSB0aGlzLmNvbHVtbi5maWx0ZXJDZWxsVGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgnZmlsdGVyQ2VsbFRlbXBsYXRlJylcbiAgICBwdWJsaWMgZ2V0IGZpbHRlckNlbGxUZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlckNlbGxUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcXVpY2sgZmlsdGVyIHRlbXBsYXRlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgI2ZpbHRlckNlbGxUZW1wbGF0ZSBJZ3hGaWx0ZXJDZWxsVGVtcGxhdGUgbGV0LWNvbHVtbj1cImNvbHVtblwiPlxuICAgICAqICAgIDxpbnB1dCAoaW5wdXQpPVwib25JbnB1dCgpXCI+XG4gICAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIidmaWx0ZXJDZWxsVGVtcGxhdGUnXCIsIHtyZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgICAqIHB1YmxpYyBmaWx0ZXJDZWxsVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgICogdGhpcy5jb2x1bW4uZmlsdGVyQ2VsbFRlbXBsYXRlID0gdGhpcy5maWx0ZXJDZWxsVGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHNldCBmaWx0ZXJDZWxsVGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyQ2VsbFRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2VsbHMgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkNlbGxzID0gdGhpcy5jb2x1bW4uX2NlbGxzO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIGdldCBjZWxscygpOiBDZWxsVHlwZVtdIHtcbiAgICAgICAgLy8gVE9ETyBjYWxjbHVsYXRlIGluZGV4IGZvciByZW1vdGUgZGF0YSBzY2VuYXJpb3NcbiAgICAgICAgLy8gY2hlY2sgaW5kZXhlcyBpbiB0aGlzLmRhdGFSb3dMaXN0LmZpcnN0IGFuZCB0aGlzLmRhdGFSb3dMaXN0Lmxhc3RcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5kYXRhVmlld1xuICAgICAgICAgICAgLm1hcCgocmVjLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5ncmlkLmlzR3JvdXBCeVJlY29yZChyZWMpICYmICF0aGlzLmdyaWQuaXNTdW1tYXJ5Um93KHJlYykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IG5ldyBJZ3hHcmlkQ2VsbCh0aGlzLmdyaWQgYXMgYW55LCBpbmRleCwgdGhpcy5maWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmZpbHRlcihjZWxsID0+IGNlbGwpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IF9jZWxscygpOiBJZ3hHcmlkQ2VsbENvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5yb3dMaXN0LmZpbHRlcigocm93KSA9PiByb3cgaW5zdGFuY2VvZiBJZ3hSb3dEaXJlY3RpdmUpXG4gICAgICAgICAgICAubWFwKChyb3cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocm93Ll9jZWxscykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93Ll9jZWxscy5maWx0ZXIoKGNlbGwpID0+IGNlbGwuY29sdW1uSW5kZXggPT09IHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gdmlzaWJsZSBpbmRleC5cbiAgICAgKiBJZiB0aGUgY29sdW1uIGlzIG5vdCB2aXNpYmxlLCByZXR1cm5zIGAtMWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCB2aXNpYmxlQ29sdW1uSW5kZXggPSAgdGhpcy5jb2x1bW4udmlzaWJsZUluZGV4O1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdmlzaWJsZUluZGV4KCk6IG51bWJlciB7XG4gICAgICAgIGlmICghaXNOYU4odGhpcy5fdkluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bnBpbm5lZENvbHVtbnMgPSB0aGlzLmdyaWQudW5waW5uZWRDb2x1bW5zLmZpbHRlcihjID0+ICFjLmNvbHVtbkdyb3VwKTtcbiAgICAgICAgY29uc3QgcGlubmVkQ29sdW1ucyA9IHRoaXMuZ3JpZC5waW5uZWRDb2x1bW5zLmZpbHRlcihjID0+ICFjLmNvbHVtbkdyb3VwKTtcbiAgICAgICAgbGV0IGNvbCA9IHRoaXM7XG4gICAgICAgIGxldCB2SW5kZXggPSAtMTtcblxuICAgICAgICBpZiAodGhpcy5jb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgY29sID0gdGhpcy5hbGxDaGlsZHJlbi5maWx0ZXIoYyA9PiAhYy5jb2x1bW5Hcm91cCAmJiAhYy5oaWRkZW4pWzBdIGFzIGFueTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb2x1bW5MYXlvdXRDaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkcmVuVmlzaWJsZUluZGV4ZXMuZmluZCh4ID0+IHguY29sdW1uID09PSB0aGlzKS5pbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5waW5uZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4SW5Db2xsZWN0aW9uID0gdW5waW5uZWRDb2x1bW5zLmluZGV4T2YoY29sKTtcbiAgICAgICAgICAgIHZJbmRleCA9IGluZGV4SW5Db2xsZWN0aW9uID09PSAtMSA/XG4gICAgICAgICAgICAgICAgLTEgOlxuICAgICAgICAgICAgICAgICh0aGlzLmdyaWQuaXNQaW5uaW5nVG9TdGFydCA/XG4gICAgICAgICAgICAgICAgICAgIHBpbm5lZENvbHVtbnMubGVuZ3RoICsgaW5kZXhJbkNvbGxlY3Rpb24gOlxuICAgICAgICAgICAgICAgICAgICBpbmRleEluQ29sbGVjdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleEluQ29sbGVjdGlvbiA9IHBpbm5lZENvbHVtbnMuaW5kZXhPZihjb2wpO1xuICAgICAgICAgICAgdkluZGV4ID0gdGhpcy5ncmlkLmlzUGlubmluZ1RvU3RhcnQgP1xuICAgICAgICAgICAgICAgIGluZGV4SW5Db2xsZWN0aW9uIDpcbiAgICAgICAgICAgICAgICB1bnBpbm5lZENvbHVtbnMubGVuZ3RoICsgaW5kZXhJbkNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdkluZGV4ID0gdkluZGV4O1xuICAgICAgICByZXR1cm4gdkluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBjb2x1bW4gaXMgYSBgQ29sdW1uR3JvdXBgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uR3JvdXAgPSAgdGhpcy5jb2x1bW4uY29sdW1uR3JvdXA7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldCBjb2x1bW5Hcm91cCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBjb2x1bW4gaXMgYSBgQ29sdW1uTGF5b3V0YCBmb3IgbXVsdGktcm93IGxheW91dC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkdyb3VwID0gIHRoaXMuY29sdW1uLmNvbHVtbkdyb3VwO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY29sdW1uTGF5b3V0KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgY29sdW1uIGlzIGEgY2hpbGQgb2YgYSBgQ29sdW1uTGF5b3V0YCBmb3IgbXVsdGktcm93IGxheW91dC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkxheW91dENoaWxkID0gIHRoaXMuY29sdW1uLmNvbHVtbkxheW91dENoaWxkO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY29sdW1uTGF5b3V0Q2hpbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5jb2x1bW5MYXlvdXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2hpbGRyZW4gY29sdW1ucyBjb2xsZWN0aW9uLlxuICAgICAqIFJldHVybnMgYW4gZW1wdHkgYXJyYXkgaWYgdGhlIGNvbHVtbiBkb2VzIG5vdCBjb250YWluIGNoaWxkcmVuIGNvbHVtbnMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjaGlsZHJlbkNvbHVtbnMgPSAgdGhpcy5jb2x1bW4uYWxsQ2hpbGRyZW47XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldCBhbGxDaGlsZHJlbigpOiBJZ3hDb2x1bW5Db21wb25lbnRbXSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGV2ZWwgb2YgdGhlIGNvbHVtbiBpbiBhIGNvbHVtbiBncm91cC5cbiAgICAgKiBSZXR1cm5zIGAwYCBpZiB0aGUgY29sdW1uIGRvZXNuJ3QgaGF2ZSBhIGBwYXJlbnRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uTGV2ZWwgPSAgdGhpcy5jb2x1bW4ubGV2ZWw7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldCBsZXZlbCgpIHtcbiAgICAgICAgbGV0IHB0ciA9IHRoaXMucGFyZW50O1xuICAgICAgICBsZXQgbHZsID0gMDtcblxuICAgICAgICB3aGlsZSAocHRyKSB7XG4gICAgICAgICAgICBsdmwrKztcbiAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGx2bDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGlzTGFzdFBpbm5lZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5pc1Bpbm5pbmdUb1N0YXJ0ICYmXG4gICAgICAgICAgICB0aGlzLmdyaWQucGlubmVkQ29sdW1uc1t0aGlzLmdyaWQucGlubmVkQ29sdW1ucy5sZW5ndGggLSAxXSA9PT0gdGhpcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGlzRmlyc3RQaW5uZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHBpbm5lZENvbHMgPSB0aGlzLmdyaWQucGlubmVkQ29sdW1ucy5maWx0ZXIoeCA9PiAheC5jb2x1bW5Hcm91cCk7XG4gICAgICAgIHJldHVybiAhdGhpcy5ncmlkLmlzUGlubmluZ1RvU3RhcnQgJiYgcGlubmVkQ29sc1swXSA9PT0gdGhpcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHJpZ2h0UGlubmVkT2Zmc2V0KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpbm5lZCAmJiAhdGhpcy5ncmlkLmlzUGlubmluZ1RvU3RhcnQgP1xuICAgICAgICAgICAgLSB0aGlzLmdyaWQucGlubmVkV2lkdGggLSB0aGlzLmdyaWQuaGVhZGVyRmVhdHVyZXNXaWR0aCArICdweCcgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGdyaWRSb3dTcGFuKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd0VuZCAmJiB0aGlzLnJvd1N0YXJ0ID8gdGhpcy5yb3dFbmQgLSB0aGlzLnJvd1N0YXJ0IDogMTtcbiAgICB9XG4gICAgcHVibGljIGdldCBncmlkQ29sdW1uU3BhbigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xFbmQgJiYgdGhpcy5jb2xTdGFydCA/IHRoaXMuY29sRW5kIC0gdGhpcy5jb2xTdGFydCA6IDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbHVtbiB3aWxsIGJlIHZpc2libGUgd2hlbiBpdHMgcGFyZW50IGlzIGNvbGxhcHNlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4tZ3JvdXA+XG4gICAgICogICA8aWd4LWNvbHVtbiBbdmlzaWJsZVdoZW5Db2xsYXBzZWRdPVwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiA8L2lneC1jb2x1bW4tZ3JvdXA+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXModHJ1ZSlcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgdmlzaWJsZVdoZW5Db2xsYXBzZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fdmlzaWJsZVdoZW5Db2xsYXBzZWQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy52aXNpYmxlV2hlbkNvbGxhcHNlZENoYW5nZS5lbWl0KHRoaXMuX3Zpc2libGVXaGVuQ29sbGFwc2VkKTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5zZXRFeHBhbmRDb2xsYXBzZVN0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHZpc2libGVXaGVuQ29sbGFwc2VkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZVdoZW5Db2xsYXBzZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBQYXNzIG9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIERhdGVQaXBlIGFuZC9vciBEZWNpbWFsUGlwZSB0byBmb3JtYXQgdGhlIGRpc3BsYXkgdmFsdWUgZm9yIGRhdGUgYW5kIG51bWVyaWMgY29sdW1ucy5cbiAgICAgKiBBY2NlcHRzIGFuIGBJQ29sdW1uUGlwZUFyZ3NgIG9iamVjdCB3aXRoIGFueSBvZiB0aGUgYGZvcm1hdGAsIGB0aW1lem9uZWAgYW5kIGBkaWdpdHNJbmZvYCBwcm9wZXJ0aWVzLlxuICAgICAqIEZvciBtb3JlIGRldGFpbHMgc2VlIGh0dHBzOi8vYW5ndWxhci5pby9hcGkvY29tbW9uL0RhdGVQaXBlIGFuZCBodHRwczovL2FuZ3VsYXIuaW8vYXBpL2NvbW1vbi9EZWNpbWFsUGlwZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHBpcGVBcmdzOiBJQ29sdW1uUGlwZUFyZ3MgPSB7XG4gICAgICogICAgICBmb3JtYXQ6ICdsb25nRGF0ZScsXG4gICAgICogICAgICB0aW1lem9uZTogJ1VUQycsXG4gICAgICogICAgICBkaWdpdHNJbmZvOiAnMS4xLTInXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBkYXRhVHlwZT1cImRhdGVcIiBbcGlwZUFyZ3NdPVwicGlwZUFyZ3NcIj48L2lneC1jb2x1bW4+XG4gICAgICogPGlneC1jb2x1bW4gZGF0YVR5cGU9XCJudW1iZXJcIiBbcGlwZUFyZ3NdPVwicGlwZUFyZ3NcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgcGlwZUFyZ3ModmFsdWU6IElDb2x1bW5QaXBlQXJncykge1xuICAgICAgICB0aGlzLl9jb2x1bW5QaXBlQXJncyA9IE9iamVjdC5hc3NpZ24odGhpcy5fY29sdW1uUGlwZUFyZ3MsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5ncmlkLnN1bW1hcnlTZXJ2aWNlLmNsZWFyU3VtbWFyeUNhY2hlKCk7XG4gICAgICAgIHRoaXMuZ3JpZC5waXBlVHJpZ2dlcisrO1xuICAgIH1cbiAgICBwdWJsaWMgZ2V0IHBpcGVBcmdzKCk6IElDb2x1bW5QaXBlQXJncyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5QaXBlQXJncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBjb2xsYXBzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGNvbGxhcHNpYmxlKF92YWx1ZTogYm9vbGVhbikgeyB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBleHBhbmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgZXhwYW5kZWQoX3ZhbHVlOiBib29sZWFuKSB7IH1cblxuICAgIC8qKlxuICAgICAqIGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBkZWZhdWx0V2lkdGg6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyB3aWR0aFNldEJ5VXNlcjogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgaGFzTmVzdGVkUGF0aDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZGVmYXVsdFRpbWVGb3JtYXQgPSAnaGg6bW06c3MgdHQnO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBkZWZhdWx0RGF0ZVRpbWVGb3JtYXQgPSAnZGQvTU0veXl5eSBISDptbTpzcyB0dCc7XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSBvZiB0aGUgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgdHJlZSA9ICB0aGlzLmNvbHVtbi5maWx0ZXJpbmdFeHByZXNzaW9uc1RyZWU7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldCBmaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUoKTogRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5maWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUuZmluZCh0aGlzLmZpZWxkKSBhcyBGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgcGFyZW50IGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHBhcmVudENvbHVtbiA9IHRoaXMuY29sdW1uLnBhcmVudDtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5jb2x1bW4ucGFyZW50ID0gaGlnaGVyTGV2ZWxDb2x1bW47XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHBhcmVudCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBjaGlsZHJlbiBjb2x1bW5zLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uQ2hpbGRyZW4gPSB0aGlzLmNvbHVtbi5jaGlsZHJlbjtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5jb2x1bW4uY2hpbGRyZW4gPSBjaGlsZHJlbkNvbHVtbnM7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGNoaWxkcmVuOiBRdWVyeUxpc3Q8SWd4Q29sdW1uQ29tcG9uZW50PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfYXBwbHlTZWxlY3RhYmxlQ2xhc3MgPSBmYWxzZTtcblxuICAgIHByb3RlY3RlZCBfdkluZGV4ID0gTmFOO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3Bpbm5lZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2JvZHlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9oZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9pbmxpbmVFZGl0b3JUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9maWx0ZXJDZWxsVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfc3VtbWFyaWVzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9maWx0ZXJzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9zb3J0U3RyYXRlZ3k6IElTb3J0aW5nU3RyYXRlZ3kgPSBEZWZhdWx0U29ydGluZ1N0cmF0ZWd5Lmluc3RhbmNlKCk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZ3JvdXBpbmdDb21wYXJlcjogKGE6IGFueSwgYjogYW55KSA9PiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfaGlkZGVuID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfaW5kZXg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kaXNhYmxlUGlubmluZyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3dpZHRoOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZGVmYXVsdE1pbldpZHRoID0gJyc7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfaGFzU3VtbWFyeSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2VkaXRhYmxlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqICBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF92aXNpYmxlV2hlbkNvbGxhcHNlZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9jb2xsYXBzaWJsZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2V4cGFuZGVkID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9zZWxlY3RhYmxlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldCBpc1ByaW1hcnlDb2x1bW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ncmlkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maWVsZCA9PT0gdGhpcy5ncmlkLnByaW1hcnlLZXk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZmllbGQ6IHN0cmluZztcbiAgICBwcml2YXRlIF9jYWxjV2lkdGggPSBudWxsO1xuICAgIHByaXZhdGUgX2NvbHVtblBpcGVBcmdzOiBJQ29sdW1uUGlwZUFyZ3MgPSB7IGRpZ2l0c0luZm86IERFRkFVTFRfRElHSVRTX0lORk8gfTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgZ3JpZEFQSTogR3JpZEJhc2VBUElTZXJ2aWNlPElneEdyaWRCYXNlRGlyZWN0aXZlICYgR3JpZFR5cGU+LFxuICAgICAgICBwdWJsaWMgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHJvdGVjdGVkIHBsYXRmb3JtOiBQbGF0Zm9ybVV0aWwsXG4gICAgKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVzZXRDYWNoZXMoKSB7XG4gICAgICAgIHRoaXMuX3ZJbmRleCA9IE5hTjtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZUNhbGNXaWR0aCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jZWxsVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2JvZHlUZW1wbGF0ZSA9IHRoaXMuY2VsbFRlbXBsYXRlLnRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlYWRUZW1wbGF0ZSAmJiB0aGlzLmhlYWRUZW1wbGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclRlbXBsYXRlID0gdGhpcy5oZWFkVGVtcGxhdGUudG9BcnJheSgpWzBdLnRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVkaXRvclRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbmxpbmVFZGl0b3JUZW1wbGF0ZSA9IHRoaXMuZWRpdG9yVGVtcGxhdGUudGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJDZWxsVGVtcGxhdGUgPSB0aGlzLmZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NvbHVtblBpcGVBcmdzLmZvcm1hdCkge1xuICAgICAgICAgICAgdGhpcy5fY29sdW1uUGlwZUFyZ3MuZm9ybWF0ID0gdGhpcy5kYXRhVHlwZSA9PT0gR3JpZENvbHVtbkRhdGFUeXBlLlRpbWUgP1xuICAgICAgICAgICAgICAgIERFRkFVTFRfVElNRV9GT1JNQVQgOiB0aGlzLmRhdGFUeXBlID09PSBHcmlkQ29sdW1uRGF0YVR5cGUuRGF0ZVRpbWUgP1xuICAgICAgICAgICAgICAgICAgICBERUZBVUxUX0RBVEVfVElNRV9GT1JNQVQgOiBERUZBVUxUX0RBVEVfRk9STUFUO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zdW1tYXJpZXMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXRhVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgR3JpZENvbHVtbkRhdGFUeXBlLlN0cmluZzpcbiAgICAgICAgICAgICAgICBjYXNlIEdyaWRDb2x1bW5EYXRhVHlwZS5Cb29sZWFuOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1bW1hcmllcyA9IElneFN1bW1hcnlPcGVyYW5kO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEdyaWRDb2x1bW5EYXRhVHlwZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgY2FzZSBHcmlkQ29sdW1uRGF0YVR5cGUuQ3VycmVuY3k6XG4gICAgICAgICAgICAgICAgY2FzZSBHcmlkQ29sdW1uRGF0YVR5cGUuUGVyY2VudDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdW1tYXJpZXMgPSBJZ3hOdW1iZXJTdW1tYXJ5T3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBHcmlkQ29sdW1uRGF0YVR5cGUuRGF0ZTpcbiAgICAgICAgICAgICAgICBjYXNlIEdyaWRDb2x1bW5EYXRhVHlwZS5EYXRlVGltZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdW1tYXJpZXMgPSBJZ3hEYXRlU3VtbWFyeU9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgR3JpZENvbHVtbkRhdGFUeXBlLlRpbWU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyaWVzID0gSWd4VGltZVN1bW1hcnlPcGVyYW5kO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1bW1hcmllcyA9IElneFN1bW1hcnlPcGVyYW5kO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZmlsdGVycykge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRhdGFUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBHcmlkQ29sdW1uRGF0YVR5cGUuQm9vbGVhbjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gSWd4Qm9vbGVhbkZpbHRlcmluZ09wZXJhbmQuaW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBHcmlkQ29sdW1uRGF0YVR5cGUuTnVtYmVyOlxuICAgICAgICAgICAgICAgIGNhc2UgR3JpZENvbHVtbkRhdGFUeXBlLkN1cnJlbmN5OlxuICAgICAgICAgICAgICAgIGNhc2UgR3JpZENvbHVtbkRhdGFUeXBlLlBlcmNlbnQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVycyA9IElneE51bWJlckZpbHRlcmluZ09wZXJhbmQuaW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBHcmlkQ29sdW1uRGF0YVR5cGUuRGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gSWd4RGF0ZUZpbHRlcmluZ09wZXJhbmQuaW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBHcmlkQ29sdW1uRGF0YVR5cGUuVGltZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gSWd4VGltZUZpbHRlcmluZ09wZXJhbmQuaW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBHcmlkQ29sdW1uRGF0YVR5cGUuRGF0ZVRpbWU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVycyA9IElneERhdGVUaW1lRmlsdGVyaW5nT3BlcmFuZC5pbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEdyaWRDb2x1bW5EYXRhVHlwZS5TdHJpbmc6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gSWd4U3RyaW5nRmlsdGVyaW5nT3BlcmFuZC5pbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0R3JpZFRlbXBsYXRlKGlzUm93OiBib29sZWFuLCBpc0lFOiBib29sZWFuKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKGlzUm93KSB7XG4gICAgICAgICAgICBjb25zdCByb3dzQ291bnQgPSB0aGlzLmdyaWQubXVsdGlSb3dMYXlvdXRSb3dTaXplO1xuICAgICAgICAgICAgcmV0dXJuIGlzSUUgP1xuICAgICAgICAgICAgICAgIGAoMWZyKVske3Jvd3NDb3VudH1dYCA6XG4gICAgICAgICAgICAgICAgYHJlcGVhdCgke3Jvd3NDb3VudH0sMWZyKWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW5TaXplc1N0cmluZyh0aGlzLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRJbml0aWFsQ2hpbGRDb2x1bW5TaXplcyhjaGlsZHJlbjogUXVlcnlMaXN0PElneENvbHVtbkNvbXBvbmVudD4pOiBBcnJheTxNUkxDb2x1bW5TaXplSW5mbz4ge1xuICAgICAgICBjb25zdCBjb2x1bW5TaXplczogTVJMQ29sdW1uU2l6ZUluZm9bXSA9IFtdO1xuICAgICAgICAvLyBmaW5kIHRoZSBzbWFsbGVzdCBjb2wgc3BhbnNcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjb2wgPT4ge1xuICAgICAgICAgICAgaWYgKCFjb2wuY29sU3RhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdXaWR0aFNldCA9IGNvbC53aWR0aFNldEJ5VXNlciAmJiBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXSAmJiAhY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0ud2lkdGhTZXRCeVVzZXI7XG4gICAgICAgICAgICBjb25zdCBuZXdTcGFuU21hbGxlciA9IGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdICYmIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLmNvbFNwYW4gPiBjb2wuZ3JpZENvbHVtblNwYW47XG4gICAgICAgICAgICBjb25zdCBib3RoV2lkdGhzU2V0ID0gY29sLndpZHRoU2V0QnlVc2VyICYmIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdICYmIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLndpZHRoU2V0QnlVc2VyO1xuICAgICAgICAgICAgY29uc3QgYm90aFdpZHRoc05vdFNldCA9ICFjb2wud2lkdGhTZXRCeVVzZXIgJiYgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0gJiYgIWNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLndpZHRoU2V0QnlVc2VyO1xuXG4gICAgICAgICAgICBpZiAoY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vdGhpbmcgaXMgZGVmaW5lZCB5ZXQgdGFrZSBhbnkgY29sdW1uIGF0IGZpcnN0XG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIGNvbEVuZCB0byBrbm93IHdoZXJlIHRoZSBjb2x1bW4gYWN0dWFsbHkgZW5kcywgYmVjYXVzZSBub3QgYWx3YXlzIGl0IHN0YXJ0cyB3aGVyZSB3ZSBoYXZlIGl0IHNldCBpbiBjb2x1bW5TaXplcy5cbiAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2wud2lkdGhTZXRCeVVzZXIgfHwgdGhpcy5ncmlkLmNvbHVtbldpZHRoU2V0QnlVc2VyID8gcGFyc2VJbnQoY29sLmNhbGNXaWR0aCwgMTApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY29sU3BhbjogY29sLmdyaWRDb2x1bW5TcGFuLFxuICAgICAgICAgICAgICAgICAgICBjb2xFbmQ6IGNvbC5jb2xTdGFydCArIGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhTZXRCeVVzZXI6IGNvbC53aWR0aFNldEJ5VXNlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1dpZHRoU2V0IHx8IChuZXdTcGFuU21hbGxlciAmJiAoKGJvdGhXaWR0aHNTZXQpIHx8IChib3RoV2lkdGhzTm90U2V0KSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBjb2x1bW4gaXMgc2V0IGFscmVhZHkgaXQgc2hvdWxkIGVpdGhlciBub3QgaGF2ZSB3aWR0aCBkZWZpbmVkIG9yIGhhdmUgd2lkdGggd2l0aCBiaWdnZXIgc3BhbiB0aGFuIHRoZSBuZXcgb25lLlxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogIElmIHJlcGxhY2VkIGNvbHVtbiBoYXMgYmlnZ2VyIHNwYW4sIHdlIHdhbnQgdG8gZmlsbCB0aGUgcmVtYWluaW5nIGNvbHVtbnNcbiAgICAgICAgICAgICAgICAgKiAgdGhhdCB0aGUgcmVwbGFjaW5nIGNvbHVtbiBkb2VzIG5vdCBmaWxsIHdpdGggdGhlIG9sZCBvbmUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGJvdGhXaWR0aHNTZXQgJiYgbmV3U3BhblNtYWxsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSB3aGVyZSB0aGUgbmV3IGNvbHVtbiBzZXQgd291bGQgZW5kIGFuZCBhcHBseSB0aGUgb2xkIGNvbHVtbiB0byB0aGUgcmVzdCBkZXBlbmRpbmcgb24gaG93IG11Y2ggaXQgc3BhbnMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgbm90IHlldCByZXBsYWNlZCBpdCBzbyB3ZSBjYW4gdXNlIGl0IGRpcmVjdGx5IGZyb20gdGhlIGNvbHVtblNpemVzIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgd2hlcmUgY29sRW5kIGlzIHVzZWQgYmVjYXVzZSB0aGUgY29sU3RhcnQgb2YgdGhlIG9sZCBjb2x1bW4gaXMgbm90IGFjdHVhbGx5IGkgKyAxLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gY29sLmNvbFN0YXJ0IC0gMSArIGNvbC5ncmlkQ29sdW1uU3BhbjsgaSA8IGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLmNvbEVuZCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2x1bW5TaXplc1tpXSB8fCAhY29sdW1uU2l6ZXNbaV0ud2lkdGhTZXRCeVVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXSA9IGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIG9sZCBjb2x1bW4gd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2wud2lkdGhTZXRCeVVzZXIgfHwgdGhpcy5ncmlkLmNvbHVtbldpZHRoU2V0QnlVc2VyID8gcGFyc2VJbnQoY29sLmNhbGNXaWR0aCwgMTApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY29sU3BhbjogY29sLmdyaWRDb2x1bW5TcGFuLFxuICAgICAgICAgICAgICAgICAgICBjb2xFbmQ6IGNvbC5jb2xTdGFydCArIGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhTZXRCeVVzZXI6IGNvbC53aWR0aFNldEJ5VXNlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJvdGhXaWR0aHNTZXQgJiYgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0uY29sU3BhbiA8IGNvbC5ncmlkQ29sdW1uU3Bhbikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gYWxyZWFkeSBpbiB0aGUgY29sdW1uU2l6ZXMgaGFzIHNtYWxsZXIgc3Bhbiwgd2Ugc3RpbGwgbmVlZCB0byBmaWxsIGFueSBlbXB0eSBwbGFjZXMgd2l0aCB0aGUgY3VycmVudCBjb2wuXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSB3aGVyZSB0aGUgc21hbGxlciBjb2x1bW4gc2V0IHdvdWxkIGVuZCBhbmQgYXBwbHkgdGhlIGJpZ2dlciBjb2x1bW4gdG8gdGhlIHJlc3QgZGVwZW5kaW5nIG9uIGhvdyBtdWNoIGl0IHNwYW5zLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIGhlcmUgd2UgZG8gbm90IGhhdmUgaXQgaW4gY29sdW1uU2l6ZXMgd2Ugc2V0IGl0IGFzIGEgbmV3IGNvbHVtbiBrZWVwaW5nIHRoZSBzYW1lIGNvbFNwYW4uXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbC5jb2xTdGFydCAtIDEgKyBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXS5jb2xTcGFuOyBpIDwgY29sLmNvbFN0YXJ0IC0gMSArIGNvbC5ncmlkQ29sdW1uU3BhbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29sdW1uU2l6ZXNbaV0gfHwgIWNvbHVtblNpemVzW2ldLndpZHRoU2V0QnlVc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29sLndpZHRoU2V0QnlVc2VyIHx8IHRoaXMuZ3JpZC5jb2x1bW5XaWR0aFNldEJ5VXNlciA/IHBhcnNlSW50KGNvbC5jYWxjV2lkdGgsIDEwKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sU3BhbjogY29sLmdyaWRDb2x1bW5TcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbEVuZDogY29sLmNvbFN0YXJ0ICsgY29sLmdyaWRDb2x1bW5TcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoU2V0QnlVc2VyOiBjb2wud2lkdGhTZXRCeVVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmxhdHRlbiBjb2x1bW5TaXplcyBzbyB0aGVyZSBhcmUgbm90IGNvbHVtbnMgd2l0aCBjb2xTcGFuID4gMVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtblNpemVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29sdW1uU2l6ZXNbaV0gJiYgY29sdW1uU2l6ZXNbaV0uY29sU3BhbiA+IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgaiA9IDE7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGFsbCBlbXB0eSBwbGFjZXMgZGVwZW5kaW5nIG9uIGhvdyBtdWNoIHRoZSBjdXJyZW50IGNvbHVtbiBzcGFucyBzdGFydGluZyBmcm9tIG5leHQgY29sLlxuICAgICAgICAgICAgICAgIGZvciAoOyBqIDwgY29sdW1uU2l6ZXNbaV0uY29sU3BhbiAmJiBpICsgaiArIDEgPCBjb2x1bW5TaXplc1tpXS5jb2xFbmQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uU2l6ZXNbaSArIGpdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoKCFjb2x1bW5TaXplc1tpXS53aWR0aCAmJiBjb2x1bW5TaXplc1tpICsgal0ud2lkdGgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFjb2x1bW5TaXplc1tpXS53aWR0aCAmJiAhY29sdW1uU2l6ZXNbaSArIGpdLndpZHRoICYmIGNvbHVtblNpemVzW2kgKyBqXS5jb2xTcGFuIDw9IGNvbHVtblNpemVzW2ldLmNvbFNwYW4pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCEhY29sdW1uU2l6ZXNbaSArIGpdLndpZHRoICYmIGNvbHVtblNpemVzW2kgKyBqXS5jb2xTcGFuIDw9IGNvbHVtblNpemVzW2ldLmNvbFNwYW4pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2ggYW4gYWxyZWFkeSBkZWZpbmVkIGNvbHVtbiB0aGF0IGhhcyB3aWR0aCBhbmQgdGhlIGN1cnJlbnQgZG9lc24ndCBoYXZlIG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcmVhY2hlZCBjb2x1bW4gaGFzIGJpZ2dlciBjb2xTcGFuIHdlIHN0b3AuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gY29sdW1uU2l6ZXNbaV0ud2lkdGhTZXRCeVVzZXIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2ldLndpZHRoIC8gY29sdW1uU2l6ZXNbaV0uY29sU3BhbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uU2l6ZXNbaV0ud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpICsgal0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBjb2x1bW5TaXplc1tpXS5yZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sU3BhbjogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xFbmQ6IGNvbHVtblNpemVzW2ldLmNvbEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aFNldEJ5VXNlcjogY29sdW1uU2l6ZXNbaV0ud2lkdGhTZXRCeVVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgY29sdW1uIHdpZHRoIHNvIGl0IGlzIGRpdmlkZWQgYmV0d2VlbiBhbGwgY29sdW1ucyBpdCBzcGFucyBhbmQgc2V0IGl0IHRvIDEuXG4gICAgICAgICAgICAgICAgY29sdW1uU2l6ZXNbaV0ud2lkdGggPSBjb2x1bW5TaXplc1tpXS53aWR0aFNldEJ5VXNlciA/XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2ldLndpZHRoIC8gY29sdW1uU2l6ZXNbaV0uY29sU3BhbiA6XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2ldLndpZHRoO1xuICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2ldLmNvbFNwYW4gPSAxO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbmRleCBiYXNlZCBvbiBob3cgbXVjaCB3ZSBoYXZlIHJlcGxhY2VkLiBTdWJ0cmFjdCAxIGJlY2F1c2Ugd2Ugc3RhcnRlZCBmcm9tIDEuXG4gICAgICAgICAgICAgICAgaSArPSBqIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb2x1bW5TaXplcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0RmlsbGVkQ2hpbGRDb2x1bW5TaXplcyhjaGlsZHJlbjogUXVlcnlMaXN0PElneENvbHVtbkNvbXBvbmVudD4pOiBBcnJheTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgY29sdW1uU2l6ZXMgPSB0aGlzLmdldEluaXRpYWxDaGlsZENvbHVtblNpemVzKGNoaWxkcmVuKTtcblxuICAgICAgICAvLyBmaWxsIHRoZSBnYXBzIGlmIHRoZXJlIGFyZSBhbnlcbiAgICAgICAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHNpemUgb2YgY29sdW1uU2l6ZXMpIHtcbiAgICAgICAgICAgIGlmIChzaXplICYmICEhc2l6ZS53aWR0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNpemUud2lkdGggKyAncHgnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQodGhpcy5ncmlkLmdldFBvc3NpYmxlQ29sdW1uV2lkdGgoKSwgMTApICsgJ3B4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UmVzaXphYmxlQ29sVW5kZXJFbmQoKTogTVJMUmVzaXplQ29sdW1uSW5mb1tdIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uTGF5b3V0IHx8ICF0aGlzLmNvbHVtbkxheW91dENoaWxkIHx8IHRoaXMuY29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiBbeyB0YXJnZXQ6IHRoaXMsIHNwYW5Vc2VkOiAxIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29sdW1uU2l6ZWQgPSB0aGlzLmdldEluaXRpYWxDaGlsZENvbHVtblNpemVzKHRoaXMucGFyZW50LmNoaWxkcmVuKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0czogTVJMUmVzaXplQ29sdW1uSW5mb1tdID0gW107XG4gICAgICAgIGNvbnN0IGNvbEVuZCA9IHRoaXMuY29sRW5kID8gdGhpcy5jb2xFbmQgOiB0aGlzLmNvbFN0YXJ0ICsgMTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtblNpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xTdGFydCA8PSBpICsgMSAmJiBpICsgMSA8IGNvbEVuZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldHMucHVzaCh7IHRhcmdldDogY29sdW1uU2l6ZWRbaV0ucmVmLCBzcGFuVXNlZDogMSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldHNTcXVhc2hlZDogTVJMUmVzaXplQ29sdW1uSW5mb1tdID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRzU3F1YXNoZWQubGVuZ3RoICYmIHRhcmdldHNTcXVhc2hlZFt0YXJnZXRzU3F1YXNoZWQubGVuZ3RoIC0gMV0udGFyZ2V0LmZpZWxkID09PSB0YXJnZXQudGFyZ2V0LmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0c1NxdWFzaGVkW3RhcmdldHNTcXVhc2hlZC5sZW5ndGggLSAxXS5zcGFuVXNlZCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzU3F1YXNoZWQucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldHNTcXVhc2hlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQaW5zIHRoZSBjb2x1bW4gYXQgdGhlIHByb3ZpZGVkIGluZGV4IGluIHRoZSBwaW5uZWQgYXJlYS5cbiAgICAgKiBEZWZhdWx0cyB0byBpbmRleCBgMGAgaWYgbm90IHByb3ZpZGVkLCBvciB0byB0aGUgaW5pdGlhbCBpbmRleCBpbiB0aGUgcGlubmVkIGFyZWEuXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbHVtbiBpcyBzdWNjZXNzZnVsbHkgcGlubmVkLiBSZXR1cm5zIGBmYWxzZWAgaWYgdGhlIGNvbHVtbiBjYW5ub3QgYmUgcGlubmVkLlxuICAgICAqIENvbHVtbiBjYW5ub3QgYmUgcGlubmVkIGlmOlxuICAgICAqIC0gSXMgYWxyZWFkeSBwaW5uZWRcbiAgICAgKiAtIGluZGV4IGFyZ3VtZW50IGlzIG91dCBvZiByYW5nZVxuICAgICAqIC0gVGhlIHBpbm5lZCBhcmVhIGV4Y2VlZHMgODAlIG9mIHRoZSBncmlkIHdpZHRoXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBzdWNjZXNzID0gdGhpcy5jb2x1bW4ucGluKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHBpbihpbmRleD86IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgdGhlIHJldHVybiB0eXBlIG9mIHRoZSBvbGQgZnVuY3Rpb25zXG4gICAgICAgIC8vIHNob3VsZCBiZSBtb3ZlZCBhcyBhIGV2ZW50IHBhcmFtZXRlci5cbiAgICAgICAgY29uc3QgZ3JpZCA9ICh0aGlzLmdyaWQgYXMgYW55KTtcbiAgICAgICAgaWYgKHRoaXMuX3Bpbm5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmICF0aGlzLnBhcmVudC5waW5uZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcExldmVsUGFyZW50LnBpbihpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoYXNJbmRleCA9IGluZGV4ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChoYXNJbmRleCAmJiAoaW5kZXggPCAwIHx8IGluZGV4ID4gZ3JpZC5waW5uZWRDb2x1bW5zLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQgJiYgIXRoaXMucGlubmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJvb3RQaW5uZWRDb2xzID0gZ3JpZC5fcGlubmVkQ29sdW1ucy5maWx0ZXIoKGMpID0+IGMubGV2ZWwgPT09IDApO1xuICAgICAgICBpbmRleCA9IGhhc0luZGV4ID8gaW5kZXggOiByb290UGlubmVkQ29scy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGFyZ3M6IElQaW5Db2x1bW5DYW5jZWxsYWJsZUV2ZW50QXJncyA9IHsgY29sdW1uOiB0aGlzLCBpbnNlcnRBdEluZGV4OiBpbmRleCwgaXNQaW5uZWQ6IGZhbHNlLCBjYW5jZWw6IGZhbHNlIH07XG4gICAgICAgIHRoaXMuZ3JpZC5jb2x1bW5QaW4uZW1pdChhcmdzKTtcblxuICAgICAgICBpZiAoYXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JpZC5jcnVkU2VydmljZS5lbmRFZGl0KGZhbHNlKTtcblxuICAgICAgICB0aGlzLl9waW5uZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnBpbm5lZENoYW5nZS5lbWl0KHRoaXMuX3Bpbm5lZCk7XG4gICAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIHRoYXQgaW5kZXggaXMgdGhlIGxhc3QgcG9zaXRpb24sIHNvIHdpbGwgbmVlZCB0byBmaW5kIHRhcmdldCBjb2x1bW4gYnkgW2luZGV4LTFdXG4gICAgICAgIGNvbnN0IHRhcmdldENvbHVtbiA9IGFyZ3MuaW5zZXJ0QXRJbmRleCA9PT0gZ3JpZC5fcGlubmVkQ29sdW1ucy5sZW5ndGggP1xuICAgICAgICAgICAgZ3JpZC5fcGlubmVkQ29sdW1uc1thcmdzLmluc2VydEF0SW5kZXggLSAxXSA6IGdyaWQuX3Bpbm5lZENvbHVtbnNbYXJncy5pbnNlcnRBdEluZGV4XTtcblxuICAgICAgICBpZiAoZ3JpZC5fcGlubmVkQ29sdW1ucy5pbmRleE9mKHRoaXMpID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKCFncmlkLmhhc0NvbHVtbkdyb3Vwcykge1xuICAgICAgICAgICAgICAgIGdyaWQuX3Bpbm5lZENvbHVtbnMuc3BsaWNlKGFyZ3MuaW5zZXJ0QXRJbmRleCwgMCwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGluc2VydCBiYXNlZCBvbmx5IG9uIHJvb3QgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgIHJvb3RQaW5uZWRDb2xzLnNwbGljZShhcmdzLmluc2VydEF0SW5kZXgsIDAsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGxldCBhbGxQaW5uZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyByZS1jcmVhdGUgaGllcmFyY2h5XG4gICAgICAgICAgICAgICAgcm9vdFBpbm5lZENvbHMuZm9yRWFjaChncm91cCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFsbFBpbm5lZC5wdXNoKGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsUGlubmVkID0gYWxsUGlubmVkLmNvbmNhdChncm91cC5hbGxDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZ3JpZC5fcGlubmVkQ29sdW1ucyA9IGFsbFBpbm5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdyaWQuX3VucGlubmVkQ29sdW1ucy5pbmRleE9mKHRoaXMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuQ291bnQgPSB0aGlzLmFsbENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBncmlkLl91bnBpbm5lZENvbHVtbnMuc3BsaWNlKGdyaWQuX3VucGlubmVkQ29sdW1ucy5pbmRleE9mKHRoaXMpLCAxICsgY2hpbGRyZW5Db3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzSW5kZXgpIHtcbiAgICAgICAgICAgIGdyaWQuX21vdmVDb2x1bW5zKHRoaXMsIHRhcmdldENvbHVtbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgdGhpcy5hbGxDaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLnBpbigpKTtcbiAgICAgICAgICAgIGdyaWQucmVpbml0UGluU3RhdGVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLnJlc2V0Q2FjaGVzKCk7XG4gICAgICAgIGdyaWQubm90aWZ5Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5MYXlvdXRDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmNvbHVtbnMuZmlsdGVyKHggPT4geC5jb2x1bW5MYXlvdXQpLmZvckVhY2goeCA9PiB4LnBvcHVsYXRlVmlzaWJsZUluZGV4ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmlkLmZpbHRlcmluZ1NlcnZpY2UucmVmcmVzaEV4cHJlc3Npb25zKCk7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJnczogSVBpbkNvbHVtbkV2ZW50QXJncyA9IHsgY29sdW1uOiB0aGlzLCBpbnNlcnRBdEluZGV4OiBpbmRleCwgaXNQaW5uZWQ6IHRydWUgfTtcbiAgICAgICAgdGhpcy5ncmlkLmNvbHVtblBpbm5lZC5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnBpbnMgdGhlIGNvbHVtbiBhbmQgcGxhY2UgaXQgYXQgdGhlIHByb3ZpZGVkIGluZGV4IGluIHRoZSB1bnBpbm5lZCBhcmVhLlxuICAgICAqIERlZmF1bHRzIHRvIGluZGV4IGAwYCBpZiBub3QgcHJvdmlkZWQsIG9yIHRvIHRoZSBpbml0aWFsIGluZGV4IGluIHRoZSB1bnBpbm5lZCBhcmVhLlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBjb2x1bW4gaXMgc3VjY2Vzc2Z1bGx5IHVucGlubmVkLiBSZXR1cm5zIGBmYWxzZWAgaWYgdGhlIGNvbHVtbiBjYW5ub3QgYmUgdW5waW5uZWQuXG4gICAgICogQ29sdW1uIGNhbm5vdCBiZSB1bnBpbm5lZCBpZjpcbiAgICAgKiAtIElzIGFscmVhZHkgdW5waW5uZWRcbiAgICAgKiAtIGluZGV4IGFyZ3VtZW50IGlzIG91dCBvZiByYW5nZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgc3VjY2VzcyA9IHRoaXMuY29sdW1uLnVucGluKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHVucGluKGluZGV4PzogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGdyaWQgPSAodGhpcy5ncmlkIGFzIGFueSk7XG4gICAgICAgIGlmICghdGhpcy5fcGlubmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucGlubmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3BMZXZlbFBhcmVudC51bnBpbihpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzSW5kZXggPSBpbmRleCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaGFzSW5kZXggJiYgKGluZGV4IDwgMCB8fCBpbmRleCA+IGdyaWQuX3VucGlubmVkQ29sdW1ucy5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlc3RpbWF0ZSB0aGUgZXhhY3QgaW5kZXggYXQgd2hpY2ggY29sdW1uIHdpbGwgYmUgaW5zZXJ0ZWRcbiAgICAgICAgLy8gdGFrZXMgaW50byBhY2NvdW50IGluaXRpYWwgdW5waW5uZWQgaW5kZXggb2YgdGhlIGNvbHVtblxuICAgICAgICBpZiAoIWhhc0luZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gZ3JpZC51bnBpbm5lZENvbHVtbnMubWFwKGNvbCA9PiBjb2wuaW5kZXgpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgaW5kaWNlcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgICAgICBpbmRleCA9IGluZGljZXMuaW5kZXhPZih0aGlzLmluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFyZ3M6IElQaW5Db2x1bW5DYW5jZWxsYWJsZUV2ZW50QXJncyA9IHsgY29sdW1uOiB0aGlzLCBpbnNlcnRBdEluZGV4OiBpbmRleCwgaXNQaW5uZWQ6IHRydWUsIGNhbmNlbDogZmFsc2UgfTtcbiAgICAgICAgdGhpcy5ncmlkLmNvbHVtblBpbi5lbWl0KGFyZ3MpO1xuXG4gICAgICAgIGlmIChhcmdzLmNhbmNlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmlkLmNydWRTZXJ2aWNlLmVuZEVkaXQoZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuX3Bpbm5lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBpbm5lZENoYW5nZS5lbWl0KHRoaXMuX3Bpbm5lZCk7XG5cbiAgICAgICAgLy8gaXQgaXMgcG9zc2libGUgdGhhdCBpbmRleCBpcyB0aGUgbGFzdCBwb3NpdGlvbiwgc28gd2lsbCBuZWVkIHRvIGZpbmQgdGFyZ2V0IGNvbHVtbiBieSBbaW5kZXgtMV1cbiAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uID0gYXJncy5pbnNlcnRBdEluZGV4ID09PSBncmlkLl91bnBpbm5lZENvbHVtbnMubGVuZ3RoID9cbiAgICAgICAgICAgIGdyaWQuX3VucGlubmVkQ29sdW1uc1thcmdzLmluc2VydEF0SW5kZXggLSAxXSA6IGdyaWQuX3VucGlubmVkQ29sdW1uc1thcmdzLmluc2VydEF0SW5kZXhdO1xuXG4gICAgICAgIGlmICghaGFzSW5kZXgpIHtcbiAgICAgICAgICAgIGdyaWQuX3VucGlubmVkQ29sdW1ucy5zcGxpY2UoaW5kZXgsIDAsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKGdyaWQuX3Bpbm5lZENvbHVtbnMuaW5kZXhPZih0aGlzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBncmlkLl9waW5uZWRDb2x1bW5zLnNwbGljZShncmlkLl9waW5uZWRDb2x1bW5zLmluZGV4T2YodGhpcyksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0luZGV4KSB7XG4gICAgICAgICAgICBncmlkLm1vdmVDb2x1bW4odGhpcywgdGFyZ2V0Q29sdW1uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICB0aGlzLmFsbENoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQudW5waW4oKSk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLnJlaW5pdFBpblN0YXRlcygpO1xuICAgICAgICBncmlkLnJlc2V0Q2FjaGVzKCk7XG5cbiAgICAgICAgZ3JpZC5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkxheW91dENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuY29sdW1ucy5maWx0ZXIoeCA9PiB4LmNvbHVtbkxheW91dCkuZm9yRWFjaCh4ID0+IHgucG9wdWxhdGVWaXNpYmxlSW5kZXhlcygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyaWQuZmlsdGVyaW5nU2VydmljZS5yZWZyZXNoRXhwcmVzc2lvbnMoKTtcblxuICAgICAgICB0aGlzLmdyaWQuY29sdW1uUGlubmVkLmVtaXQoeyBjb2x1bW46IHRoaXMsIGluc2VydEF0SW5kZXg6IGluZGV4LCBpc1Bpbm5lZDogZmFsc2UgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYSBjb2x1bW4gdG8gdGhlIHNwZWNpZmllZCB2aXNpYmxlIGluZGV4LlxuICAgICAqIElmIHBhc3NlZCBpbmRleCBpcyBpbnZhbGlkLCBvciBpZiBjb2x1bW4gd291bGQgcmVjZWl2ZSBhIGRpZmZlcmVudCB2aXNpYmxlIGluZGV4IGFmdGVyIG1vdmluZywgbW92aW5nIGlzIG5vdCBwZXJmb3JtZWQuXG4gICAgICogSWYgcGFzc2VkIGluZGV4IHdvdWxkIG1vdmUgdGhlIGNvbHVtbiB0byBhIGRpZmZlcmVudCBjb2x1bW4gZ3JvdXAuIG1vdmluZyBpcyBub3QgcGVyZm9ybWVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29sdW1uLm1vdmUoaW5kZXgpO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgbW92ZShpbmRleDogbnVtYmVyKSB7XG4gICAgICAgIGxldCB0YXJnZXQ7XG4gICAgICAgIGNvbnN0IGdyaWQgPSAodGhpcy5ncmlkIGFzIElneEdyaWRCYXNlRGlyZWN0aXZlKTtcbiAgICAgICAgbGV0IGNvbHVtbnM6IEFycmF5PElneENvbHVtbkNvbXBvbmVudCB8IElneENvbHVtbkdyb3VwQ29tcG9uZW50PiA9IGdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLnZpc2libGVJbmRleCA+IC0xKTtcbiAgICAgICAgLy8gZ3JpZCBsYXN0IHZpc2libGUgaW5kZXhcbiAgICAgICAgY29uc3QgbGkgPSBjb2x1bW5zLm1hcChjID0+IGMudmlzaWJsZUluZGV4KS5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWF4KGEsIGIpKTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGNvbnN0IGlzUHJlY2VkaW5nID0gdGhpcy52aXNpYmxlSW5kZXggPCBpbmRleDtcblxuICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMudmlzaWJsZUluZGV4IHx8IGluZGV4IDwgMCB8fCBpbmRleCA+IGxpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBjb2x1bW5zID0gY29sdW1ucy5maWx0ZXIoYyA9PiBjLmxldmVsID49IHRoaXMubGV2ZWwgJiYgYyAhPT0gdGhpcyAmJiBjLnBhcmVudCAhPT0gdGhpcyAmJlxuICAgICAgICAgICAgICAgIGMudG9wTGV2ZWxQYXJlbnQgPT09IHRoaXMudG9wTGV2ZWxQYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICAgICAgLy8gSWYgaXNQcmVjZWRpbmcsIGZpbmQgYSB0YXJnZXQgc3VjaCB0aGF0IHdoZW4gdGhlIGN1cnJlbnQgY29sdW1uIGlzIHBsYWNlZCBhZnRlciBpdCwgY3VycmVudCBjb2x1bW1uIHdpbGwgcmVjZWl2ZSBhIHZpc2libGVJbmRleCA9PT0gaW5kZXguIFRoaXMgdGFrZXMgaW50byBhY2NvdW50IHZpc2libGUgY2hpbGRyZW4gb2YgdGhlIGNvbHVtbnMuXG4gICAgICAgIC8vIElmICFpc1ByZWNlZGluZywgZmluZHMgYSBjb2x1bW4gb2YgdGhlIHNhbWUgbGV2ZWwgYW5kIHZpc2libGUgaW5kZXggdGhhdCBlcXVhbHMgdGhlIHBhc3NlZCBpbmRleCBhZ3VtZW50IChjLnZpc2libGVJbmRleCA9PT0gaW5kZXgpLiBObyBuZWVkIHRvIGNvbnNpZGVyIHRoZSBjaGlsZHJlbiBoZXJlLlxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgICAgICAgaWYgKGlzUHJlY2VkaW5nKSB7XG4gICAgICAgICAgICBjb2x1bW5zID0gY29sdW1ucy5maWx0ZXIoYyA9PiBjLnZpc2libGVJbmRleCA+IHRoaXMudmlzaWJsZUluZGV4KTtcbiAgICAgICAgICAgIHRhcmdldCA9IGNvbHVtbnMuZmluZChjID0+IGMubGV2ZWwgPT09IHRoaXMubGV2ZWwgJiYgYy52aXNpYmxlSW5kZXggKyBjLmNhbGNDaGlsZHJlbigpIC0gdGhpcy5jYWxjQ2hpbGRyZW4oKSA9PT0gaW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sdW1ucyA9IGNvbHVtbnMuZmlsdGVyKGMgPT4gYy52aXNpYmxlSW5kZXggPCB0aGlzLnZpc2libGVJbmRleCk7XG4gICAgICAgICAgICB0YXJnZXQgPSBjb2x1bW5zLmZpbmQoYyA9PiBjLmxldmVsID09PSB0aGlzLmxldmVsICYmIGMudmlzaWJsZUluZGV4ID09PSBpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRhcmdldCB8fCAodGFyZ2V0LnBpbm5lZCAmJiB0aGlzLmRpc2FibGVQaW5uaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcG9zID0gaXNQcmVjZWRpbmcgPyBEcm9wUG9zaXRpb24uQWZ0ZXJEcm9wVGFyZ2V0IDogRHJvcFBvc2l0aW9uLkJlZm9yZURyb3BUYXJnZXQ7XG4gICAgICAgIGdyaWQubW92ZUNvbHVtbih0aGlzLCB0YXJnZXQgYXMgSWd4Q29sdW1uQ29tcG9uZW50LCBwb3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vIGNoaWxkcmVuIGZvciB0aGUgY29sdW1uLCBzbyB3aWxsIHJldHVybnMgMSBvciAwLCBpZiB0aGUgY29sdW1uIGlzIGhpZGRlbi5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2FsY0NoaWxkcmVuKCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5oaWRkZW4gPyAwIDogMTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgY29sdW1uIHZpYmlzaWxpdHkgYW5kIGVtaXRzIHRoZSByZXNwZWN0aXZlIGV2ZW50LlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGVWaXNpYmlsaXR5KHZhbHVlPzogYm9vbGVhbikge1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID8/ICF0aGlzLmhpZGRlbjtcbiAgICAgICAgY29uc3QgZXZlbnRBcmdzOiBJQ29sdW1uVmlzaWJpbGl0eUNoYW5naW5nRXZlbnRBcmdzID0geyBjb2x1bW46IHRoaXMsIG5ld1ZhbHVlLCBjYW5jZWw6IGZhbHNlIH07XG4gICAgICAgIHRoaXMuZ3JpZC5jb2x1bW5WaXNpYmlsaXR5Q2hhbmdpbmcuZW1pdChldmVudEFyZ3MpO1xuXG4gICAgICAgIGlmIChldmVudEFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oaWRkZW4gPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5ncmlkLmNvbHVtblZpc2liaWxpdHlDaGFuZ2VkLmVtaXQoeyBjb2x1bW46IHRoaXMsIG5ld1ZhbHVlIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHRvcCBsZXZlbCBwYXJlbnQgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgdG9wTGV2ZWxQYXJlbnQgPSAgdGhpcy5jb2x1bW4udG9wTGV2ZWxQYXJlbnQ7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldCB0b3BMZXZlbFBhcmVudCgpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBoZWFkZXIgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbiA9IHRoaXMuZ3JpZC5jb2x1bW5MaXN0LmZpbHRlcihjID0+IGMuZmllbGQgPT09ICdJRCcpWzBdO1xuICAgICAqIGxldCBoZWFkZXJDZWxsID0gY29sdW1uLmhlYWRlckNlbGw7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldCBoZWFkZXJDZWxsKCk6IElneEdyaWRIZWFkZXJDb21wb25lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmhlYWRlckNlbGxMaXN0LmZpbmQoKGhlYWRlcikgPT4gaGVhZGVyLmNvbHVtbiA9PT0gdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgZmlsdGVyIGNlbGwgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbiA9IHRoaXMuZ3JpZC5jb2x1bW5MaXN0LmZpbHRlcihjID0+IGMuZmllbGQgPT09ICdJRCcpWzBdO1xuICAgICAqIGxldCBmaWx0ZXJlbGwgPSBjb2x1bW4uZmlsdGVyZWxsO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZmlsdGVyQ2VsbCgpOiBJZ3hHcmlkRmlsdGVyaW5nQ2VsbENvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZmlsdGVyQ2VsbExpc3QuZmluZCgoZmlsdGVyQ2VsbCkgPT4gZmlsdGVyQ2VsbC5jb2x1bW4gPT09IHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGhlYWRlciBncm91cCBvZiB0aGUgY29sdW1uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaGVhZGVyR3JvdXAoKTogSWd4R3JpZEhlYWRlckdyb3VwQ29tcG9uZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5oZWFkZXJHcm91cHNMaXN0LmZpbmQoZ3JvdXAgPT4gZ3JvdXAuY29sdW1uID09PSB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdXRvc2l6ZSB0aGUgY29sdW1uIHRvIHRoZSBsb25nZXN0IGN1cnJlbnRseSB2aXNpYmxlIGNlbGwgdmFsdWUsIGluY2x1ZGluZyB0aGUgaGVhZGVyIGNlbGwuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoJ2dyaWQnKSBncmlkOiBJZ3hHcmlkQ29tcG9uZW50O1xuICAgICAqIGxldCBjb2x1bW4gPSB0aGlzLmdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLmZpZWxkID09PSAnSUQnKVswXTtcbiAgICAgKiBjb2x1bW4uYXV0b3NpemUoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKiBAcGFyYW0gYnlIZWFkZXJPbmx5IFNldCBpZiBjb2x1bW4gc2hvdWxkIGJlIGF1dG9zaXplZCBiYXNlZCBvbmx5IG9uIHRoZSBoZWFkZXIgY29udGVudC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXV0b3NpemUoYnlIZWFkZXJPbmx5ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5nZXRBdXRvU2l6ZShieUhlYWRlck9ubHkpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLnJlZmxvdygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRBdXRvU2l6ZShieUhlYWRlciA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSAhYnlIZWFkZXIgPyB0aGlzLmdldExhcmdlc3RDZWxsV2lkdGgoKSA6XG4gICAgICAgICAgICAoT2JqZWN0LnZhbHVlcyh0aGlzLmdldEhlYWRlckNlbGxXaWR0aHMoKSkucmVkdWNlKChhLCBiKSA9PiBhICsgYikgKyAncHgnKTtcbiAgICAgICAgY29uc3QgaXNQZXJjZW50YWdlV2lkdGggPSB0aGlzLndpZHRoICYmIHR5cGVvZiB0aGlzLndpZHRoID09PSAnc3RyaW5nJyAmJiB0aGlzLndpZHRoLmluZGV4T2YoJyUnKSAhPT0gLTE7XG5cbiAgICAgICAgbGV0IG5ld1dpZHRoO1xuICAgICAgICBpZiAoaXNQZXJjZW50YWdlV2lkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyaWRBdmFpbGFibGVTaXplID0gdGhpcy5ncmlkLmNhbGNXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRhZ2VTaXplID0gcGFyc2VGbG9hdChzaXplKSAvIGdyaWRBdmFpbGFibGVTaXplICogMTAwO1xuICAgICAgICAgICAgbmV3V2lkdGggPSBwZXJjZW50YWdlU2l6ZSArICclJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gaXNQZXJjZW50YWdlV2lkdGggPyB0aGlzLm1heFdpZHRoUGVyY2VudCA6IHRoaXMubWF4V2lkdGhQeDtcbiAgICAgICAgY29uc3QgbWluV2lkdGggPSBpc1BlcmNlbnRhZ2VXaWR0aCA/IHRoaXMubWluV2lkdGhQZXJjZW50IDogdGhpcy5taW5XaWR0aFB4O1xuICAgICAgICBpZiAodGhpcy5tYXhXaWR0aCAmJiAocGFyc2VGbG9hdChuZXdXaWR0aCkgPiBtYXhXaWR0aCkpIHtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gaXNQZXJjZW50YWdlV2lkdGggPyBtYXhXaWR0aCArICclJyA6IG1heFdpZHRoICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIGlmIChwYXJzZUZsb2F0KG5ld1dpZHRoKSA8IG1pbldpZHRoKSB7XG4gICAgICAgICAgICBuZXdXaWR0aCA9IGlzUGVyY2VudGFnZVdpZHRoID8gbWluV2lkdGggKyAnJScgOiBtaW5XaWR0aCArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3V2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDYWxjV2lkdGgoKTogYW55IHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbGNXaWR0aCAmJiAhaXNOYU4odGhpcy5jYWxjUGl4ZWxXaWR0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxjV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZUNhbGNXaWR0aCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY1dpZHRoO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIGFuZCBwYWRkaW5nIG9mIGEgaGVhZGVyIGNlbGwuXG4gICAgICovXG4gICAgcHVibGljIGdldEhlYWRlckNlbGxXaWR0aHMoKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5ncmlkLmRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG5cbiAgICAgICAgLy8gV2UgZG8gbm90IGNvdmVyIGNhc2VzIHdoZXJlIHRoZXJlIGFyZSBjaGlsZHJlbiB3aXRoIHdpZHRoIDEwMCUgYW5kIGV0YyxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGVuIHdlIHRyeSB0byBnZXQgbmV3IGNvbHVtbiBzaXplLCBiYXNlZCBvbiBoZWFkZXIgY29udGVudCwgd2hpY2ggaXMgc2l6ZWQgYmFzZWQgb24gY29sdW1uIHNpemUuLi5cbiAgICAgICAgY29uc3QgaGVhZGVyV2lkdGggPSB0aGlzLnBsYXRmb3JtLmdldE5vZGVTaXplVmlhUmFuZ2UocmFuZ2UsXG4gICAgICAgICAgICB0aGlzLmhlYWRlckNlbGwubmF0aXZlRWxlbWVudCxcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyR3JvdXAubmF0aXZlRWxlbWVudCk7XG5cbiAgICAgICAgY29uc3QgaGVhZGVyU3R5bGUgPSB0aGlzLmdyaWQuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmhlYWRlckNlbGwubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGhlYWRlclBhZGRpbmcgPSBwYXJzZUZsb2F0KGhlYWRlclN0eWxlLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQoaGVhZGVyU3R5bGUucGFkZGluZ1JpZ2h0KSArXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGhlYWRlclN0eWxlLmJvcmRlclJpZ2h0V2lkdGgpO1xuXG4gICAgICAgIC8vIFRha2UgaW50byBjb25zaWRlcmF0aW9uIHRoZSBoZWFkZXIgZ3JvdXAgZWxlbWVudCwgc2luY2UgY29sdW1uIHBpbm5pbmcgYXBwbGllcyBib3JkZXJzIHRvIGl0IGlmIGl0cyBub3QgYSBjb2x1bW5Hcm91cC5cbiAgICAgICAgY29uc3QgaGVhZGVyR3JvdXBTdHlsZSA9IHRoaXMuZ3JpZC5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuaGVhZGVyR3JvdXAubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGJvcmRlclNpemUgPSAhdGhpcy5wYXJlbnQgPyBwYXJzZUZsb2F0KGhlYWRlckdyb3VwU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCkgKyBwYXJzZUZsb2F0KGhlYWRlckdyb3VwU3R5bGUuYm9yZGVyTGVmdFdpZHRoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IE1hdGguY2VpbChoZWFkZXJXaWR0aCksIHBhZGRpbmc6IE1hdGguY2VpbChoZWFkZXJQYWRkaW5nICsgYm9yZGVyU2l6ZSkgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUmV0dXJucyB0aGUgc2l6ZSAoaW4gcGl4ZWxzKSBvZiB0aGUgbG9uZ2VzdCBjdXJyZW50bHkgdmlzaWJsZSBjZWxsLCBpbmNsdWRpbmcgdGhlIGhlYWRlciBjZWxsLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKCdncmlkJykgZ3JpZDogSWd4R3JpZENvbXBvbmVudDtcbiAgICAgKlxuICAgICAqIGxldCBjb2x1bW4gPSB0aGlzLmdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLmZpZWxkID09PSAnSUQnKVswXTtcbiAgICAgKiBsZXQgc2l6ZSA9IGNvbHVtbi5nZXRMYXJnZXN0Q2VsbFdpZHRoKCk7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRMYXJnZXN0Q2VsbFdpZHRoKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5ncmlkLmRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIGNvbnN0IGxhcmdlc3QgPSBuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpO1xuXG4gICAgICAgIGlmICh0aGlzLl9jZWxscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsc0NvbnRlbnRXaWR0aHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NlbGxzLmZvckVhY2goKGNlbGwpID0+IGNlbGxzQ29udGVudFdpZHRocy5wdXNoKGNlbGwuY2FsY3VsYXRlU2l6ZVRvRml0KHJhbmdlKSkpO1xuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNlbGxzQ29udGVudFdpZHRocy5pbmRleE9mKE1hdGgubWF4KC4uLmNlbGxzQ29udGVudFdpZHRocykpO1xuICAgICAgICAgICAgY29uc3QgY2VsbFN0eWxlID0gdGhpcy5ncmlkLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5fY2VsbHNbaW5kZXhdLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgY2VsbFBhZGRpbmcgPSBwYXJzZUZsb2F0KGNlbGxTdHlsZS5wYWRkaW5nTGVmdCkgKyBwYXJzZUZsb2F0KGNlbGxTdHlsZS5wYWRkaW5nUmlnaHQpICtcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGNlbGxTdHlsZS5ib3JkZXJMZWZ0V2lkdGgpICsgcGFyc2VGbG9hdChjZWxsU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCk7XG5cbiAgICAgICAgICAgIGxhcmdlc3Quc2V0KE1hdGgubWF4KC4uLmNlbGxzQ29udGVudFdpZHRocyksIGNlbGxQYWRkaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhlYWRlckNlbGwgJiYgdGhpcy5hdXRvc2l6ZUhlYWRlcikge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyQ2VsbFdpZHRocyA9IHRoaXMuZ2V0SGVhZGVyQ2VsbFdpZHRocygpO1xuICAgICAgICAgICAgbGFyZ2VzdC5zZXQoaGVhZGVyQ2VsbFdpZHRocy53aWR0aCwgaGVhZGVyQ2VsbFdpZHRocy5wYWRkaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhcmdlc3RDZWxsID0gTWF0aC5tYXgoLi4uQXJyYXkuZnJvbShsYXJnZXN0LmtleXMoKSkpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChsYXJnZXN0Q2VsbCArIGxhcmdlc3QuZ2V0KGxhcmdlc3RDZWxsKSk7XG5cbiAgICAgICAgaWYgKE51bWJlci5pc05hTih3aWR0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHdpZHRoICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q2VsbFdpZHRoKCkge1xuICAgICAgICBjb25zdCBjb2xXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIGNvbnN0IGlzUGVyY2VudGFnZVdpZHRoID0gY29sV2lkdGggJiYgdHlwZW9mIGNvbFdpZHRoID09PSAnc3RyaW5nJyAmJiBjb2xXaWR0aC5pbmRleE9mKCclJykgIT09IC0xO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkxheW91dENoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sV2lkdGggJiYgIWlzUGVyY2VudGFnZVdpZHRoKSB7XG5cbiAgICAgICAgICAgIGxldCBjZWxsV2lkdGggPSBjb2xXaWR0aDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2VsbFdpZHRoICE9PSAnc3RyaW5nJyB8fCBjZWxsV2lkdGguZW5kc1dpdGgoJ3B4JykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoICs9ICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjZWxsV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29sV2lkdGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHBvcHVsYXRlVmlzaWJsZUluZGV4ZXMoKSB7IH1cblxuICAgIHByb3RlY3RlZCBnZXRDb2x1bW5TaXplc1N0cmluZyhjaGlsZHJlbjogUXVlcnlMaXN0PElneENvbHVtbkNvbXBvbmVudD4pOiBzdHJpbmcge1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLmdldEZpbGxlZENoaWxkQ29sdW1uU2l6ZXMoY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gcmVzLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNhY2hlQ2FsY1dpZHRoKCk6IGFueSB7XG4gICAgICAgIGNvbnN0IGdyaWQgPSB0aGlzLmdyaWRBUEkuZ3JpZDtcbiAgICAgICAgY29uc3QgY29sV2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IGNvbFdpZHRoICYmIHR5cGVvZiBjb2xXaWR0aCA9PT0gJ3N0cmluZycgJiYgY29sV2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcbiAgICAgICAgaWYgKGlzUGVyY2VudGFnZVdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjV2lkdGggPSBwYXJzZUZsb2F0KGNvbFdpZHRoKSAvIDEwMCAqIGdyaWQuY2FsY1dpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKCFjb2xXaWR0aCkge1xuICAgICAgICAgICAgLy8gbm8gd2lkdGhcbiAgICAgICAgICAgIHRoaXMuX2NhbGNXaWR0aCA9IHRoaXMuZGVmYXVsdFdpZHRoIHx8IGdyaWQuZ2V0UG9zc2libGVDb2x1bW5XaWR0aCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2FsY1dpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGNQaXhlbFdpZHRoID0gcGFyc2VGbG9hdCh0aGlzLl9jYWxjV2lkdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc2V0RXhwYW5kQ29sbGFwc2VTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5maWx0ZXIoY29sID0+IChjb2wudmlzaWJsZVdoZW5Db2xsYXBzZWQgIT09IHVuZGVmaW5lZCkpLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29sbGFwc2libGUpIHtcbiAgICAgICAgICAgICAgICBjLmhpZGRlbiA9IHRoaXMuaGlkZGVuOyByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjLmhpZGRlbiA9IHRoaXMuX2V4cGFuZGVkID8gYy52aXNpYmxlV2hlbkNvbGxhcHNlZCA6ICFjLnZpc2libGVXaGVuQ29sbGFwc2VkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjaGVja0NvbGxhcHNpYmxlU3RhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC52aXNpYmxlV2hlbkNvbGxhcHNlZCk7XG4gICAgICAgIHJldHVybiAoY29scy5zb21lKGMgPT4gYyA9PT0gdHJ1ZSkgJiYgY29scy5zb21lKGMgPT4gYyA9PT0gZmFsc2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBwaW5uYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdyaWQgYXMgYW55KS5faW5pdCB8fCAhdGhpcy5waW5uZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgYXBwbHlTZWxlY3RhYmxlQ2xhc3MoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseVNlbGVjdGFibGVDbGFzcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHNldCBhcHBseVNlbGVjdGFibGVDbGFzcyh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBseVNlbGVjdGFibGVDbGFzcyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19